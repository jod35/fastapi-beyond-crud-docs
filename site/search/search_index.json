{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"FastAPI Beyond CRUD","text":"<p>This course material is tailored for my FastAPI Framework course. FastAPI has quickly emerged as one of Python's leading frameworks for crafting server-side web applications. I'm excited to present this comprehensive course, dedicated to helping you understand API development with FastAPI. I trust you'll find immense value in it as we delve into the complexities of building robust APIs.</p>"},{"location":"#about-me","title":"About Me:","text":"<p>My name is Ssali Jonathan. I am a software engineer based in Uganda. For about 3 years, I have been building a Youtube channel where I educate people about programming mainly using the Python language. I have worked on freelance, and fulltime roles. I have a passion for educating others and sharing knowledge.</p>"},{"location":"#please-donate-to-the-project","title":"Please donate to the project","text":"<p>I have made this course available for free on my Youtube channel and on this website. If you can support me to create more projects like this, please consider donating to my work using the following channels.</p> <p>Buy me a coffee</p> <p>Become a Patreon </p>"},{"location":"#follow-me-on-the-following-platforms","title":"Follow me on the following platforms","text":"<ul> <li>Twitter</li> <li>Github</li> <li>Youtube</li> </ul> <p>Next Project SetUp and Installation</p>"},{"location":"chapter1/","title":"Installation and Project SetUp","text":"<p>In chapter, we install FastAPI, starting with a minimal setup.</p>"},{"location":"chapter1/#1-virtual-environment-creation","title":"1. Virtual Environment Creation","text":"<p>Begin by creating a virtual environment using the built-in Python module <code>venv</code>. If you already have Python installed, you might not need to install it separately. However, on Linux, installation may be necessary based on your distribution. In your commandline or terminal, type the following command.</p> <pre><code>python3 -m venv env\n</code></pre> <p>This command generates a virtual environment in the specified folder (in our example, <code>env</code>). This folder is an isolated Python environment which shall separate the dependencies of our project from the system wide Python installation.</p> <p>Activate the virtual environment using the following commands:</p> <p>On Linux or macOS: <pre><code>source env/bin/activate\n</code></pre></p> <p>On Windows: <pre><code>env/Scripts/activate\n</code></pre></p> <p>Once activated, your command line will indicate the active virtual environment:</p> <p>On Linux or macOS: <pre><code>(env) yourusername@yourmachine$\n</code></pre></p> <p>On Windows: <pre><code>(env) C:\\users\\YourUsername&gt;\n</code></pre></p>"},{"location":"chapter1/#2-directory-structure","title":"2. Directory Structure","text":"<p>At this point, your directory structure should look like this:</p> <pre><code>\u2514\u2500\u2500 env\n</code></pre>"},{"location":"chapter1/#3-installing-fastapi","title":"3. Installing FastAPI","text":"<p>Now, let us install FastAPI within the virtual environment. We shall install FastAPI with the <code>pip</code> using the following command. </p> <pre><code>(env) pip install fastapi\n</code></pre>"},{"location":"chapter1/#4-freeze-dependencies","title":"4. Freeze Dependencies","text":"<p>Freeze the installed dependencies into a <code>requirements.txt</code> file to track the exact versions of our dependencies so that we can easily reproduce them in the future.</p> <pre><code>(env) pip freeze &gt; requirements.txt\n</code></pre>"},{"location":"chapter1/#5-confirm-the-installation","title":"5. Confirm the installation","text":"<p>Let us confirm our fastapi installation by running the following command. <pre><code>(env) fastapi --version\nFastAPI CLI version: 0.0.2\n</code></pre> This command shall show us the version of FastAPI CLI the FastAPI commandline interface. The <code>fastapi</code> command shall help us run and manage our app as we shall see in the coming chapters.</p> <p>If the version has been displayed, then we are sure that FastAPI has been installed in our virtual environment.</p>"},{"location":"chapter1/#conclusion","title":"Conclusion","text":"<p>By following these steps, you have successfully set up a virtual environment, and installed FastAPI, frozen the dependencies for future reproducing of the project and you have verified your installation using the <code>fastapi</code> CLI command. This structured approach ensures a clean and manageable development environment for our FastAPI project. Next, we shall create a simple web server and create our first API routes.</p> <p>Previous Introduction</p> <p>Next Creating a Simple Web Server</p>"},{"location":"chapter2/","title":"Creating a Simple Web Server","text":""},{"location":"chapter2/#introduction","title":"Introduction","text":"<p>Now that we have FastAPI installed, we are going to create a simple web server on whicn our application shall run using FastAPI.</p> <p>At this stage, our directory only contains our virtual environment directory <code>env</code> and <code>requirements.txt</code> as shown below as follows: <pre><code>\u2514\u2500\u2500 env\n\u2514\u2500\u2500 requirements.txt\n</code></pre></p> <p>Let's create a file named <code>main.py</code> and populate it with the following code:</p> <pre><code>from fastapi import FastAPI\n\napp = FastAPI()\n\n@app.get('/')\nasync def read_root():\n    return {\"message\": \"Hello World!\"}\n</code></pre> <p>In this code snippet, we perform the following actions:</p>"},{"location":"chapter2/#creating-a-fastapi-instance","title":"Creating a FastAPI instance:","text":"<p>We have imported the <code>FastAPI</code> class from the <code>fastapi</code> package. This class serves as the primary entry point for all FastAPI applications. Through it we can get access to various FastAPI features such as routes , middleware, exception handlers and path operations.</p> <p>We then create an instance of the <code>FastAPI</code> class named <code>app</code>. The main FastAPI instance can be called anything as long as it is a valid Python name. </p> <pre><code>from fastapi import FastAPI\n\napp = FastAPI()\n</code></pre>"},{"location":"chapter2/#creating-an-api-route","title":"Creating an API Route:","text":"<p>We define our first API route by creating a function named <code>read_root</code>. This function, when accessed, will return a JSON message containing \"Hello World!\".</p> <pre><code>@app.get('/')\nasync def read_root():\n    return {\"message\": \"Hello World!\"}\n</code></pre> <p>The <code>@app</code> decorator associates the function with the HTTP GET method  via the <code>get</code> method. We then provide the path (route) of the root path (<code>/</code>). This means that whenever the <code>/</code> route is accessed, the defined message will be returned.</p> <p>All HTTP methods such as <code>post</code>,<code>put</code>,<code>head</code>,<code>patch</code>, <code>delete</code>, <code>trace</code> and <code>options</code> are all available on the <code>@app</code> decorator.</p>"},{"location":"chapter2/#running-the-fastapi-application","title":"Running the FastAPI Application:","text":"<p>To run our FastAPI application, we shall use the <code>fastapi</code>command we introduced in the previous chapter. Open a terminal and execute the following command within the virtual environment:</p> <pre><code>(env)$ fastapi dev main.py\n</code></pre> <p>The <code>fastapi dev</code> command enables us to execute our FastAPI application in development mode. This feature facilitates running our application with auto-reload functionality, ensuring that any modifications we make are automatically applied, restarting the server accordingly. It operates by identifying the FastAPI instance within the specified module or Python package, which in our scenario is <code>main.py</code>, where we have defined the app object. When we initiate our application, it will display the following output. <pre><code>INFO     Using path main.py                                                                              \nINFO     Resolved absolute path /home/jod35/Documents/fastapi-beyond-CRUD/main.py                         \nINFO     Searching for package file structure from directories with __init__.py files                 \nINFO     Importing from /home/jod35/Documents/fastapi-beyond-CRUD                                     \n\n \u256d\u2500 Python package file structure \u2500\u256e                                                                  \n \u2502                                 \u2502                                                                  \n \u2502      \ud83d\udc0d main.py                 \u2502                                                                  \n \u2502                                 \u2502                                                                  \n \u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f                                                                  \n\nINFO     Importing module main.py                                                                       \nINFO     Found importable FastAPI app                                                                 \n\n \u256d\u2500 Importable FastAPI app \u2500\u256e                                                                         \n \u2502                          \u2502                                                                         \n \u2502  from main import app    \u2502                                                                         \n \u2502                          \u2502                                                                         \n \u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f                                                                         \n\nINFO     Using import string main:app                                                                  \n\n \u256d\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 FastAPI CLI - Development mode \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e                                              \n \u2502                                                     \u2502                                              \n \u2502  Serving at: http://127.0.0.1:8000                  \u2502                                              \n \u2502                                                     \u2502                                              \n \u2502  API docs: http://127.0.0.1:8000/docs               \u2502                                              \n \u2502                                                     \u2502                                              \n \u2502  Running in development mode, for production use:   \u2502                                              \n \u2502                                                     \u2502                                              \n \u2502  fastapi run                                        \u2502                                              \n \u2502                                                     \u2502    \n</code></pre></p> <p>Running the server will make your application available at this web address: <code>http://localhost:8000</code>.</p> <p>Following these steps means you've successfully created a basic FastAPI application with a greeting endpoint. You've also learned how to start the application using Uvicorn, which helps you develop more easily because it automatically reloads your code when you make changes.</p>"},{"location":"chapter2/#choosing-an-api-client","title":"Choosing an API Client","text":"<p>Depending on your choice, you may want to test your application with an Api Client, I will begin with Insomnia which is a simple open source application for testing and development APIs.</p> <p>In insomnia, we shall create our simple request collection and we shall now see our response of <code>Hello World</code>.</p> <ol> <li> <p>Create a new request collection </p> </li> <li> <p>Name the request collection </p> </li> <li> <p>Create an HTTP request </p> </li> <li> <p>Make a request </p> </li> </ol> <p>And just like that, you have created your FastAPI application, run it and even made your HTTP request using an HTTP client.</p>"},{"location":"chapter2/#managing-requests-and-responses","title":"Managing Requests and Responses","text":"<p>There are very many ways that clients can pass request data to a FastAPI API route. These include: - Path Parameters - Query Parameters - Headers e.t.c.</p> <p>Through such ways, we can obtain data from incoming requests to our APIs.</p>"},{"location":"chapter2/#parameter-type-declarations","title":"Parameter type declarations","text":"<p>All parameters in a FastAPI request are requiresd to have a type declaration via type hints. Primitive Python types such (<code>None</code>,<code>int</code>,<code>str</code>,<code>bool</code>,<code>float</code>), container types such as (<code>dict</code>,<code>tuples</code>,<code>dict</code>,<code>set</code>) and some other complex types are all supported. </p> <p>Additionally FastAPI also allows all types present within Python's <code>typing</code> module.  These data types represent common conventions in Python and are utilized for variable type annotations. They facilitate type checking and model validation during compilation. Examples include <code>Optional</code>, <code>List</code>, <code>Dict</code>, <code>Set</code>, <code>Union</code>, <code>Tuple</code>, <code>FrozenSet</code>, <code>Iterable</code>, and <code>Deque</code>.</p>"},{"location":"chapter2/#path-parameters","title":"Path Parameters","text":"<p>All request data supplied in the endpoint URL of a FastAPI API is acquired through a path parameter, thus rendering URLs dynamic. FastAPI adopts curly braces (<code>{}</code>) to denote path parameters when defining a URL. Once enclosed within the braces, FastAPI requires that they be provided as parameters to the route handler functions we establish for those paths.</p> <pre><code>#inside main.py\n@app.get('/greet/{username}')\nasync def greet(username:str):\n   return {\"message\":f\"Hello {username}\"}\n</code></pre> <p>In this example the <code>greet()</code> route handler function will require <code>username</code> which is annotated with <code>str</code> indicating that the username shall be a string. Sending a greetings to the user \"jona\" shall return the response shown below.</p> <p></p> <p>Just in we make a request to the route without the param,  </p>"},{"location":"chapter2/#query-parameters","title":"Query Parameters","text":"<p>These are key-value pairs provided at the end of a URL, indicated by a question mark (<code>?</code>). Just like path parameters, they also take in request data. Whenever we want to provide multiple query parameters, we use the ampersand (<code>&amp;</code>) sign.</p> <pre><code># inside main.py\n\nuser_list = [\n   \"Jerry\",\n   \"Joey\",\n   \"Phil\"\n] \n\n@app.get('/search')\nasync def search_for_user(username:str):\n   for user in user_list:\n    if username in user_list :\n        return {\"message\":f\"details for user {username}\"}\n\n    else:\n        return {\"message\":\"User Not Found\"}\n</code></pre> <p>In this example, we've set up a route for searching users within a simple list. Notice that there are no path parameters specified in the route's URL. Instead, we're passing the <code>username</code> directly to our route handler, <code>search_for_user</code>. In FastAPI, any parameter passed to a route handler, like <code>search_for_user</code>, and is not provided in the path as a path param is treated as a query parameter. Therefore, to access this route, we need to use <code>/search?username=sample_name</code>, where <code>username</code> is the key and <code>sample_name</code> is the value.</p> <p>Let us save and test the example above. Saecrning for a user who exists returns the needed response.</p> <p></p> <p>And searching for a user who does not exist returns the following response.  </p>"},{"location":"chapter2/#optional-parameters","title":"Optional Parameters","text":"<p>There may also be cases when the API route can operate as needed even in the presence of a path or query param. In this case, we can make the parameters optional when annotating their types in the route handler functions. Forexample, our first example can be modified to the following: <pre><code>from typing import Optional\n\n@app.get('/greet/')\nasync def greet(username:Optional[str]=\"User\"):\n   return {\"message\":f\"Hello {username}\"}\n</code></pre></p> <p>This time, we've made the <code>username</code> path parameter optional. We achieved this by removing it from the route definition. Additionally, we updated the type annotation for the <code>username</code> parameter in the <code>greet</code> route handler function to make it an optional string, with a default value of \"User\". To accomplish this, we're using the <code>Optional</code> type from Python's <code>typing</code> module. <pre><code>username:Optional[str]\n</code></pre></p> <p>When we save the example, we shall test it and get the following response. </p> <p>Note that this time if we do not provide the <code>username</code>, we shall get the default username of \"User\". </p>"},{"location":"chapter2/#request-body","title":"Request Body","text":"<p>Frequently, clients need to send data to the server for tasks like creating or updating resources through methods like POST, PATCH, PUT, DELETE, or for various other operations. FastAPI simplifies this process by enabling you to define a Pydantic model to establish the structure of the data being sent. Furthermore, it aids in validating data types using type hints. Let's delve into a straightforward example to illustrate this concept.</p> <pre><code># inside main.py\nfrom pydantic import BaseModel\n\n# the User model\nclass UserSchema(BaseModel):\n   username:str\n   email:str\n\n\n@app.post(\"/create_user\")\nasync def create_user(user_data:UserSchema):\n   new_user = {\n      \"username\" : user_data.username,\n      \"email\": user_data.email\n   }\n\n   users.append(new_user)\n\n   return {\"message\":\"User Created successfully\",\"user\":new_user}\n</code></pre> <p>What we have done in the above example is to create a Pydantic model by inheriting Pydantic's <code>BaseModel</code> class. On this class we have defined attributes <code>username</code> and <code>email</code> and also annotated them with the <code>str</code> type.  <pre><code>class UserSchema(BaseModel):\n   username:str\n   email:str\n</code></pre></p> <p>Following that, have crafted an API route intended to handle a POST request at /create_user. The handler for this route accepts a parameter representing the user_data obtained from the client, with its type annotated as the Pydantic model UserSchema. <pre><code>create_user(user_data:UserSchema)\n</code></pre></p> <p>Using this <code>user_data</code>, we construct a new_user dictionary and append it to our users list. <pre><code>   new_user = {\n      \"username\" : user_data.username,\n      \"email\": user_data.email\n   }\n\n   users.append(new_user)\n</code></pre></p> <p>We finally return a response with the newly created <code>new_user</code> dictionary. </p> <pre><code>   return {\"message\":\"User Created successfully\",\"user\":new_user}\n</code></pre> <p>Let's test this. If we make the request without providing the request body, we should receive the following response. </p> <p>Please note that we will receive the <code>422 Unprocessable Entity</code> status code because FastAPI failed to retrieve data from the request body, as it has not been provided.</p> <p>When we provide the body without the required fields, we will receive the following output. </p> <p>We will receive the same output, but this time we will be notified that the required fields (<code>email</code>,<code>username</code>) for the data are missing.</p> <p>Let us now provide valid data.</p> <p></p> <p>Supplying valid values for the <code>email</code> and <code>username</code> fields will result in a successful response.</p>"},{"location":"chapter2/#note","title":"Note","text":"<p>There can indeed be scenarios that necessitate the use of all the features we've discussed. You can have an API route that accepts path, query, and optional parameters, and FastAPI is capable of handling such complexity seamlessly.</p>"},{"location":"chapter2/#request-headers","title":"Request Headers","text":"<p>During a request-response transaction, the client not only sends parameters to the server but also provides information about the context of the request's origin. This contextual information is crucial as it enables the server to customize the type of response it returns to the client.</p> <p>Common request headers include: - <code>User-Agent</code>: This string allows network protocol peers to identify the application responsible for the request, the operating system it's running on, or the version of the software being used.</p> <ul> <li> <p><code>Host</code>: This specifies the domain name of the server, and (optionally) the TCP port number on which the server is listening.</p> </li> <li> <p><code>Accept</code>: Informs the server about the types of data that can be sent back.</p> </li> <li> <p><code>Accept-Language</code>: This header informs the server about the preferred human language for the response.</p> </li> <li> <p><code>Accept-Encoding</code>: The encoding algorithm, usually a compression algorithm, that can be used on the resource sent back.</p> </li> <li> <p><code>Referer</code>: This specifies the address of the previous web page from which a link to the currently requested page was followed.</p> </li> <li> <p><code>Connection</code>: This header controls whether the network connection stays open after the current transaction finishes. </p> </li> </ul> <p>To access such headers, FastAPI provides us with the <code>Header</code> function giving us the ability to get the values of these headers using the exact names but in a snake-case syntax forexample, <code>User-Agent</code> is <code>user_agent</code>, <code>Accept-Encoding</code> is <code>accept_encoding</code> and so on. Let us take a look at a small code example.</p> <p><pre><code># inside main.py\n@app.get('/get_headers')\nasync def get_all_request_headers(\n    user_agent: Optional[str] = Header(None),\n    accept_encoding: Optional[str] = Header(None),\n    referer: Optional[str] = Header(None),\n    connection: Optional[str] = Header(None),\n    accept_language: Optional[str] = Header(None),\n    host: Optional[str] = Header(None),\n):\n    request_headers = {}\n    request_headers[\"User-Agent\"] = user_agent\n    request_headers[\"Accept-Encoding\"] = accept_encoding\n    request_headers[\"Referer\"] = referer\n    request_headers[\"Accept-Language\"] = accept_language\n    request_headers[\"Connection\"] = connection\n    request_headers[\"Host\"] = host\n\n    return request_headers\n</code></pre> We've started by importing the <code>Header</code> function from FastAPI into our route handler. Each header has been added and designated as an optional string. A default value has been assigned by invoking the <code>Header</code> function with <code>None</code> as a parameter.  Using the <code>None</code> argument allows the Header() function to declare the variable optionally, which aligns with best practices.</p> <pre><code>    user_agent: Optional[str] = Header(None)\n</code></pre> <p>we have then created a request_headers dictionary with the names of the headers as keys and the values as what we get by calling the <code>Header</code> function.</p> <p>Making a request to the <code>/get_headers</code> route shall return the following response depending on how you have made the request. For my case, </p>"},{"location":"chapter2/#conclusion","title":"Conclusion","text":"<p>In this chapter, we utilized FastAPI to construct a basic web server and delved into different methods of communicating and inputting data. We introduced concepts such as path and query parameters, along with request headers. Moving forward, the next chapter will focus on developing a straightforward CRUD API for managing book resources utilizing an in-memory database.</p> <p>Next Creating a simple CRUD API</p> <p>Previous Installation and Configuration</p>"},{"location":"chapter3/","title":"Building a CRUD REST API","text":""},{"location":"chapter3/#what-is-crud","title":"What is CRUD?","text":"<p>CRUD represents the four basic data operations:</p> <ul> <li> <p>Create (C):</p> </li> <li> <p>Objective: Add new data.</p> </li> <li> <p>Action: Insert a new record or entity.</p> </li> <li> <p>Read (R):</p> </li> <li> <p>Objective: Retrieve existing data.</p> </li> <li> <p>Action: Fetch data without modification.</p> </li> <li> <p>Update (U):</p> </li> <li> <p>Objective: Modify existing data.</p> </li> <li> <p>Action: Update attributes or values.</p> </li> <li> <p>Delete (D):</p> </li> <li>Objective: Remove data.</li> <li>Action: Delete a record or entity.</li> </ul> <p>CRUD operations are fundamental in data management, commonly used in applications dealing with data persistence. In FastAPI Beyond CRUD, the focus is on extending FastAPI capabilities beyond typical CRUD applications, exploring advanced features and use cases. But before diving into such aspects, let us build a simple CRUD API using FastAPI.</p>"},{"location":"chapter3/#a-simple-crud-api-implementation","title":"A simple CRUD API implementation","text":"<p>Our simple CRUD API will have a few endpoints to perform CRUD operations on a simple in-memory database of books. Here's a list of endpoints that we shall have in our CRUD API.</p> Endpoint Method Description /books Get Read all books /books POST Create a book /book/{book_id} GET Get a book by id /book/{book_id} PATCH Update a book by id /book/{book_id} DELETE Delete a book by id <p>The provided table describes various API endpoints, their associated HTTP methods, and their functionalities:</p> <ol> <li> <p><code>/books</code> - GET: Read all books</p> </li> <li> <p>Description: This endpoint is designed to retrieve information about all available books. When a client makes an HTTP GET request to <code>/books</code>, the server responds by providing details on all books in the system.</p> </li> <li> <p><code>/books</code> - POST: Create a book</p> </li> <li> <p>Description: To add a new book to the system, clients can make an HTTP POST request to <code>/books</code>. This operation involves creating and storing a new book based on the data provided in the request body.</p> </li> <li> <p><code>/book/{book_id}</code> - GET: Get a book by id</p> </li> <li> <p>Description: By making an HTTP GET request to <code>/book/{book_id}</code>, clients can retrieve detailed information about a specific book. The <code>book_id</code> parameter in the path specifies which book to fetch.</p> </li> <li> <p><code>/book/{book_id}</code> - PATCH: Update a book by id</p> </li> <li> <p>Description: To modify the information of a specific book, clients can send an HTTP PATCH request to <code>/book/{book_id}</code>. The <code>book_id</code> parameter identifies the target book, and the request body contains the updated data.</p> </li> <li> <p><code>/book/{book_id}</code> - DELETE: Delete a book by id</p> </li> <li>Description: This endpoint allows clients to delete a specific book from the system. By sending an HTTP DELETE request to <code>/book/{book_id}</code>, the book identified by <code>book_id</code> will be removed from the records.</li> </ol> <p>Now that we have a plan of our simple API, we can now build our simple CRUD API by adding the following code to <code>main.py</code>. We shall begin by creating a very simple list of books that we will use as our database.</p> <pre><code># in memory database of the books\nbooks = [\n    {\n        \"id\": 1,\n        \"title\": \"Think Python\",\n        \"author\": \"Allen B. Downey\",\n        \"publisher\": \"O'Reilly Media\",\n        \"published_date\": \"2021-01-01\",\n        \"page_count\": 1234,\n        \"language\": \"English\",\n    },\n    {\n        \"id\": 2,\n        \"title\": \"Django By Example\",\n        \"author\": \"Antonio Mele\",\n        \"publisher\": \"Packt Publishing Ltd\",\n        \"published_date\": \"2022-01-19\",\n        \"page_count\": 1023,\n        \"language\": \"English\",\n    },\n    {\n        \"id\": 3,\n        \"title\": \"The web socket handbook\",\n        \"author\": \"Alex Diaconu\",\n        \"publisher\": \"Xinyu Wang\",\n        \"published_date\": \"2021-01-01\",\n        \"page_count\": 3677,\n        \"language\": \"English\",\n    },\n    {\n        \"id\": 4,\n        \"title\": \"Head first Javascript\",\n        \"author\": \"Hellen Smith\",\n        \"publisher\": \"Oreilly Media\",\n        \"published_date\": \"2021-01-01\",\n        \"page_count\": 540,\n        \"language\": \"English\",\n    },\n    {\n        \"id\": 5,\n        \"title\": \"Algorithms and Data Structures In Python\",\n        \"author\": \"Kent Lee\",\n        \"publisher\": \"Springer, Inc\",\n        \"published_date\": \"2021-01-01\",\n        \"page_count\": 9282,\n        \"language\": \"English\",\n    },\n    {\n        \"id\": 6,\n        \"title\": \"Head First HTML5 Programming\",\n        \"author\": \"Eric T Freeman\",\n        \"publisher\": \"O'Reilly Media\",\n        \"published_date\": \"2011-21-01\",\n        \"page_count\": 3006,\n        \"language\": \"English\",\n    },\n]\n</code></pre> <p>Once we have that, we shall build our endpoints on the simple database.</p> <pre><code>from fastapi import FastAPI, status\nfrom fastapi.exceptions import HTTPException\nfrom pydantic import BaseModel\nfrom typing import List\n\n\napp = FastAPI()\n\nclass Book(BaseModel):\n    id: int\n    title: str\n    author: str\n    publisher: str\n    published_date: str\n    page_count: int\n    language: str\n\nclass BookUpdateModel(BaseModel):\n    title: str\n    author: str\n    publisher: str\n    page_count: int\n    language: str\n\n\n@app.get(\"/books\", response_model=List[Book])\nasync def get_all_books():\n    return books\n\n\n@app.post(\"/books\", status_code=status.HTTP_201_CREATED)\nasync def create_a_book(book_data: Book) -&gt; dict:\n    new_book = book_data.model_dump()\n\n    books.append(new_book)\n\n    return new_book\n\n\n@app.get(\"/book/{book_id}\")\nasync def get_book(book_id: int) -&gt; dict:\n    for book in books:\n        if book[\"id\"] == book_id:\n            return book\n\n    raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=\"Book not found\")\n\n\n@app.patch(\"/book/{book_id}\")\nasync def update_book(book_id: int,book_update_data:BookUpdateModel) -&gt; dict:\n\n    for book in books:\n        if book['id'] == book_id:\n            book['title'] = book_update_data.title\n            book['publisher'] = book_update_data.publisher\n            book['page_count'] = book_update_data.page_count\n            book['language'] = book_update_data.language\n\n            return book\n\n    raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=\"Book not found\")\n\n\n@app.delete(\"/book/{book_id}\",status_code=status.HTTP_204_NO_CONTENT)\nasync def delete_book(book_id: int):\n    for book in books:\n        if book[\"id\"] == book_id:\n            books.remove(book)\n\n            return {}\n\n    raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=\"Book not found\")\n</code></pre>"},{"location":"chapter3/#reading-all-books-http-get","title":"Reading All Books (HTTP GET)","text":"<p>This route responds to GET requests made to <code>/books</code>, providing a list of all books available in the application. It ensures that the response adheres to the <code>List[Book]</code> model, guaranteeing consistency with the structure defined by the <code>Book</code> model. <pre><code>class Book(BaseModel):\n    id: int\n    title: str\n    author: str\n    publisher: str\n    published_date: str\n    page_count: int\n    language: str\n\n\n@app.get(\"/books\", response_model=List[Book])\nasync def get_all_books():\n    return books\n</code></pre></p> <p>FastAPI significantly simplifies the process of returning any JSON serializable object as a response.</p>"},{"location":"chapter3/#note","title":"Note","text":"<p>JSON (JavaScript Object Notation) serialization involves transforming a data structure or object from a programming language (such as Python, JavaScript, or others) into a JSON-formatted string. This string representation can then be transmitted over a network or stored in a file, subsequently allowing deserialization back into the original data structure.</p> <p>In Python, the following data types are serializable:</p> <ul> <li>Lists</li> <li>Dictionaries</li> <li>Strings</li> <li>Tuples</li> <li>Booleans</li> <li>None</li> </ul> <p>This capability enables us to effortlessly respond with a list of book objects when issuing a <code>GET</code> request to <code>http://localhost:8000/books</code>, as illustrated below:</p> <p></p>"},{"location":"chapter3/#read-one-book-http-get","title":"Read one Book (HTTP GET)","text":"<p>To retrieve a single book by its ID, the FastAPI application employs the <code>read_book</code> function whenever a request is made to <code>book/{book_id}</code>. The <code>{book_id}</code> serves as a path parameter passed to the <code>read_book</code> function to locate the book with the corresponding ID. The process involves iterating through the list of books to verify the existence of a book with the provided ID. If the book is not found, an <code>HTTPException</code> is raised, signaling that the book resource is not available. Notably, FastAPI's <code>status</code> module facilitates access to status codes, enabling the use of codes such as <code>HTTP_404_NOT_FOUND</code> to indicate resource absence.</p> <pre><code>@app.get(\"/book/{book_id}\")\nasync def get_book(book_id: int) -&gt; dict:\n    for book in books:\n        if book[\"id\"] == book_id:\n            return book\n\n    raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=\"Book not found\")\n</code></pre> <p></p>"},{"location":"chapter3/#adding-a-new-book-http-post","title":"Adding a New Book (HTTP POST)","text":"<p>To facilitate the insertion of a new book into the system, the Book model is utilized to define the structure and constraints for creating a new book resource.</p> <pre><code>from pydantic import BaseModel\n\nclass Book(BaseModel):\n    id: int\n    title: str\n    author: str\n    publisher: str\n    published_date: str\n    page_count: int\n    language: str\n</code></pre> <p>Subsequently, an endpoint is established to enable the addition of a new book. This endpoint is designed to receive data formatted according to the specifications outlined by our Book model. Upon receipt, the incoming data undergoes validation to ensure its adherence to the predefined schema, thereby maintaining data integrity and security. <pre><code>@app.post(\"/books\", status_code=status.HTTP_201_CREATED)\nasync def create_a_book(book_data: Book) -&gt; dict:\n    new_book = book_data.model_dump()\n\n    books.append(new_book)\n\n    return new_book\n</code></pre></p> <p>Upon successful validation, the provided book data is appended to the list of existing books within the system. This systematic approach guarantees the integrity of the data being transmitted to the server. Furthermore, the endpoint is configured to return a status code of 201 (Created) upon successful creation of the new book, signifying the successful addition of the resource.</p> <p>The <code>Book</code> class ensures that the data sent to the server follows the expected format. If invalid data is submitted, the server responds with errors, as shown below when no data is sent:</p> <p></p> <p>Similarly, submitting incomplete or incorrect data results in validation errors:</p> <p></p> <p>On the other hand, sending valid JSON data to the server creates a new book record. The response includes a 201 Created status code:</p> <p></p>"},{"location":"chapter3/#note_1","title":"Note","text":"<p>It's crucial to use the right HTTP status code in each response. In this case, we use <code>status_code=201</code> to indicate the successful creation of a resource. The default status code is 200, which represents a standard successful response.</p>"},{"location":"chapter3/#update-a-book-http-patch","title":"Update a book (HTTP PATCH)","text":"<p>Let us look at the update endpoint. This is quite similar to the create endpoint as it allows data to be sent to the server via the PATCH HTTP method. But it also requires we provide the <code>book_id</code> of the book that we will be updating. we loop through the book list and find the book that matches the <code>book_id</code> as shown below:</p> <pre><code>@app.patch(\"/book/{book_id}\")\nasync def update_book(book_id: int,book_update_data:BookUpdateModel) -&gt; dict:\n\n    for book in books:\n        if book['id'] == book_id:\n            book['title'] = book_update_data.title\n            book['publisher'] = book_update_data.publisher\n            book['page_count'] = book_update_data.page_count\n            book['language'] = book_update_data.language\n\n            return book\n\n    raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=\"Book not found\")\n</code></pre> <p>If you notice, we have added the <code>book_update_data</code> parameter to our handler function and this is to be the validator for the data we shall use to update the book record. Notice this has a different schema called <code>BookUpdateModel</code>.</p> <pre><code>class BookUpdateSchema(BaseModel):\n    title:str\n    author:str\n    publisher:str\n    page_count:int\n    language:str\n</code></pre> <p>Notice how we have neglected some of the fields that are available in our Book structure as shown in our list of books. This is to ensure that we only send those fields that will be updated. Let us update our book record.</p> <p></p> <p>Let us confirm if our book record has been updated successfully. To do so we are going to retrieve the book by its ID. The book record has been updated successfully.</p> <p></p>"},{"location":"chapter3/#delete-a-book-http-delete","title":"Delete a book (HTTP Delete)","text":"<p>Let us finally look at the deletion of a book record. This is carried out in the following example:</p> <pre><code>from fastapi import HTTPException, status\n\n@app.delete(\"/book/{book_id}\", status_code=status.HTTP_204_NO_CONTENT)\nasync def delete_book(book_id: int):\n    for book in books:\n        if book[\"id\"] == book_id:\n            books.remove(book)\n            return {}\n\n    raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=\"Book not found\")\n</code></pre> <p>In this code, we loop through the books and find the book associated with the given <code>book_id</code>. We then remove it from the list of books using the <code>remove</code> list method. Notice that we return a 204 response status code, indicating that the book has been deleted and therefore no content is returned.</p> <p>Here is a visual example of the deletion process:</p> <p></p> <p>And just like that, we have created a CRUD REST API using a simple in memory database. </p>"},{"location":"chapter3/#conclusion","title":"Conclusion","text":"<p>In this chapter, we've developed a basic CRUD REST API using FastAPI. We utilized a simple in-memory database, represented by a Python list, to explore all CRUD actions. Moving forward, we'll restructure our project files to achieve a more organized and easily maintainable file structure.</p> <p>Previous Creating a Simple Web Server</p> <p>Next Improved Project Structure Using Routers</p>"},{"location":"chapter4/","title":"Large Project Structure Using Routers","text":""},{"location":"chapter4/#current-folder-structure","title":"Current folder structure","text":"<p>So far, our project structure is quite simple:</p> <pre><code>\u251c\u2500\u2500 env/\n\u251c\u2500\u2500 main.py\n\u251c\u2500\u2500 requirements.txt\n</code></pre>"},{"location":"chapter4/#currrent-code-structure","title":"Currrent code structure","text":"<p>Additionally, our <code>main.py</code> file looks like this:</p> <pre><code># inside main.py\nfrom fastapi import FastAPI, Query\n\n\napp = FastAPI()\n\nbooks = [\n    {\n        \"id\": 1,\n        \"title\": \"Think Python\",\n        \"author\": \"Allen B. Downey\",\n        \"publisher\": \"O'Reilly Media\",\n        \"published_date\": \"2021-01-01\",\n        \"page_count\": 1234,\n        \"language\": \"English\",\n    },\n    # ... (other book entries)\n]\n\nclass Book(BaseModel):\n    id: int\n    title: str\n    author: str\n    publisher: str\n    published_date: str\n    page_count: int\n    language: str\n\nclass BookUpdateModel(BaseModel):\n    title: str\n    author: str\n    publisher: str\n    page_count: int\n    language: str\n\n@app.get(\"/books\", response_model=List[Book])\nasync def get_all_books():\n    return books\n\n\n@app.post(\"/books\", status_code=status.HTTP_201_CREATED)\nasync def create_a_book(book_data: Book) -&gt; dict:\n    new_book = book_data.model_dump()\n\n    books.append(new_book)\n\n    return new_book\n\n\n@app.get(\"/book/{book_id}\")\nasync def get_book(book_id: int) -&gt; dict:\n    for book in books:\n        if book[\"id\"] == book_id:\n            return book\n\n    raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=\"Book not found\")\n\n\n@app.patch(\"/book/{book_id}\")\nasync def update_book(book_id: int,book_update_data:BookUpdateModel) -&gt; dict:\n\n    for book in books:\n        if book['id'] == book_id:\n            book['title'] = book_update_data.title\n            book['publisher'] = book_update_data.publisher\n            book['page_count'] = book_update_data.page_count\n            book['language'] = book_update_data.language\n\n            return book\n\n    raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=\"Book not found\")\n\n\n@app.delete(\"/book/{book_id}\",status_code=status.HTTP_204_NO_CONTENT)\nasync def delete_book(book_id: int):\n    for book in books:\n        if book[\"id\"] == book_id:\n            books.remove(book)\n\n            return {}\n\n    raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=\"Book not found\")\n</code></pre>"},{"location":"chapter4/#restructuring-the-project","title":"Restructuring the project","text":"<p>The problem here is that if we add more code to this file, our code will become messy and hard to maintain beacuse all our code will be in one file <code>main.py</code>. To address this, we need to create a more organized project structure. To start, let's create a new folder called <code>src</code>, which will contain an <code>__init__.py</code> file to make it a Python package:</p> <pre><code>\u251c\u2500\u2500 env/\n\u251c\u2500\u2500 main.py\n\u251c\u2500\u2500 requirements.txt\n\u2514\u2500\u2500 src/\n    \u2514\u2500\u2500 __init__.py\n</code></pre> <p>Now, create a folder named <code>books</code> inside the <code>src</code> directory. Inside this folder, add an <code>__init__.py</code> file, a <code>routes.py</code> file, a <code>schemas.py</code> file, and a <code>book_data.py</code> file. The <code>routes.py</code> file will contain all the book routes, similar to what we created in the previous chapter. The <code>schemas.py</code> file will contain the schemas that are currently in our root directory.</p> <pre><code>\u251c\u2500\u2500 env/\n\u251c\u2500\u2500 main.py\n\u251c\u2500\u2500 requirements.txt\n\u2514\u2500\u2500 src/\n    \u2514\u2500\u2500 __init__.py\n    \u2514\u2500\u2500 books/\n        \u2514\u2500\u2500 __init__.py\n        \u2514\u2500\u2500 routes.py\n        \u2514\u2500\u2500 schemas.py\n        \u2514\u2500\u2500 book_data.py\n</code></pre> <p>First, let's move our <code>books</code> list from <code>main.py</code> to <code>book_data.py</code> inside the <code>books</code> directory.</p> <pre><code># Inside src/books/book_data.py\n\nbooks = [\n    {\n        \"id\": 1,\n        \"title\": \"Think Python\",\n        \"author\": \"Allen B. Downey\",\n        \"publisher\": \"O'Reilly Media\",\n        \"published_date\": \"2021-01-01\",\n        \"page_count\": 1234,\n        \"language\": \"English\",\n    },\n    # ... (other book entries)\n]\n</code></pre> <p>Next, let's also move our Pydantic validation models from <code>main.py</code> to the <code>schemas.py</code> module inside the <code>books</code> directory.</p> <pre><code># Inside src/books/schemas.py\n\nfrom pydantic import BaseModel\n\nclass Book(BaseModel):\n    id: int\n    title: str\n    author: str\n    publisher: str\n    published_date: str\n    page_count: int\n    language: str\n\nclass BookUpdateModel(BaseModel):\n    title: str\n    author: str\n    publisher: str\n    page_count: int\n    language: str\n</code></pre> <p>Now, let's update <code>routes.py</code> as follows:</p> <pre><code># Inside routes.py\n\nfrom fastapi import APIRouter\nfrom src.books.book_data import books\nfrom src.books.schemas import BookSchema, BookUpdateSchema\n\nbook_router = APIRouter()\n\n@book_router.get(\"/books\", response_model=List[Book])\nasync def get_all_books():\n    return books\n\n\n@book_router.post(\"/books\", status_code=status.HTTP_201_CREATED)\nasync def create_a_book(book_data: Book) -&gt; dict:\n    new_book = book_data.model_dump()\n\n    books.append(new_book)\n\n    return new_book\n\n\n@book_router.get(\"/book/{book_id}\")\nasync def get_book(book_id: int) -&gt; dict:\n    for book in books:\n        if book[\"id\"] == book_id:\n            return book\n\n    raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=\"Book not found\")\n\n\n@book_router.patch(\"/book/{book_id}\")\nasync def update_book(book_id: int,book_update_data:BookUpdateModel) -&gt; dict:\n\n    for book in books:\n        if book['id'] == book_id:\n            book['title'] = book_update_data.title\n            book['publisher'] = book_update_data.publisher\n            book['page_count'] = book_update_data.page_count\n            book['language'] = book_update_data.language\n\n            return book\n\n    raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=\"Book not found\")\n\n\n@book_router.delete(\"/book/{book_id}\",status_code=status.HTTP_204_NO_CONTENT)\nasync def delete_book(book_id: int):\n    for book in books:\n        if book[\"id\"] == book_id:\n            books.remove(book)\n\n            return {}\n\n    raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=\"Book not found\")\n</code></pre>"},{"location":"chapter4/#introduction-to-fastapi-routers","title":"Introduction to FastAPI routers","text":"<p>What has been accomplished is the division of our project into modules using routers. FastAPI routers allow easy modularization of our API by grouping related API routes together. Routers function similarly to FastAPI instances (similar to what we have in <code>main.py</code>). As our project expands, we will introduce additional API routes, and all of them will be organized into modules grouping related functionalities.</p> <p>Let's enhance our <code>main.py</code> file to adopt this modular structure:</p> <pre><code># Inside main.py\nfrom fastapi import FastAPI\nfrom src.books.routes import book_router\n\nversion = 'v1'\n\napp = FastAPI(\n    title='Bookly',\n    description='A RESTful API for a book review web service',\n    version=version,\n)\n\napp.include_router(book_router,prefix=f\"/api/{version}/books\", tags=['books'])\n</code></pre> <p>Firstly, a variable called <code>version</code> has been introduced to hold the API version. Next, we import the <code>book_router</code> created in the previous example. Using our FastAPI instance, we include all endpoints created with it by calling the <code>include_router</code> method.</p> <p>Arguments added to the FastAPI instance are:</p> <ul> <li><code>title</code>: The title of the API.</li> <li><code>description</code>: The description of the API.</li> <li><code>version</code>  : The version of the API.</li> </ul> <p>While these arguments may not be particularly useful at present, they become valuable when we explore API documentation with OpenAPI.</p> <p>Furthermore, we added the following arguments to the include_router method:</p> <ul> <li> <p><code>prefix</code>: The path through which all related endpoints can be accessed. In our case, it's named the /{version}/books prefix, resulting in /v1/books or /v2/books based on the application version. This implies that all book-related endpoints can be accessed using http://localhost:8000/api/v1/books.</p> </li> <li> <p><code>tags</code>: The list of tags associated with the endpoints that fall within a given router.</p> </li> </ul> <p>Let us now now move all the source code in our <code>main.py</code> module to <code>src/__init__.py</code>. (delete your <code>main.py</code>)</p> <p><pre><code># inside src/__init__.py\nfrom fastapi import FastAPI\nfrom src.books.routes import book_router\n\nversion = 'v1'\n\napp = FastAPI(\n    title=\"Bookly\",\n    description=\"A REST API for a book review web service\",\n    version= version,\n    lifespan=life_span\n)\n\napp.include_router(book_router, prefix=f\"/api/{version}/books\", tags=['books'])\n</code></pre> Having moved our code, we shall now have this folder structure. <pre><code>\u251c\u2500\u2500 requirements.txt\n\u251c\u2500\u2500 run.py\n\u2514\u2500\u2500 src\n    \u251c\u2500\u2500 books\n    \u2502   \u251c\u2500\u2500 book_data.py\n    \u2502   \u251c\u2500\u2500 __init__.py\n    \u2502   \u251c\u2500\u2500 routes.py\n    \u2502   \u251c\u2500\u2500 schemas.py\n    \u2502   \u251c\u2500\u2500 book_data.py\n    \u2514\u2500\u2500 __init__.py\n</code></pre></p> <p>Once more, let's start our server using <code>fastapi dev src/</code>. Pay attention to the fact that this time we're specifying<code>src/</code>. This is because we've designated it as a package by including <code>__init__.py</code>. Additionally, our FastAPI instance named <code>app</code> is created there. Consequently, FastAPI will utilize it to operate our application.</p> <p>Runnning our application will the following terminal output. <pre><code>INFO     Using path src                                                                                                                                     \nINFO     Resolved absolute path /home/jod35/Documents/fastapi-beyond-CRUD/src                                                                               \nINFO     Searching for package file structure from directories with __init__.py files                                                                       \nINFO     Importing from /home/jod35/Documents/fastapi-beyond-CRUD                                                                                           \n\n \u256d\u2500 Python package file structure \u2500\u256e                                                                                                                        \n \u2502                                 \u2502                                                                                                                        \n \u2502  \ud83d\udcc1 src                         \u2502                                                                                                                        \n \u2502  \u2514\u2500\u2500 \ud83d\udc0d __init__.py             \u2502                                                                                                                        \n \u2502                                 \u2502                                                                                                                        \n \u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f                                                                                                                        \n\nINFO     Importing module src                                                                                                                               \nINFO     Found importable FastAPI app                                                                                                                       \n\n \u256d\u2500 Importable FastAPI app \u2500\u256e                                                                                                                               \n \u2502                          \u2502                                                                                                                               \n \u2502  from src import app     \u2502                                                                                                                               \n \u2502                          \u2502                                                                                                                               \n \u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f                                                                                                                               \n</code></pre></p>"},{"location":"chapter4/#note","title":"Note:","text":"<p>The current organization of our API endpoints is as follows:</p> Endpoint Method Description /api/v1/books GET Read all books /api/v1/books POST Create a book /api/v1/books/{book_id} GET Get a book by ID /api/v1/books/{book_id} PATCH Update a book by ID /api/v1/books/{book_id} DELETE Delete a book by ID"},{"location":"chapter4/#conclusion","title":"Conclusion","text":"<p>This chapter has focused on creating a folder structure that we can use even when our project gets bigger. In the next chapter, we shall focus on database and look at how we can persist our data and use Python to manage a relational database.</p> <p>Previous Improved Project Structure Using Routers</p> <p>Next Databases with SQLModel</p>"},{"location":"chapter5/","title":"Databases with SQLModel","text":"<p>In the preceding chapter, we developed a functional CRUD API that operated on a simple in-memory database, represented by a Python list. However, in real-world applications, it's essential to use a persistent database to store all necessary data.</p>"},{"location":"chapter5/#choosing-a-database-for-fastapi","title":"Choosing a Database for FastAPI","text":"<p>FastAPI supports various types of databases, including relational/SQL databases and non-relational/NoSQL databases. Depending on your specific requirements, you can opt for either type.</p> <p>For this series, we'll focus on using a relational database, specifically PostgreSQL. PostgreSQL is a widely used free and open-source relational database management system, offering numerous benefits:</p> <p>While using PostgreSQL, we shall need to choose a way to interact with the database using the Python Language. That introduces us to the concept of an Object Relational mapper.</p>"},{"location":"chapter5/#explaining-an-object-relational-mapper-orm","title":"Explaining an Object-Relational Mapper (ORM)","text":"<p>An Object-Relational Mapper (ORM) serves as a translator between a programming language, such as Python, and a database, like PostgreSQL or MySQL.</p> <p>In simpler terms, think of an ORM as an interpreter in a conversation where one person speaks English (Python) and the other speaks French (database). The ORM understands both languages, allowing you to interact with the database using familiar Python code without needing to understand the intricacies of how the database works internally.</p>"},{"location":"chapter5/#how-it-works","title":"How it Works:","text":"<ol> <li> <p>Mapping Objects to Tables: You create Python classes to represent tables in the database. Each object of these classes corresponds to a row in the database table.</p> </li> <li> <p>Interacting with Data: You can then interact with these Python objects as if they were regular objects in your code, like setting attributes and calling methods.</p> </li> <li> <p>Behind the Scenes: When you perform operations on these objects, like saving or deleting, the ORM translates these actions into the appropriate SQL queries that the database understands.</p> </li> <li> <p>Data Conversion: The ORM handles converting Python data types into database-specific types and vice versa, ensuring compatibility between the two.</p> </li> </ol> <p>An ORM simplifies the process of working with databases by allowing you to focus on your application's logic in Python, rather than getting bogged down in SQL queries and database management details. It acts as a bridge between the object-oriented world of programming and the relational world of databases.</p> <p>There are several different ORM solutions available for Python, but the most popular is SQLAlchemy. SQLAlchemy simplifies database access and manipulation by providing an ORM for mapping Python objects to database tables and offering a high-level SQL expression language for querying databases. While SQLAlchemy is a powerful tool on its own, there's an ORM solution that seamlessly integrates SQLAlchemy with Pydantic, the data validation library discussed in previous chapters.</p>"},{"location":"chapter5/#creating-a-database","title":"Creating a Database","text":"<p>In this series, we will make use of SQLModel, a library tailored for FastAPI. Interestingly, it was developed by the same individual who created FastAPI.</p> <p>Let's initiate the database setup. Setting up a database can be intricate, often involving multiple steps. Fortunately, numerous options are available that simplify the database creation process without extensive configuration.</p> <p>Throughout this course, I'll utilize Neon, a free fully managed PostgreSQL database with a generous free tier. With Neon, we can swiftly create a database and get started without delay.</p> <p></p> <p>Once you have created your free account on Neon, you can create a new project and in it, you will also create your new database.</p> <p></p> <p>Once you have created your database, you can then go ahead and copy your connection details.  </p> <p>After, Create a file called <code>.env</code> in which we shall store our project configurations as secrets. (This file is important and should not be added to version control) In your <code>.env</code> file, paste the database connection URL you have obtained from Neon. We are going to create an environment variable called <code>DATABASE_URL</code> with the value of our URL.</p> <pre><code># inside .env\nDATABASE_URL=postgresql://bookdb_owner:w8JK2sCASYBc@ep-rough-block-a554nxl6.us-east-2.aws.neon.tech/bookdb?sslmode=require\n</code></pre> <p>At this point, your folder structure needs to look something like this: <pre><code>|__ .env\n\u251c\u2500\u2500 env/\n\u251c\u2500\u2500 main.py\n\u251c\u2500\u2500 requirements.txt\n\u2514\u2500\u2500 schemas.py\n\u2514\u2500\u2500 src/\n    \u2514\u2500\u2500 __init__.py\n    \u2514\u2500\u2500 books/\n        \u2514\u2500\u2500 __init__.py\n        \u2514\u2500\u2500 routes.py\n        \u2514\u2500\u2500 schemas.py\n        \u2514\u2500\u2500 book_data.py\n</code></pre></p>"},{"location":"chapter5/#settings-management-with-pydantic","title":"Settings Management With Pydantic","text":"<p>With that in place, we can now set up our configurations so that we can read them out from anywhere within our application. Let us begin by creating a <code>config.py</code> file that contains the configuration variables that will be used in this series.</p> <p>We are going to rely on Pydantic to read our environment variables. Pydantic alone will not help us; we shall need to install <code>pydantic-settings</code>, a library that is based on Pydantic to help us with the specific role of reading environment variables from our <code>.env</code> file. </p> <p>So let us start by installing </p> <p><pre><code>$ pip install pydantic-settings\n</code></pre> After installing <code>pydantic-settings</code>, let us now go ahead and create a file called <code>config.py</code> at the root of our project. Inside that file, add the following code.</p> <pre><code># inside src/config.py\nfrom pydantic_settings import BaseSettings, SettingsConfigDict\n\n\nclass Settings(BaseSettings):\n    DATABASE_URL: str \n\n    model_config = SettingsConfigDict(\n        env_file=\".env\", \n        extra=\"ignore\"\n    )\n</code></pre>"},{"location":"chapter5/#explanation","title":"Explanation:","text":"<p>In the provided code snippet, we've performed the following actions:</p> <ol> <li>We are importing the <code>BaseSettings</code> class from <code>pydantic_settings</code>.</li> <li>Creating a subclass called <code>Settings</code>, inheriting from <code>BaseSettings</code>.</li> <li>Defining an attribute named <code>DATABASE_URL</code> with a type annotation of <code>str</code>.</li> <li>To modify our configuration to read from the <code>.env</code> file, we modified the <code>model_config</code> attribute of the <code>Settings</code> class which is one to help us with modifying the configuration of any pydantic model class. This is set to an instance of the <code>SettingsConfigDict</code> class which enables us to read the configuration from the <code>.env</code> file. This is by simply setting the <code>env_file</code> argument to the name of the <code>.env</code> file. We have also added the <code>extra</code> argument and given it a value of <code>ignore</code> as we may want to ignore any extra attributes provided within our <code>Settings</code> class.</li> </ol> <p>This configuration allows us to read the <code>DATABASE_URL</code> from the environment variables.  Let's observe how this configuration operates. We'll initiate a Python interpreter shell for testing:</p> <pre><code>$ python3\nPython 3.10.12 (main, Nov 20 2023, 15:14:05) [GCC 11.4.0] on linux\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\n&gt;&gt;&gt; from config import Settings\n&gt;&gt;&gt; settings = Settings()\n&gt;&gt;&gt; settings.DATABASE_URL\n'postgresql://bookdb_owner:w8JK2sCASYBc@ep-rough-block-a554nxl6.us-east-2.aws.neon.tech/bookdb?sslmode'\n&gt;&gt;&gt; \n</code></pre> <p>In the above demonstration, we start by importing the <code>Settings</code> class from the <code>config.py</code> file. Subsequently, we instantiate a <code>settings</code> object. Utilizing this <code>settings</code> object, we access and retrieve the <code>DATABASE_URL</code> setting. Upon calling it, our database URL will be displayed in the console. Note that this shall work because we currently have the <code>DATABASE_URL</code> setting in our <code>.env</code> file.</p> <p>Once this has been implemented, let us then add the following line to <code>config.py</code>. <pre><code># inside src/config.py\nfrom pydantic_settings import BaseSettings, SettingsConfigDict\n\nclass Settings(BaseSettings):\n    DATABASE_URL: str \n\n    model_config = SettingsConfigDict(\n        env_file=\".env\", \n        extra=\"ignore\"\n    )\n\n# add this line    \nConfig = Settings()\n</code></pre> We add this line so that we don't have to create a new instance of our <code>Settings</code> class whenever we shall need to access environment variables. From now on, we shall shall just have to import the <code>Config</code> variable and use it.</p>"},{"location":"chapter5/#creating-database-models-with-sqlmodel","title":"Creating database models with SQLModel","text":"<p>Alright, let us now connect to our database and also create our table in it. Let us install <code>sqlmodel</code>. <pre><code>$ pip install sqlmodel\n</code></pre></p> <p>Once we have <code>sqlmodel</code> installed, let us now create a database model using it. to start, we will create a file named models.py inside the <code>books</code> directory.</p> <p><pre><code>|__ .env\n\u251c\u2500\u2500 env/\n\u251c\u2500\u2500 main.py\n\u251c\u2500\u2500 requirements.txt\n\u2514\u2500\u2500 schemas.py\n\u2514\u2500\u2500 src/\n    \u2514\u2500\u2500 __init__.py\n    \u2514\u2500\u2500 books/\n        \u2514\u2500\u2500 __init__.py\n        \u2514\u2500\u2500 routes.py\n        |__ models.py\n        \u2514\u2500\u2500 schemas.py\n        \u2514\u2500\u2500 book_data.py\n</code></pre> Inside <code>models.py</code>, add the following code.  <pre><code># inside src/books/models.py\nfrom sqlmodel import SQLModel, Field, Column\nimport sqlalchemy.dialects.postgresql as pg\nimport uuid\n\nclass Book(SQLModel , table=True):\n    __tablename__ = \"books\"\n\n    uid:uuid.UUID = Field(\n        sa_column=Column(\n            pg.UUID,\n            primary_key=True,\n            unique=True,\n            nullable=False\n        )\n    )\n\n    title: str\n    author: str\n    publisher: str\n    published_date: str\n    page_count: int\n    language:str\n    created_at: datetime = Field(sa_column=Column(pg.TIMESTAMP, default=datetime.now))\n    updated_at:datetime = Field(sa_column=Column(pg.TIMESTAMP, default=datetime.now))\n\n    def __repr__(self) -&gt; str:\n        return f\"&lt;Book {self.title}&gt;\"\n</code></pre></p>"},{"location":"chapter5/#explanation_1","title":"Explanation","text":"<p>IN the above code, we have defined a database model using <code>SQLModel</code>. Here are the steps we took.  1. We imported the <code>SQLModel</code>, <code>Field</code>, <code>Column</code> from sqlmodel. 2. We import <code>sqlalchemy.dialects.postgresql</code>as <code>pg</code> to allow us access the PostgreSQL-specific column types. 3. In the model definition, we create a <code>Book</code> class that inherits from <code>SQLModel</code>, we then also add the <code>table</code> parameter to the class and set it to <code>True</code>to inidicate that the class is going to represent a database table.</p> <pre><code>#### Note\n    All SQLModel models are pydantic tables and therefore can be used for data validation.\n</code></pre> <ol> <li> <p>Inside the class, several attributes are defined:</p> <ul> <li><code>uid</code>: A universally unique identifier (UUID) for each book. We use the <code>Field</code> function, to add some details or attributes to it. It's also specified as the primary key column <code>(primary_key=True)</code>, with a default value generated by <code>uuid.uuid4()</code>, and it's unique and not nullable.</li> </ul> </li> </ol>"},{"location":"chapter5/#note","title":"Note","text":"<pre><code>To make our primary key store UUIDs, we have chosen to use the PostgreSQL UUID type and we achive this by using the sa_column argument in the Field function. Using SQLALchemy's Column class we then specify the type of the field.\n</code></pre> <ul> <li> <p><code>title</code>, <code>author</code>, <code>publisher</code>, <code>published_date</code>, <code>page_count</code>, <code>language</code>: These attributes represent various properties of a book, such as title, author, publisher, etc. They are all specified as strings (str) or integers (int) and will be columns in the database table.</p> </li> <li> <p><code>created_at</code> and <code>updated_at</code> represent timestamps at which a book record was created or updated. Note that we are also going in detail about defining the PostgreSQL column types as <code>pg.TIMESTAMP</code>. We also specify that we want to keep track of the </p> </li> <li> <p>def repr(self) -&gt; str: This is a special method that defines how instances of the <code>Book</code> class are represented as strings. In this case, it returns a string containing the title of the book, enclosed in angle brackets and preceded by <code>Book</code>.</p> </li> </ul>"},{"location":"chapter5/#connecting-to-databases","title":"Connecting to databases","text":"<p>For now, our current directory structure looks something like this. <pre><code>\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 requirements.txt\n\u251c\u2500\u2500 run.py\n\u2514\u2500\u2500 src\n    \u251c\u2500\u2500 books\n    \u2502   \u251c\u2500\u2500 book_data.py\n    \u2502   \u251c\u2500\u2500 __init__.py\n    \u2502   \u251c\u2500\u2500 models.py\n    \u2502   \u251c\u2500\u2500 routes.py\n    \u2502   \u2514\u2500\u2500 schemas.py\n    \u251c\u2500\u2500 config.py\n    \u2514\u2500\u2500 __init__.py\n</code></pre></p> <p>Let us add a directory in our <code>src</code> folder and call it <code>db</code> (short for database). we shall make it a normal Python package by adding the <code>__init__.py</code> file. After, we shall go ahead and add a Python file called <code>main.py</code> and we shall then add the following code.</p> <pre><code># inside src/db/main.py\nfrom sqlmodel import create_engine, text\nfrom sqlalchemy.ext.asyncio import AsyncEngine\nfrom src.config import Config\n\nengine = AsyncEngine(create_engine(\n    url=Config.DATABASE_URL,\n    echo=True\n))\n\n\nasync def initdb():\n    \"\"\"create a connection to our db\"\"\"\n\n    async with engine.begin() as conn:\n        statement = text(\"select 'Hello World'\")\n\n        result = await conn.execute(statement)\n\n        print(result)\n</code></pre>"},{"location":"chapter5/#explanation_2","title":"Explanation","text":"<ol> <li> <p>We begin by importing the necessary objects from the libraries they belong to.</p> <p><pre><code># inside src/db/main.py\nfrom sqlmodel import create_engine, text\nfrom sqlalchemy.ext.asyncio import AsyncEngine\nfrom src.config import Config\n</code></pre> <code>create_engine</code> is a function that enables to connect to a database when we need. <code>text</code> is a function that helps us generate plain text SQL statements that we can run against a database when we connect to it. <code>AsyncEngine</code> is a class for creating asynchronous engine objects. We shall look at how we shall use it in a moment. <code>Config</code> is the settings objects we created above. This will allow us access our configurations.</p> </li> <li> <p>We then create the <code>engine</code> object. This will allow us to connect to the database when we need to. (We will look at how we will use it later.)     <pre><code>engine = AsyncEngine(create_engine(\n    url=Config.DATABASE_URL,\n    echo=True\n))\n</code></pre>     This object is created by calling the <code>create_engine()</code> function. In the function call, we also add two important argumnents. The first argument is the <code>url</code> to the database to connect to. In this case, we shall use the <code>DATABASE_URL</code> value from the configuration we set up above. This is accessed on the <code>Config</code> object created in our settings.</p> <p>The second argument is the <code>echo</code> argument, this allows us to log SQL statements that will be executed in the database everytime they are executed. We finally create this object inside the <code>AsyncEngine</code> class because we want to be able to interact with the database using an asynchronous DBAPI. </p> <pre><code>A DBAPI (Database Application Programming Interface) is simply a medium through which the Python programming language can connect to the database server.\n</code></pre> </li> <li> <p>Finally, we create a function called <code>initdb</code> which is responsible for connecting to the database and executing a simple SQL statement. </p> <pre><code>async def initdb():\n    \"\"\"create a connection to our db\"\"\"`\n\n    async with engine.begin() as conn:\n    statement = text(\"select 'Hello World'\")\n\n    result = await conn.execute(statement)\n\n    print(result.all())`\n</code></pre> <p>Inside the <code>initdb</code> function, we begin by creating a connection object <code>conn</code> using an async context manager. (created with <code>async with engine.begin()</code>). We then create a plain text SQL statement and call the <code>text</code> function.</p> <p>The result of the statement is what we access through the <code>result</code> object which we finally print to our terminal when we call the <code>all</code> method on it.</p> </li> </ol>"},{"location":"chapter5/#lifespan-events-in-fastapi","title":"Lifespan events in FastAPI","text":"<p>In FastAPI, we have the flexibility to specify operations to execute prior to the application receiving requests, as well as when it concludes receiving them. This capability is crucial in situations where executing such operations may be resource-intensive and potentially degrade user experience. Examples of such operations include establishing database connections and loading AI models. For our demonstration, we'll focus on establishing a database connection before the application starts. If this concept isn't clear, let's start by examining a brief example.</p> <p>In the <code>__init__.py</code> file at the root of the <code>src</code> directory, let us modify the code as shown below.</p> <pre><code># src/__init__.py\nfrom fastapi import FastAPI\nfrom src.books.routes import book_router\nfrom contextlib import asynccontextmanager\n\n\n#the lifespan event\n@asynccontextmanager\nasync def lifespan(app: FastAPI):    \n    print(\"Server is starting...\")\n    yield\n    print(\"server is stopping\")\n\n\n\napp = FastAPI(\n    lifespan=lifespan # add the lifespan event to our application\n)\n\napp.include_router(\n    book_router,\n    prefix=\"/books\",\n    tags=['books']\n)\n</code></pre>"},{"location":"chapter5/#explanation_3","title":"Explanation","text":"<p>Let's create an async function called lifespan. This function will be decorated with asynccontextmanager from the contextlib module in Python. Inside this function, there will be two print statements, separated by a <code>yield</code> statement.</p> <p>The code before the <code>yield</code> statement will execute first (when the server starts), followed by the code after the <code>yield</code> statement, which will execute last (when the server stops).</p> <p>This function is a lifespan event because it runs once before the application starts and then continues throughout the application's lifespan.</p> <p>Now, if we stop the server by pressing CTRL+C and then restart it, the following output will be logged in the terminal. <pre><code>$ python3 run.py \nINFO:     Will watch for changes in these directories: ['/home/jod35/Documents/fastapi-beyond-CRUD']\nINFO:     Uvicorn running on http://127.0.0.1:8000 (Press *CTRL+C* to quit)\nINFO:     Started reloader process [18506] using WatchFiles\nINFO:     Started server process [18508]\nINFO:     Waiting for application startup.\nserver is starting...\n</code></pre> At the server's start, you'll observe the text <code>server is starting</code> printed in the terminal. After halting the server using Ctrl+C, you should see the subsequent output <pre><code>INFO:     Application startup complete.\n^CINFO:     Shutting down\nINFO:     Waiting for application shutdown.\nserver is stopping\nINFO:     Application shutdown complete.\nINFO:     Finished server process [18669]\n$\n</code></pre></p> <p>Now that we grasp how lifespan events function, let's integrate our init_db function to establish a connection to the PostgreSQL database.</p> <p>Update the lifespan function in <code>src/__init__.py</code> to include the following code.</p> <p><pre><code>#src/__init__.py\n...\nfrom src.db.main import initdb\n\n\n@asynccontextmanager\nasync def lifespan(app: FastAPI):    \n    await initdb()\n    yield\n    print(\"server is stopping\")\n</code></pre> Upon saving, you'll observe the following output in your terminal.</p> <p><pre><code>INFO:     Started server process [21034]\nINFO:     Waiting for application startup.\n2024-05-06 11:50:41,802 INFO sqlalchemy.engine.Engine BEGIN (implicit)\n2024-05-06 11:50:41,803 INFO sqlalchemy.engine.Engine select 'Hello World'\n2024-05-06 11:50:41,803 INFO sqlalchemy.engine.Engine [generated in 0.00015s] ()\n[('Hello World',)]\n2024-05-06 11:50:41,803 INFO sqlalchemy.engine.Engine COMMIT\n</code></pre> This code establishes a connection to the database and executes a SELECT statement, which will return the string \"Hello World\" as demonstrated in the provided output.</p>"},{"location":"chapter5/#creating-database-tables","title":"Creating database tables","text":"<p>Let's update the code in <code>src/db/main.py</code> to incorporate our custom lifespan event into the database model, utilizing the <code>Book</code> model. We'll then utilize SQLmodel to generate the necessary database tables based on this model.</p> <pre><code># inside src/db/main.py\nfrom sqlmodel import create_engine, text\nfrom sqlalchemy.ext.asyncio import AsyncEngine\nfrom src.config import Config\nfrom sqlmodel import SQLModel\nfrom src.books.models import Book\n\n\nengine = AsyncEngine(create_engine(\n    url=Config.DATABASE_URL,\n    echo=True\n))\n\n\nasync def initdb():\n    \"\"\"create our database models in the database\"\"\"\n\n    async with engine.begin() as conn:\n        await conn.run_sync(SQLModel.metadata.create_all)\n</code></pre> <p>In the above code, we began with importing the <code>Book</code> model from <code>src/books/models</code>. After, we then modify the <code>initdb()</code> function by adding the following: <pre><code>    async with engine.begin() as conn:\n        await conn.run_sync(SQLModel.metadata.create_all)\n</code></pre></p> <p>In this code snippet, we utilize an asynchronous context manager with <code>engine.begin()</code>, enabling us to create a transactional context to interact with our database. Within this context, we execute <code>conn.run_sync(SQLModel.metadata.create_all()</code>.</p> <p>Here, <code>SQLModel.metadata</code> encompasses all the metadata linked with SQLModel. By invoking the <code>create_all()</code> method on this metadata object, any tables present in the metadata but absent in the database will be created.</p> <p>Note  - <code>conn.run_sync()</code> is an asynchronous function that we utilize to run synchronous functions such as <code>SQLModel.metadata.create_all()</code>.</p> <p>With that said, let us save the file and have a look at our terminal output.  <pre><code>INFO:     Waiting for application startup.\n2024-05-06 12:13:21,042 INFO sqlalchemy.engine.Engine BEGIN (implicit)\n2024-05-06 12:13:21,042 INFO sqlalchemy.engine.Engine PRAGMA main.table_info(\"books\")\n2024-05-06 12:13:21,042 INFO sqlalchemy.engine.Engine [raw sql] ()\n2024-05-06 12:13:21,043 INFO sqlalchemy.engine.Engine PRAGMA temp.table_info(\"books\")\n2024-05-06 12:13:21,043 INFO sqlalchemy.engine.Engine [raw sql] ()\n2024-05-06 12:13:21,044 INFO sqlalchemy.engine.Engine \nCREATE TABLE books (\n        uid UUID NOT NULL, \n        title VARCHAR NOT NULL, \n        author VARCHAR NOT NULL, \n        publisher VARCHAR NOT NULL, \n        published_date VARCHAR NOT NULL, \n        page_count INTEGER NOT NULL, \n        language VARCHAR NOT NULL, \n        created_at TIMESTAMP, \n        updated_at TIMESTAMP, \n        PRIMARY KEY (uid), \n        UNIQUE (uid)\n)\n\n\n2024-05-06 12:13:21,044 INFO sqlalchemy.engine.Engine [no key 0.00014s] ()\n2024-05-06 12:13:21,086 INFO sqlalchemy.engine.Engine COMMIT\n</code></pre> Running the code above shall allow us to create the table in the database also logging the SQL query in the terminal as shown above. </p>"},{"location":"chapter5/#conclusion","title":"Conclusion","text":"<p>In this chapter, we've introduced persistence to our data by employing a relational database management system (PostgreSQL). Additionally, we've explored the utilization of Pydantic for configuration settings. We've also examined SQLModel, an ORM that combines Pydantic and SQLAlchemy to manage relational databases effectively. Our database, which stores book data, is now operational. Looking ahead, I've outlined the CRUD actions for our persistent database in the following chapter.</p> <p>Previous: Improved Project Structure Using Routers</p> <p>Next: Finishing Up the CRUD</p>"},{"location":"chapter6/","title":"Finishing Up the CRUD","text":""},{"location":"chapter6/#creating-a-service-class","title":"Creating a service class","text":"<p>In this chapter, we will focus on creating a dedicated service file to house the essential logic required for executing CRUD operations using our PostgreSQL database. The primary objective is to abstract away database interactions from our API routes, enhancing code readability and maintainability.</p> <p>We will construct a class within this service file, which will serve as a centralized point for invoking all methods related to managing our book data.</p> <p>To initiate this process, let's commence by creating the file <code>service.py</code> within the <code>src/books/</code> directory. <pre><code># inside /src/books/service.py\nfrom sqlmodel.ext.asyncio.session import AsyncSession\nfrom src.books.models import Book\nfrom src.books.schemas import BookCreateModel\nfrom sqlmodel import select\n\n\nclass BookService:\n    \"\"\"\n    This class provides methods to create, read, update, and delete books\n    \"\"\"\n\n    pass\n</code></pre></p> <p>We call this class <code>BookService</code> as it shall be called only when managing data about books. We then create an <code>__init__</code> method to help us define some attributes on this class. The first attribute we give to this class is the <code>session</code> object. In SQLModel, a session object is a unit of work through which all of transactions between the database and Python are done. Through it we can Create, Read, Update, Delete database objects in an efficient manner.</p> <p>Let us add this to our <code>BookService</code> class. <pre><code>    ... #the rest of the BookService class\n    def __init__(self, session: AsyncSession):\n        self.session = session\n</code></pre></p> <p>Every <code>BookService</code> instance shall be created with a <code>session</code> object allowing it to interact with the database.</p>"},{"location":"chapter6/#read-all-books","title":"Read all books","text":"<p>Let us begin by adding the method <code>get_all_books</code> that is responsible for getting all the books from the database.</p> <pre><code>    ... #the rest of the BookService class\n    async def get_all_books(self):\n        \"\"\"\n        Get a list of all books\n\n        Returns:\n            list: list of books\n        \"\"\"\n        statement = select(Book).order_by(Book.created_at)\n\n        result = await self.session.exec(statement)\n\n        return result.all()\n</code></pre> <p>To start, we craft a query utilizing the <code>select</code> function from SQLModel, initiating an SQL SELECT operation on our Books table. Subsequently, we sort the books based on their creation date (created_at) via the order_by method.</p> <p>This constructed statement is subsequently executed through the <code>session</code> object, assuming that we have assigned an attribute to objects that will be instantiated from our class. The resulting <code>result</code> object will return a list of books obtained by invoking the <code>all</code> method.</p>"},{"location":"chapter6/#creating-a-new-book","title":"Creating a new Book","text":"<p>Let us now add the method for creating a new book <pre><code>    ... # rest of the BookService class\n    async def create_book(self, book_create_data: BookCreateModel):\n        \"\"\"\n        Create a new book\n\n        Args:\n            book_create_data (BookCreateModel): data to create a new\n\n        Returns:\n            Book: the new book\n        \"\"\"\n        new_book = Book(**book_create_data.model_dump())\n\n        self.session.add(new_book)\n\n        await self.session.commit()\n\n        return new_book\n</code></pre> The <code>create_book</code> method is responsible for adding a new book to the database using the provided book data. Specifically, <code>book_create_data</code> must adhere to the structure defined by a Pydantic model called <code>BookCreateModel</code>, which we'll soon create in our <code>src/books/schema.py</code> directory.</p> <p>To create a new book record, we begin by initializing a new instance of the Book database model. This is achieved by unpacking book_create_data, which we convert into a Python dictionary utilizing the model_dump method.</p> <p>Following this, we utilize our <code>session</code> object to add the new book record to the database via <code>session.add</code>. Finally, we commit the transaction to ensure that the changes are persisted in the database, accomplished with <code>session.commit</code>, not forgetting to return the newly created book record.</p> <p>Before we proceed, we need to add the <code>BookCreateSchema</code> class to <code>src/books/schemas.py</code> </p> <p>Let us add the <code>BookCreateSchema</code> class to <code>src/books/schemas.py</code>. <pre><code># inside src/books/schemas.py\nclass BookCreateModel(BaseModel):\n    \"\"\"\n        This class is used to validate the request when creating or updating a book\n    \"\"\"\n    title: str\n    author: str\n    isbn: str\n    description: str\n</code></pre></p>"},{"location":"chapter6/#retrieve-a-book-by-its-uid","title":"Retrieve a book by its uid","text":"<pre><code>    ... # the rest of the BookService class\n    async def get_book(self, book_uid: str):\n        \"\"\"Get a book by its UUID.\n\n        Args:\n            book_uid (str): the UUID of the book\n\n        Returns:\n            Book: the book object\n        \"\"\"\n        statement = select(Book).where(Book.uid == book_uid)\n\n        result = await self.session.exec(statement)\n\n        book = result.first()\n\n        return book if book else None\n</code></pre> <p>To retrieve a book from the database, we construct a <code>select</code> statement to fetch all books but filter by the <code>uid</code> to ensure that only the desired book is retrieved. This filtering is achieved using the <code>where</code> method.</p> <p>Subsequently, we execute the statement using the <code>session</code> object, obtaining the <code>result</code>. Finally, we retrieve the book by invoking the <code>first</code> method on the result object. Note that we are returning <code>None</code> if a book matching the <code>uid</code> is not found.</p>"},{"location":"chapter6/#update-a-book","title":"Update a book","text":"<p>Now updating a book is going to involve the following: - first, we need to retrieve the book to update by its <code>uid</code> - second, we need to get the data we shall be updating the book with (<code>book_update_data</code>). - finally, we shall update the book fields with the new data - return the updated book if found or None when not.</p> <p><pre><code>    ... # rest of the BookService class\n    async def update_book(self, book_uid: str, book_update_data: BookCreateSchema):\n        \"\"\"Update a book\n\n        Args:\n            book_uid (str): the UUID of the book\n            book_update_data (BookCreateModel): the data to update the book\n\n        Returns:\n            Book: the updated book\n        \"\"\"\n\n        book = await self.get_book(book_uid=book_uid)\n\n        if book is not None:\n\n            for key, value in book_update_data.model_dump().items():\n                setattr(book, key, value)\n\n            await self.session.commit()\n\n            return book\n\n        else:\n            return None\n</code></pre> To implement the <code>update_book</code> method, which updates a book by its UID, we first fetch the book based on its UID, following the approach described for retrieving a book.</p> <p>Next, we update the book object with the following code:</p> <pre><code># Unpack the book data dictionary and set fields\nfor key, value in book_update_data.model_dump().items():\n    setattr(book, key, value)\n</code></pre> <p>This code iterates over the key-value pairs in the dictionary obtained from <code>book_update_data.model_dump()</code>, setting each field of the book object accordingly.</p> <p>Finally, after updating the book object with the new data, we commit the changes to the database using session.commit(). This ensures that the modifications made to the book are saved persistently in the database.</p>"},{"location":"chapter6/#delete-a-book","title":"Delete a Book","text":"<p>To delete a book from the database, we follow a similar approach as when retrieving a book. Once we have obtained the book object from the database using its <code>uid</code>, we use the <code>session.delete</code> method to mark the <code>book</code> object for deletion. To finalize the deletion and apply the changes to the database, we call <code>session.commit()</code>. This ensures that the book is effectively removed from the database.</p> <pre><code>    ... #rest of the BookService class\n    async def delete_book(self, book_uid):\n        \"\"\"Delete a book\n\n        Args:\n            book_uid (str): the UUID of the book\n        \"\"\"\n        book = await self.get_book(book_uid=book_uid)\n\n        if not book:\n            return None\n\n        else:\n            await self.session.delete(book)\n\n            await self.session.commit()\n\n            return {}\n</code></pre> <p>Let update our routes to ensure they use our newly created book database to Create, Read, Update and Delete our book database record. The source code for <code>src/books/service.py</code> should look like this at this point.</p> <pre><code># inside /src/books/service.py\nfrom sqlmodel.ext.asyncio.session import AsyncSession\nfrom .models import Book\nfrom .schemas import BookCreateSchema\nfrom sqlmodel import select, desc\n\n\nclass BookService:\n    \"\"\"\n    This class provides methods to create, read, update, and delete books\n    \"\"\"\n\n    def __init__(self, session: AsyncSession):\n        self.session = session\n\n    async def get_all_books(self):\n        \"\"\"\n        Get a list of all books\n\n        Returns:\n            list: list of books\n        \"\"\"\n        statement = select(Book).order_by(desc(Book.created_at))\n\n        result = await self.session.exec(statement)\n\n        return result.all()\n\n    async def create_book(self, book_create_data: BookCreateSchema):\n        \"\"\"\n        Create a new book\n\n        Args:\n            book_create_data (BookCreateModel): data to create a new\n\n        Returns:\n            Book: the new book\n        \"\"\"\n        new_book = Book(**book_create_data.model_dump())\n\n        self.session.add(new_book)\n\n        await self.session.commit()\n\n        return new_book\n\n    async def get_book(self, book_uid: str):\n        \"\"\"Get a book by its UUID.\n\n        Args:\n            book_uid (str): the UUID of the book\n\n        Returns:\n            Book: the book object\n        \"\"\"\n        statement = select(Book).where(Book.uid == book_uid)\n\n        result = await self.session.exec(statement)\n\n        book = result.first()\n\n        return book if book else None\n\n    async def update_book(self, book_uid: str, book_update_data: BookCreateSchema):\n        \"\"\"Update a book\n\n        Args:\n            book_uid (str): the UUID of the book\n            book_update_data (BookCreateModel): the data to update the book\n\n        Returns:\n            Book: the updated book\n        \"\"\"\n\n        book = await self.get_book(book_uid=book_uid)\n\n        if book is not None:\n\n            for key, value in book_update_data.model_dump().items():\n                setattr(book, key, value)\n\n            await self.session.commit()\n\n            return book\n\n        else:\n            return None\n\n    async def delete_book(self, book_uid):\n        \"\"\"Delete a book\n\n        Args:\n            book_uid (str): the UUID of the book\n        \"\"\"\n        book = await self.get_book(book_uid=book_uid)\n\n        if book is not None:\n            await self.session.delete(book)\n\n            await self.session.commit()\n\n            return {}\n\n        else:\n            return None\n</code></pre>"},{"location":"chapter6/#dependency-injection","title":"Dependency Injection","text":"<p>Now that we have created the <code>BookService</code> class, we need to create the <code>session</code> object that we shall use a dependency in every API route that shall interact with the database in any way.</p> <p>Dependency injection in FastAPI allows for the sharing of state among multiple API routes by providing a mechanism to create Python objects, referred to as dependencies, and accessing them only when necessary within dependant functions. While the concept may initially seem technical and esoteric, it is a fundamental aspect of FastAPI that proves remarkably beneficial across various scenarios. Interestingly, we often employ dependency injection without realizing it, demonstrating its widespread usefulness. Some potential applications include:</p> <ul> <li>Gathering input parameters for HTTP requests (Path and query parameters)</li> <li>Validating parameters inputs</li> <li>Checking authentication and authorization (we shall look at this in coming chapters)</li> <li>Emitting logs and metrics e.t.c.</li> </ul> <p>Let us create our first dependency: <pre><code># add this to src/db/main.py\nfrom sqlmodel.ext.asyncio.session import AsyncSession\nfrom sqlalchemy.orm import sessionmaker\n\n... # rest of main.py\n\nasync def get_session() -&gt; AsyncSession:\n    \"\"\"Dependency to provide the session object\"\"\"\n    async_session = sessionmaker(\n        bind=async_engine, class_=AsyncSession, expire_on_commit=False\n    )\n\n    async with async_session() as session:\n        yield session\n</code></pre></p> <p>In the above code, we define an async function called <code>get_session</code> that should return an object of the <code>AsyncSesion</code> class. This class is what allows us to use an aync DBAPI to interact with the database. That is the object we shall create all <code>BookService</code> objects with.</p> <p>Now that we have an understanding of how we shall get our session, let us go to the <code>src/books/routes.py</code> and modify it to make calls to the methods we have so far defined inside the <code>BookService</code> class.</p> <pre><code># inside src/books/routes.py\nfrom fastapi import APIRouter, Depends\nfrom sqlmodel.ext.asyncio.session import AsyncSession\nfrom src.books.book_data import books\nfrom src.books.schemas import BookSchema, BookUpdateSchema\nfrom src.db.main import get_session\nfrom .service import BookService\n\nbook_router = APIRouter()\n\n\n@book_router.get(\"/\")\nasync def read_books(session: AsyncSession = Depends(get_session)):\n    \"\"\"Read all books\"\"\"\n    books = await BookService(session).get_all_books()\n    return books\n\n\n@book_router.get(\"/{book_uid}\")\nasync def read_book(book_uid: str, session: AsyncSession = Depends(get_session)):\n    \"\"\"Read a book\"\"\"\n    book = await BookService(session).get_book(book_uid)\n    return book\n\n\n@book_router.post(\"/\", status_code=201)\nasync def create_book(book: BookSchema, session: AsyncSession = Depends(get_session)):\n    \"\"\"Create a new book\"\"\"\n    new_book = await BookService(session).create_book(book)\n\n    return new_book\n\n\n@book_router.patch(\"/{book_uid}\")\nasync def update_book(\n    book_uid: int,\n    update_data: BookUpdateSchema,\n    session: AsyncSession = Depends(get_session),\n):\n    \"\"\" \"update book\"\"\"\n\n    updated_book = await BookService(session).update_book(book_uid, update_data)\n\n    return updated_book\n\n\n@book_router.delete(\"/{book_uid}\", status_code=204)\nasync def delete_book(book_uid: str, session: AsyncSession = Depends(get_session)):\n    \"\"\"delete a book\"\"\"\n    result = await BookService(session).delete_book(book_uid)\n\n    if result is not None:\n        return {}\n    else:\n        return JSONResponse(\n            content={\"error\": \"book not found\"}, status_code=status.HTTP_404_NOT_FOUND\n        )\n</code></pre> <p>We've made minimal changes to the file but have introduced some updates that I'll outline here. Let's start by examining the dependency injection we've integrated. Take note of how we've included the following code in each route handler function. <pre><code>session: AsyncSession = Depends(get_session)\n</code></pre> What we're accomplishing here is the sharing of the <code>session</code> generated by calling the <code>get_session</code> function we defined earlier in this chapter.</p> <p>Once the <code>session</code> is established, we proceed to instantiate the <code>BookService</code> class. This instance allows us to utilize its methods for performing various CRUD operations as needed.</p> <p><pre><code>    books = await BookService(session).get_all_books()\n</code></pre> We instantiate the <code>BookService</code> function to invoke its <code>get_all_books()</code> method, supplying the session as a dependency to the route handler that includes the above code.</p>"},{"location":"chapter6/#conclusion","title":"Conclusion","text":"<p>In this chapter, we expanded our application to incorporate CRUD operations on our book data by leveraging our persistent PostgreSQL database. We explored how to utilize SQLModel to accomplish this task efficiently.</p> <p>Previous: Databases with SQLModel</p> <p>Next: Finishing Up the CRUD</p>"},{"location":"chapter7/","title":"Creating the User Authentication Model","text":"<p>Now that we have a working CRUD API, let's move on to more advanced topics. The first thing we need to tackle is figuring out who our users are and what they can do in the application. This breaks down into two main points:</p> <ul> <li>Authentication: Making sure users are who they say they are.</li> <li>Authorization: Deciding what actions users are allowed to take based on their identity.</li> </ul>"},{"location":"chapter7/#creating-the-user-account-model","title":"Creating the user account model","text":"<p>To achieve that, we shall begin by having a database model for keeping information about user accounts. Our current project structure looks like. <pre><code>\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 requirements.txt\n\u2514\u2500\u2500 src\n    \u251c\u2500\u2500 books\n    \u2502   \u251c\u2500\u2500 book_data.py\n    \u2502   \u251c\u2500\u2500 __init__.py\n    \u2502   \u251c\u2500\u2500 models.py\n    \u2502   \u251c\u2500\u2500 routes.py\n    \u2502   \u251c\u2500\u2500 schemas.py\n    \u2502   \u2514\u2500\u2500 service.py\n    \u251c\u2500\u2500 config.py\n    \u251c\u2500\u2500 db\n    \u2502   \u251c\u2500\u2500 __init__.py\n    \u2502   \u2514\u2500\u2500 main.py\n    \u2514\u2500\u2500 __init__.py\n</code></pre></p> <p>Inside the <code>src</code> folder, we shall create a directory called <code>auth</code>. This shall keep all source code associated with user account management. Inside it, we shall create a <code>__init__.py</code> file to mark it as a Python package. Our updated directory structure is now:</p> <pre><code>\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 requirements.txt\n\u2514\u2500\u2500 src\n    \u251c\u2500\u2500 auth\n    \u2502   \u2514\u2500\u2500 __init__.py\n    \u251c\u2500\u2500 books\n    \u2502   \u251c\u2500\u2500 book_data.py\n    \u2502   \u251c\u2500\u2500 __init__.py\n    \u2502   \u251c\u2500\u2500 models.py\n    \u2502   \u251c\u2500\u2500 routes.py\n    \u2502   \u251c\u2500\u2500 schemas.py\n    \u2502   \u2514\u2500\u2500 service.py\n    \u251c\u2500\u2500 config.py\n    \u251c\u2500\u2500 db\n    \u2502   \u251c\u2500\u2500 __init__.py\n    \u2502   \u2514\u2500\u2500 main.py\n    \u2514\u2500\u2500 __init__.py\n</code></pre> <p>Let us now add a <code>models.py</code> file in which we shall create the user account model. </p> <pre><code># inside src/auth/models.py\nfrom sqlmodel import SQLModel, Field, Column\nimport sqlalchemy.dialects.postgresql as pg\nimport uuid\n\n\nclass User(SQLModel, table=True):\n    __tablename__ = \"user_accounts\"\n\n    uid: uuid.UUID = Field(\n        sa_column=Column(\n            pg.UUID,\n            primary_key=True,\n            unique=True,\n            nullable=False,\n            default=uuid.uuid4,\n            info={\"description\": \"Unique identifier for the user account\"},\n        )\n    )\n\n    username: str\n    first_name: str = Field(nullable=True)\n    last_name: str = Field(nullable=True)\n    is_verified: bool = False\n    email: str\n    password_hash: str\n    created_at: datetime = Field(sa_column=Column(pg.TIMESTAMP, default=func.now))\n\n    def __repr__(self) -&gt; str:\n        return f\"&lt;User {self.username}&gt;\"\n</code></pre> <p>Most of the code here was explained in Chapter 5, so I will only cover what is new.</p> <ul> <li>We created a database model called <code>User</code> with the table name <code>user_accounts</code>.</li> <li> <p>The primary fields added include <code>uuid</code>, along with other fields such as <code>first_name</code>, <code>last_name</code>, <code>email</code>, <code>password_hash</code>, <code>created_at</code>, and <code>is_verified</code>.</p> </li> <li> <p>The <code>is_verified</code> field is necessary as it allows us to verify user-provided email addresses, ensuring we only deal with valid email addresses.</p> </li> </ul> <p>Once we have created this database model, let's save it and ensure the table is reflected in our database.</p>"},{"location":"chapter7/#database-migrations-with-alembic","title":"Database Migrations with Alembic","text":"<p>Previously, we applied changes to the database using the lifespan event created in Chapter 5. This method allowed us to create the table each time our server started, which was helpful during development. However, in a production environment, we need a proper database migration system to migrate changes to our database schema without restarting our server.</p> <p>To achieve this, we will use Alembic, a database migration tool for use with SQLAlchemy. Since we are using SQLModel, which is based on SQLAlchemy, Alembic will be very useful.</p> <p>Let's begin by installing Alembic in our virtual environment using <code>pip</code>: <pre><code>(env) $ pip install alembic\n</code></pre></p> <p>To confirm that Alembic has been installed, run the following command: <pre><code>(env) $ alembic --version\nalembic 1.13.1\n</code></pre></p> <p>Alembic is installed and the version is <code>1.13.1</code>. Now, let's initialize Alembic in our project with this command: <pre><code>(env) $ alembic init -t async migrations\n  Creating directory '/home/jod35/Documents/fastapi-beyond-CRUD/migrations' ...  done\n  Creating directory '/home/jod35/Documents/fastapi-beyond-CRUD/migrations/versions' ...  done\n  Generating /home/jod35/Documents/fastapi-beyond-CRUD/migrations/script.py.mako ...  done\n  Generating /home/jod35/Documents/fastapi-beyond-CRUD/migrations/env.py ...  done\n  Generating /home/jod35/Documents/fastapi-beyond-CRUD/alembic.ini ...  done\n  Generating /home/jod35/Documents/fastapi-beyond-CRUD/migrations/README ...  done\n  Please edit configuration/connection/logging settings in '/home/jod35/Documents/fastapi-beyond-CRUD/alembic.ini' before proceeding.\n</code></pre></p> <p>The above command uses Alembic to create a migration environment. The migration environment, in this case, is the <code>migrations</code> folder added to our project directory. This folder and the <code>alembic.ini</code> file are generated by Alembic and form the migration environment.</p> <p>We used the <code>-t</code> option to specify the template for setting up the environment. We chose the async template because our project uses an async DBAPI.</p> <p>Now, our folder structure looks like this: <pre><code>\u251c\u2500\u2500 alembic.ini\n\u251c\u2500\u2500 migrations\n\u2502   \u251c\u2500\u2500 env.py\n\u2502   \u251c\u2500\u2500 README\n\u2502   \u251c\u2500\u2500 script.py.mako\n\u2502   \u2514\u2500\u2500 versions\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 requirements.txt\n\u2514\u2500\u2500 src\n    \u251c\u2500\u2500 auth\n    \u2502   \u251c\u2500\u2500 __init__.py\n    \u2502   \u251c\u2500\u2500 models.py\n    \u251c\u2500\u2500 books\n    \u2502   \u251c\u2500\u2500 book_data.py\n    \u2502   \u251c\u2500\u2500 __init__.py\n    \u2502   \u251c\u2500\u2500 models.py\n    \u2502   \u251c\u2500\u2500 routes.py\n    \u2502   \u251c\u2500\u2500 schemas.py\n    \u2502   \u2514\u2500\u2500 service.py\n    \u251c\u2500\u2500 config.py\n    \u251c\u2500\u2500 db\n    \u2502   \u251c\u2500\u2500 __init__.py\n    \u2502   \u2514\u2500\u2500 main.py\n    \u2514\u2500\u2500 __init__.py\n</code></pre></p> <p>The <code>migrations</code> directory contains the following: - <code>versions/</code>: This folder will contain Python scripts created for each migration to track database changes. - <code>env.py</code>: This script serves as the entry point for Alembic. When you run Alembic commands like <code>alembic init</code>, <code>alembic revision</code>, or <code>alembic upgrade</code>, this script executes the necessary actions. - <code>README</code>: This file contains a description of the migration environment we have set up. - <code>script.py.mako</code>: This is a template used by Alembic to create new Python migration scripts each time we create a new migration.</p> <p>Sure, here is the rewritten text:</p> <p>The <code>alembic.ini</code> file contains configurations for Alembic that enable it to interact with our database and project.</p> <p>Now that we understand our migration environment, let's set up SQLModel to work with Alembic. We start by editing <code>migrations/env.py</code>:</p> <pre><code>import asyncio\nfrom logging.config import fileConfig\n\nfrom sqlalchemy import pool\nfrom sqlalchemy.engine import Connection\nfrom sqlalchemy.ext.asyncio import async_engine_from_config\n\nfrom alembic import context\nfrom sqlmodel import SQLModel # new change\nfrom src.auth.models import User # new change\n\n# this is the Alembic Config object, which provides\n# access to the values within the .ini file in use.\nconfig = context.config\n\n# Interpret the config file for Python logging.\n# This line sets up loggers basically.\nif config.config_file_name is not None:\n    fileConfig(config.config_file_name)\n\n# add your model's MetaData object here\n# for 'autogenerate' support\n# from myapp import mymodel\n# target_metadata = mymodel.Base.metadata\ntarget_metadata = SQLModel.metadata # new change\n\n... # the rest of env.py\n</code></pre> <p>In this example, we import the <code>User</code> model we created in <code>/src/auth/models.py</code>. This is necessary because Alembic will automatically generate changes to the model. Additionally, we import the <code>SQLModel</code> class to access the <code>metadata</code> object, which Alembic uses to track changes to our database model using SQLModel.</p> <p>Next, we edit the <code>migrations/script.py.mako</code> file to include SQLModel:</p> <pre><code># inside migrations/script.mako.py\n\"\"\"${message}\n\nRevision ID: ${up_revision}\nRevises: ${down_revision | comma,n}\nCreate Date: ${create_date}\n\n\"\"\"\nfrom typing import Sequence, Union\n\nfrom alembic import op\nimport sqlalchemy as sa\nimport sqlmodel # ADD THIS\n\n...\n</code></pre> <p>We then edit <code>alembic.ini</code> to specify the URL to the database we want to migrate:</p> <pre><code># set to 'true' to search source files recursively\n# in each \"version_locations\" directory\n# new in Alembic version 1.10\n# recursive_version_locations = false\n\n# the output encoding used when revision files\n# are written from script.py.mako\n# output_encoding = utf-8\n\nsqlalchemy.url = postgresql+asyncpg://user:pswd@host/db # use the URL to your database\n</code></pre> <p>Having made these changes, let's create our first database migration. Our database currently contains only the <code>books</code> table. We'll create a migration to add the <code>user_accounts</code> table:</p> <pre><code>(env) $ alembic revision --autogenerate -m \"init\"\nINFO  [alembic.runtime.migration] Context impl PostgresqlImpl.\nINFO  [alembic.runtime.migration] Will assume transactional DDL.\nINFO  [alembic.autogenerate.compare] Detected added table 'user_accounts'\n  Generating /home/jod35/Documents/fastapi-beyond-CRUD/migrations/versions/8cf8276d5f3c_init.py ...  done\n</code></pre> <p>The newly created <code>migrations/versions/8cf8276d5f3c_init.py</code> file contains the following:</p> <pre><code># inside src/migrations/versions/8cf8276d5f3c_init.py\n\"\"\"init\n\nRevision ID: 8cf8276d5f3c\nRevises: \nCreate Date: 2024-05-21 19:27:53.577277\n\n\"\"\"\nfrom typing import Sequence, Union\n\nfrom alembic import op\nimport sqlalchemy as sa\nimport sqlmodel\n\nfrom sqlalchemy.dialects import postgresql\n\n# revision identifiers, used by Alembic.\nrevision: str = '8cf8276d5f3c'\ndown_revision: Union[str, None] = None\nbranch_labels: Union[str, Sequence[str], None] = None\ndepends_on: Union[str, Sequence[str], None] = None\n\n\ndef upgrade() -&gt; None:\n    # ### commands auto generated by Alembic - please adjust! ###\n    op.create_table('user_accounts',\n    sa.Column('uid', sa.UUID(), nullable=False),\n    sa.Column('username', sqlmodel.sql.sqltypes.AutoString(), nullable=False),\n    sa.Column('first_name', sqlmodel.sql.sqltypes.AutoString(), nullable=True),\n    sa.Column('last_name', sqlmodel.sql.sqltypes.AutoString(), nullable=True),\n    sa.Column('is_verified', sa.Boolean(), nullable=False),\n    sa.Column('email', sqlmodel.sql.sqltypes.AutoString(), nullable=False),\n    sa.Column('password_hash', sqlmodel.sql.sqltypes.AutoString(), nullable=False),\n    sa.Column('created_at', postgresql.TIMESTAMP(), nullable=True),\n    sa.PrimaryKeyConstraint('uid'),\n    sa.UniqueConstraint('uid')\n    )\n    # ### end Alembic commands ###\n\n\ndef downgrade() -&gt; None:\n    # ### commands auto generated by Alembic - please adjust! ###\n    op.drop_table('user_accounts')\n    # ### end Alembic commands ###\n</code></pre> <p>This code includes:</p> <ul> <li><code>revision</code>: The unique identifier for this migration.</li> <li><code>down_revision</code>: The identifier of the previous migration, set to <code>None</code> for the initial migration.</li> <li><code>branch_labels</code> and <code>depends_on</code>: Optional fields, set to <code>None</code>.</li> </ul> <p>The <code>upgrade</code> function defines the changes to the database structure, creating the <code>user_accounts</code> table with specified columns. The <code>downgrade</code> function reverts these changes by dropping the <code>user_accounts</code> table if the migration is undone.</p> <p>To apply these changes to the database, use the following command:</p> <pre><code>(env) $ alembic upgrade head\nINFO  [alembic.runtime.migration] Context impl PostgresqlImpl.\nINFO  [alembic.runtime.migration] Will assume transactional DDL.\nINFO  [alembic.runtime.migration] Running upgrade  -&gt; 8cf8276d5f3c, init\n</code></pre> <p>This command creates the <code>user_accounts</code> table in the database. To verify, list the tables in your current database:</p> <pre><code>(env) $ psql --username=&lt;your-username&gt; --dbname=&lt;your-db&gt;\n</code></pre> <p>For example:</p> <pre><code>(env) $ psql --username=jod35 --dbname=books\npsql (14.11 (Ubuntu 14.11-0ubuntu0.22.04.1))\nType \"help\" for help.\n\nbooks=# \\dt\n            List of relations\n Schema |      Name       | Type  | Owner \n--------+-----------------+-------+-------\n public | alembic_version | table | jod35\n public | books           | table | jod35\n public | user_accounts   | table | jod35\n(3 rows)\n</code></pre> <p>The <code>alembic_version</code> and <code>user_accounts</code> tables have been created. Let's examine their structures.</p> <p>For <code>alembic_version</code>:</p> <pre><code>books=# \\d alembic_version\n                    Table \"public.alembic_version\"\n   Column    |         Type          | Collation | Nullable | Default \n-------------+-----------------------+-----------+----------+---------\n version_num | character varying(32) |           | not null | \nIndexes:\n    \"alembic_version_pkc\" PRIMARY KEY, btree (version_num)\n</code></pre> <p>This table includes one column, <code>version_num</code>, which keeps records of the version numbers of changes made to the database structure.</p> <p>For <code>user_accounts</code>:</p> <pre><code>books=# \\d user_accounts\n                         Table \"public.user_accounts\"\n    Column     |            Type             | Collation | Nullable | Default \n---------------+-----------------------------+-----------+----------+---------\n uid           | uuid                        |           | not null | \n username      | character varying           |           | not null | \n first_name    | character varying           |           |          | \n last_name     | character varying           |           |          | \n is_verified   | boolean                     |           | not null | \n email         | character varying           |           | not null | \n password_hash | character varying           |           | not null | \n created_at    | timestamp without time zone\n\n```console\ncreated_at    | timestamp without time zone |           |          | \nIndexes:\n    \"user_accounts_pkey\" PRIMARY KEY, btree (uid)\n</code></pre> <p>Ladies and gentlemen, we have successfully created the <code>user_accounts</code> table from the <code>User</code> model. Now that we have done this, let us look at some ways to implement authentication in FastAPI.</p>"},{"location":"chapter7/#conclusion","title":"Conclusion","text":"<p>In this chapter, we have created a simple database model to enable us manage user accounts in our application. We have introduced Alembic, a database migration tool that runs on SQLAlchemy database models, allowing us to easily introduce changes to an existing database structure without haveing to delete data.</p>"},{"location":"chapter8/","title":"JWT Authentication","text":""},{"location":"chapter8/#implementing-jwt-authentication","title":"Implementing JWT Authentication","text":"<p>In the previous chapter, we created a database model for user accounts. Using this, we are going to authenticate (show that our users are who they claim to be) and also authorize (show that they have the right access to specific parts of our application.)</p>"},{"location":"chapter8/#creating-user-accounts","title":"Creating User Accounts","text":"<p>Ths first task shall be one of making users join our application through signing up. Using thisstep, users shall have user accounts that can allow them use the application.</p> <p>Our current project structure is something like this. <pre><code>\u251c\u2500\u2500 alembic.ini\n\u251c\u2500\u2500 migrations\n\u2502   \u251c\u2500\u2500 env.py\n\u2502   \u251c\u2500\u2500 README\n\u2502   \u251c\u2500\u2500 script.py.mako\n\u2502   \u2514\u2500\u2500 versions\n\u2502       \u2514\u2500\u2500 8cf8276d5f3c_init.py\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 requirements.txt\n\u2514\u2500\u2500 src\n    \u251c\u2500\u2500 auth\n    \u2502   \u251c\u2500\u2500 __init__.py\n    \u2502   \u251c\u2500\u2500 models.py\n    \u251c\u2500\u2500 books\n    \u2502   \u251c\u2500\u2500 book_data.py\n    \u2502   \u251c\u2500\u2500 __init__.py\n    \u2502   \u251c\u2500\u2500 models.py\n    \u2502   \u251c\u2500\u2500 routes.py\n    \u2502   \u251c\u2500\u2500 schemas.py\n    \u2502   \u2514\u2500\u2500 service.py\n    \u251c\u2500\u2500 config.py\n    \u251c\u2500\u2500 db\n    \u2502   \u251c\u2500\u2500 __init__.py\n    \u2502   \u2514\u2500\u2500 main.py\n    \u2514\u2500\u2500 __init__.py\n</code></pre></p> <p>Let us begin by creating <code>src/auth/routes.py</code> and adding the folowing code to it. <pre><code># inside src/auth/routes.py\nfrom fastapi import Depends, status\nfrom fastapi.exceptions import HTTPException\nfrom sqlmodel.ext.asyncio.session import AsyncSession\nfrom src.db.main import get_session\nfrom src.auth.schemas import UserCreationModel\nfrom src.auth.service import UserService\n\n\nauth_router = APIRouter()\n\n@auth_router.post(\"/signup\", status_code=status.HTTP_201_CREATED)\nasync def create_user_account(\n    user_data: UserCreationModel, session: AsyncSession = Depends(get_session)\n):\n\n    username = user_data.username\n    email = user_data.email\n    password = user_data.password\n\n    user = await UserService(session).get_user(email)\n\n    if user is not None:\n        raise HTTPException(\n            status_code=status.HTTP_403_FORBIDDEN,\n            detail={\"error\": \"User Account Already Exists\"},\n        )\n    else:\n        new_user = await UserService(session).create_user(user_data)\n        return {\"message\": \"User Created successfully\"}\n</code></pre></p>"}]}