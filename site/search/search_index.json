{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"FastAPI Beyond CRUD","text":"<p>This course material is tailored for my FastAPI Framework course. FastAPI has quickly emerged as one of Python's leading frameworks for crafting server-side web applications. I'm excited to present this comprehensive course, dedicated to helping you understand API development with FastAPI. I trust you'll find immense value in it as we delve into the complexities of building robust APIs.</p>"},{"location":"#about-me","title":"About Me:","text":"<p>My name is Ssali Jonathan. I am a software engineer based in Uganda. For about 3 years, I have been building a Youtube channel where I educate people about programming mainly using the Python language. I have worked on freelance, and fulltime roles. I have a passion for educating others and sharing knowledge.</p>"},{"location":"#please-donate-to-the-project","title":"Please donate to the project","text":"<p>I have made this course available for free on my Youtube channel and on this website. If you can support me to create more projects like this, please consider donating to my work using the following channels.</p> <p></p> <p>Become a Patron!</p>"},{"location":"#follow-me-on-the-following-platforms","title":"Follow me on the following platforms","text":"<ul> <li>Twitter</li> <li>Github</li> <li>Youtube</li> </ul>"},{"location":"chapter1/","title":"Installation and Project SetUp","text":"<p>In chapter, we install FastAPI, starting with a minimal setup.</p>"},{"location":"chapter1/#1-virtual-environment-creation","title":"1. Virtual Environment Creation","text":"<p>Begin by creating a virtual environment using the built-in Python module <code>venv</code>. If you already have Python installed, you might not need to install it separately. However, on Linux, installation may be necessary based on your distribution. In your commandline or terminal, type the following command.</p> <pre><code>python3 -m venv env\n</code></pre> <p>This command generates a virtual environment in the specified folder (in our example, <code>env</code>). This folder is an isolated Python environment which shall separate the dependencies of our project from the system wide Python installation.</p> <p>Activate the virtual environment using the following commands:</p> <p>On Linux or macOS: <pre><code>source env/bin/activate\n</code></pre></p> <p>On Windows: <pre><code>env/Scripts/activate\n</code></pre></p> <p>Once activated, your command line will indicate the active virtual environment:</p> <p>On Linux or macOS: <pre><code>(env) yourusername@yourmachine$\n</code></pre></p> <p>On Windows: <pre><code>(env) C:\\users\\YourUsername&gt;\n</code></pre></p>"},{"location":"chapter1/#2-directory-structure","title":"2. Directory Structure","text":"<p>At this point, your directory structure should look like this:</p> <pre><code>\u2514\u2500\u2500 env\n</code></pre>"},{"location":"chapter1/#3-installing-fastapi","title":"3. Installing FastAPI","text":"<p>Now, let us install FastAPI within the virtual environment. We shall install FastAPI with the <code>pip</code> using the following command. </p> <pre><code>(env) pip install fastapi\n</code></pre>"},{"location":"chapter1/#4-freeze-dependencies","title":"4. Freeze Dependencies","text":"<p>Freeze the installed dependencies into a <code>requirements.txt</code> file to track the exact versions of our dependencies so that we can easily reproduce them in the future.</p> <pre><code>(env) pip freeze &gt; requirements.txt\n</code></pre>"},{"location":"chapter1/#5-confirm-the-installation","title":"5. Confirm the installation","text":"<p>Let us confirm our fastapi installation by running the following command. <pre><code>(env) fastapi --version\nFastAPI CLI version: 0.0.2\n</code></pre> This command shall show us the version of FastAPI CLI the FastAPI commandline interface. The <code>fastapi</code> command shall help us run and manage our app as we shall see in the coming chapters.</p> <p>If the version has been displayed, then we are sure that FastAPI has been installed in our virtual environment.</p>"},{"location":"chapter1/#conclusion","title":"Conclusion","text":"<p>By following these steps, you have successfully set up a virtual environment, and installed FastAPI, frozen the dependencies for future reproducing of the project and you have verified your installation using the <code>fastapi</code> CLI command. This structured approach ensures a clean and manageable development environment for our FastAPI project. Next, we shall create a simple web server and create our first API routes.</p>"},{"location":"chapter10/","title":"Role Based Access Control","text":""},{"location":"chapter10/#introduction","title":"Introduction","text":"<p>With  our JWT Authentication set, let us set up a system that will allow users to access specific parts of our app based on their role within our application. This is what is referred to as **Role-Based Access Control (RBAC). </p>"},{"location":"chapter10/#add-roles-to-users","title":"Add Roles To Users","text":"<p>Role-Based access control regulates access to resources within an application based on the roles that have. Users are assigned roles, and to each of these roles, permissions can be assigned. To implement this, we are going to first of all need a role assigned to each of our users.</p> <p>To do that, Let us go to <code>src/auth/models.py</code> and make some changes to the user authentication model. adding role attribute<pre><code>class User(SQLModel, table=True):\n    __tablename__ = \"users\"\n    uid: uuid.UUID = Field(\n        sa_column=Column(pg.UUID, nullable=False, primary_key=True, default=uuid.uuid4)\n    )\n    username: str\n    email: str\n    first_name: str\n    last_name: str\n\n    # let us add this line\n    role: str = Field(\n        sa_column=Column(pg.VARCHAR, nullable=False, server_default=\"user\")\n    ) \n    is_verified: bool = Field(default=False)\n    password_hash: str \n    created_at: datetime = Field(sa_column=Column(pg.TIMESTAMP, default=datetime.now))\n    update_at: datetime = Field(sa_column=Column(pg.TIMESTAMP, default=datetime.now))\n\n    def __repr__(self):\n        return f\"&lt;User {self.username}&gt;\"\n</code></pre></p> <p>What we have done is to add a <code>role</code> field to the user authentication model. Let us apply this to the database using Alembic.</p> <pre><code>$ alembic revision --autogenerate -m \"add role to users table\"\n</code></pre> <p>We have created a revision to add the role to our table. To make it refelect in the database, we are going to apply it to the database using this command.</p> <pre><code>$ alembic upgrade head\n</code></pre>"},{"location":"chapter10/#get-the-current-authenticated-user","title":"Get The Current Authenticated User","text":"<p>Now that we've successfully added the role field to the database table without encountering errors, let's proceed to create a dependency that enables us to retrieve the currently authenticated user. Please incorporate the following code into src/auth/dependencies.py.</p> dependency to get the currently logged in user<pre><code>async def get_current_user(\n    token_details: dict = Depends(AccessTokenBearer()),\n    session: AsyncSession = Depends(get_session),\n):\n    user_email = token_details[\"user\"][\"email\"]\n\n    user = await user_service.get_user_by_email(user_email, session)\n\n    return user\n</code></pre> <p>This dependency uses the <code>AccessTokenBearer</code> dependency to obtain the details of an access token and then extract the user details from it. Once the user details are extracted, the <code>get_user_by_email</code> method of the <code>user_service</code> object is utilized to retrieve the user object based on the email obtained. The user object is then returned, completing the process of identifying and fetching the currently authenticated user. This ensures that the application can accurately verify the identity and role of the user making the request.</p> <p>Note</p> <p>Dependencies can also be injected into other dependencies. You can not use dependencies inside functions that will not be injected into API paths.</p> <p>Let us now create an API endpoint for getting the current authenticated user. Edit <code>src/auth/routes.py</code> to add the following code.</p> getting the current authenticated user<pre><code>from fastapi import APIRouter, Depends, status\nfrom .schemas import UserBooksModel, UserCreateModel, UserLoginModel, UserModel\nfrom .dependencies import (AccessTokenBearer, RefreshTokenBearer,get_current_user)\n\n\nauth_router = APIRouter()\nuser_service = UserService()\n\n\n@auth_router.get(\"/me\", response_model=UserBooksModel)\nasync def get_current_user(user=Depends(get_current_user)):\n    return user\n</code></pre> <p>The code above gets the currently logged in user by using the <code>get_current_user</code> dependency that returns the user object. </p> <p>When tested, this gives the response shown below. </p>"},{"location":"chapter10/#creating-the-role-checker-dependency","title":"Creating the Role Checker dependency","text":"<p>Let us proceed by creating the role checker dependency. Let us add the following code to the <code>src/auth/dependencies.py</code></p> Role checker dependencies<pre><code>class RoleChecker:\n    def __init__(self, allowed_roles: List[str]) -&gt; None:\n        self.allowed_roles = allowed_roles\n\n    def __call__(self, current_user: User = Depends(get_current_user)) -&gt; Any:\n        if current_user.role in self.allowed_roles:\n            return True\n\n        raise HTTPException(\n            status_code = status.HTTP_403_FORBIDDEN,\n            detail=\"You are not allowed to perform this action.\n        )\n</code></pre> <p>The RoleChecker class allows us to create objects that will enforce role-based access control for API endpoints. By specifying a list of roles in allowed_roles, we can restrict access to endpoints based on the user's role.</p> <p>The <code>__call__</code> method uses the Depends function to get the currently authenticated user. It then checks if the user's role is in the list of allowed_roles. If the role is not in the list, an HTTPException with a 403 status code is raised, indicating that the user does not have permission to perform the action.</p> <p>To use the RoleChecker dependency, let\u2019s start by adding Role-Based Access Control (RBAC) to the endpoint that allows us to retrieve the currently logged-in user. Inside <code>src/auth/routes</code>, add the following code:</p> using the role checker dependency<pre><code>from .dependencies import (\n    AccessTokenBearer,\n    RefreshTokenBearer,\n    RoleChecker,\n    get_current_user,\n)\n\nauth_router = APIRouter()\nrole_checker = RoleChecker([\"admin\"])\n\n... # rest of the code insde here\n\n@auth_router.get(\"/me\", response_model=UserBooksModel)\nasync def get_current_user(\n    user=Depends(get_current_user), _: bool = Depends(role_checker)\n):\n    return user\n</code></pre> <p>To test this, we shall get to our client and make a request to the endpoint.  </p> <p>As shown in the example, the current user is denied access to the endpoint because they lack sufficient permissions, specifically, they are not an admin.</p> <p>To address this, we can modify the role_checker to include the user role, thereby granting access to users with either the admin or user role. This change ensures that both admins and regular users can access the endpoint.</p> role checker with user role<pre><code>role_checker = RoleChecker([\"admin\",\"user\"])\n</code></pre> <p>By updating the role_checker to include the user role, we allow users who have the role of user to access the endpoint in addition to those with the admin role. This makes the endpoint accessible to a broader range of users, depending on the defined roles and permissions.</p>"},{"location":"chapter10/#use-rbac-with-other-api-endpoints","title":"Use RBAC with other API endpoints","text":"<p>Let's proceed to enhance the security of all book endpoints by implementing Role-Based Access Control. In src/books/routes.py, let's update the code with the following modifications. Book routes with RBAC<pre><code>from fastapi import APIRouter, status, Depends\nfrom fastapi.exceptions import HTTPException\nfrom .schemas import Book, BookUpdateModel, BookCreateModel, BookDetailModel\nfrom sqlmodel.ext.asyncio.session import AsyncSession\nfrom src.books.service import BookService\nfrom src.db.main import get_session\nfrom typing import List\nfrom src.auth.dependencies import AccessTokenBearer, RoleChecker\n\n\nbook_router = APIRouter()\nbook_service = BookService()\nacccess_token_bearer = AccessTokenBearer()\nrole_checker = Depends(RoleChecker([\"admin\", \"user\"]))\n\n\n@book_router.get(\"/\", response_model=List[Book], dependencies=[role_checker])\nasync def get_all_books(\n    session: AsyncSession = Depends(get_session),\n    token_details: dict = Depends(acccess_token_bearer),\n):\n    books = await book_service.get_all_books(session)\n    return books\n\n@book_router.get(\"/user/{user_uid}\", response_model=List[Book], dependencies=[role_checker])\nasync def get_user_book_submissions(\n    user_uid:str,\n    session: AsyncSession = Depends(get_session),\n    token_details: dict = Depends(acccess_token_bearer),\n):\n    books = await book_service.get_user_books(user_uid,session)\n    return books\n\n\n@book_router.post(\n    \"/\",\n    status_code=status.HTTP_201_CREATED,\n    response_model=Book,\n    dependencies=[role_checker],\n)\nasync def create_a_book(\n    book_data: BookCreateModel,\n    session: AsyncSession = Depends(get_session),\n    token_details: dict = Depends(acccess_token_bearer),\n) -&gt; dict:\n    user_id = token_details.get(\"user\")[\"user_uid\"]\n    new_book = await book_service.create_book(book_data, user_id, session)\n    return new_book\n\n\n@book_router.get(\"/{book_uid}\", response_model=BookDetailModel, dependencies=[role_checker])\nasync def get_book(\n    book_uid: str,\n    session: AsyncSession = Depends(get_session),\n    token_details: dict = Depends(acccess_token_bearer),\n) -&gt; dict:\n    book = await book_service.get_book(book_uid, session)\n\n    if book:\n        return book\n    else:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND, detail=\"Book not found\"\n        )\n\n\n@book_router.patch(\"/{book_uid}\", response_model=Book, dependencies=[role_checker])\nasync def update_book(\n    book_uid: str,\n    book_update_data: BookUpdateModel,\n    session: AsyncSession = Depends(get_session),\n    token_details: dict = Depends(acccess_token_bearer),\n) -&gt; dict:\n    updated_book = await book_service.update_book(book_uid, book_update_data, session)\n\n    if updated_book is None:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND, detail=\"Book not found\"\n        )\n\n    else:\n        return updated_book\n\n\n@book_router.delete(\n    \"/{book_uid}\", status_code=status.HTTP_204_NO_CONTENT, dependencies=[role_checker]\n)\nasync def delete_book(\n    book_uid: str,\n    session: AsyncSession = Depends(get_session),\n    token_details: dict = Depends(acccess_token_bearer),\n):\n    book_to_delete = await book_service.delete_book(book_uid, session)\n\n    if book_to_delete is None:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND, detail=\"Book not found\"\n        )\n    else:\n        return {}\n</code></pre></p> <p>In ths above code, we have gone ahead to create a <code>role_checker</code> dependency by providing it as an argument to the <code>Depends</code> function. Not that this time we add it as a member to the <code>dependencies</code> list, an argument to the http method we create from the FastAPI <code>app</code> instance. THis makes our code cleaner since we do not need to use it in our route handler code as we have done for the rest of the other dependencies. <pre><code>@book_router.get(\"/{book_uid}\", response_model=BookDetailModel, dependencies=[role_checker])\n</code></pre></p>"},{"location":"chapter10/#conclusion","title":"Conclusion","text":"<p>By implementing the steps outlined, we have successfully integrated Role-Based Access Control (RBAC) into our API endpoints. This ensures that only users with the appropriate roles can access specific parts of the application, enhancing security and maintaining proper access management.</p>"},{"location":"chapter11/","title":"Model And Schema Relationships","text":""},{"location":"chapter11/#introduction","title":"Introduction","text":"<p>At this point, the only database tables that we have in our database look like the following. If you want such good database design diagrams, please use DB Diagrams</p> <p></p> <p>To ensure that users can submit multiple books in a one-to-many relationship, we can modify the database structure. Here's how the updated structure would look:</p> <p></p> <p>In this structure, we have not really made changes to the <code>users</code> table and we have modified the <code>books</code> table by adding the <code>user_uid</code> that referencing the <code>uid</code> field on the <code>users</code> table to establish a foreign key relationship.This relationship signifies that each book entry in the books table is associated with a single user who submitted it.</p>"},{"location":"chapter11/#associating-books-with-users-one-to-many-relationship","title":"Associating Books With Users (One To Many Relationship)","text":"<p>To achieve this, let us modify the <code>Book</code> database model in <code>src/books/models.py</code> to make the above changes take effect.</p> the modified books table<pre><code>class Book(SQLModel, table=True):\n    __tablename__ = \"books\"\n\n    uid: uuid.UUID = Field(\n        sa_column=Column(pg.UUID, nullable=False, primary_key=True, default=uuid.uuid4)\n    )\n    title: str\n    author: str\n    publisher: str\n    published_date: date\n    page_count: int\n    language: str\n    # add this line below\n    user_uid: Optional[uuid.UUID] = Field(default=None, foreign_key=\"users.uid\")\n    created_at: datetime = Field(sa_column=Column(pg.TIMESTAMP, default=datetime.now))\n    update_at: datetime = Field(sa_column=Column(pg.TIMESTAMP, default=datetime.now))\n\n    def __repr__(self):\n        return f\"&lt;Book {self.title}&gt;\"\n</code></pre> <p>The user_uid field in the Book class represents a foreign key relationship to the uid field in a hypothetical users table, linking each book entry to the user who submitted it. This field is optional (Optional[uuid.UUID]) and defaults to None, allowing for books that may not be associated with a specific user. When a user submits a book, their unique identifier (uid) would typically be stored in this field, enabling queries that link books to their respective owners. This design supports database integrity and enables efficient retrieval of books based on user ownership within the application's data model.</p> <p>For this change to reflect in the database, let us create an Alembic revision for it.</p> <pre><code>$ alembic revision --autogenerate -m \"add user_uid foreignkey to books\"\n</code></pre> <p>After that, we shall apply this revision to the database by using the following command</p> <pre><code>$ alembic upgrade head\n</code></pre> <p>The updated table structure of the <code>books</code> table will look like this. This shows that the<code>user_uid</code> has successfully been added to the <code>books</code> table.</p> <pre><code>$ psql --username=jod35 --dbname=books\npsql (16.3 (Ubuntu 16.3-1.pgdg22.04+1))\nType \"help\" for help.\n\nbooks=# \\d books\n                             Table \"public.books\"\n     Column     |            Type             | Collation | Nullable | Default\n----------------+-----------------------------+-----------+----------+---------\n uid            | uuid                        |           | not null |\n title          | character varying           |           | not null |\n author         | character varying           |           | not null |\n publisher      | character varying           |           | not null |\n published_date | date                        |           | not null |\n page_count     | integer                     |           | not null |\n language       | character varying           |           | not null |\n user_uid       | uuid                        |           |          |\n created_at     | timestamp without time zone |           |          |\n update_at      | timestamp without time zone |           |          |\n</code></pre>"},{"location":"chapter11/#associate-users-with-books","title":"Associate users with books","text":"<p>To ensure each book submission is associated with the currently authenticated user's user_uid, we'll modify the BookService class in src/books/service.py. Here's how you can adjust the code to accommodate this:</p> <pre><code>class BookService:\n    ... # rest of the code\n\n    async def get_user_books(self, user_uid: str, session: AsyncSession):\n        statement = (\n            select(Book)\n            .where(Book.user_uid == user_uid)\n            .order_by(desc(Book.created_at))\n        )\n\n        result = await session.exec(statement)\n\n        return result.all()\n\n    async def create_book(\n        self, book_data: BookCreateModel, user_uid: str, session: AsyncSession\n    ):\n        book_data_dict = book_data.model_dump()\n\n        new_book = Book(**book_data_dict)\n\n        new_book.published_date = datetime.strptime(\n            book_data_dict[\"published_date\"], \"%Y-%m-%d\"\n        )\n\n        new_book.user_uid = user_uid\n\n        session.add(new_book)\n\n        await session.commit()\n\n        return new_book\n</code></pre> <p>The modified <code>BookService</code> class includes two asynchronous methods to handle book submissions and retrievals, ensuring each book is associated with the currently authenticated user's <code>user_uid</code>. The <code>get_user_books</code> method retrieves all books submitted by a specific user, identified by their <code>user_uid</code>. It constructs a SQL query using SQLModel's select to fetch books where the <code>user_uid</code> matches the provided value, ordered by the book's creation date in descending order. The result of the query is executed asynchronously and returned as a list of books.</p> <p>The <code>create_book</code> method handles the creation of a new book entry. It takes in book data (wrapped in a BookCreateModel), the <code>user_uid</code> of the currently authenticated user, and an asynchronous database session (AsyncSession). The method converts the book data into a dictionary format and initializes a new Book instance with this data. It then parses and sets the <code>published_date</code> field and assigns the <code>user_uid</code> to link the book with the authenticated user. The new book instance is added to the session, and the session commits the transaction asynchronously, saving the new book to the database. This ensures each book submission is correctly associated with the user who submitted it.</p> <p>Let us also make these changes reflect in our routes.</p> modified route for creating books<pre><code>from fastapi import APIRouter, status, Depends\nfrom fastapi.exceptions import HTTPException\nfrom .schemas import Book, BookUpdateModel, BookCreateModel, BookDetailModel\nfrom sqlmodel.ext.asyncio.session import AsyncSession\nfrom src.books.service import BookService\nfrom src.db.main import get_session\nfrom typing import List\nfrom src.auth.dependencies import AccessTokenBearer, RoleChecker\n\n\nbook_router = APIRouter()\nbook_service = BookService()\nacccess_token_bearer = AccessTokenBearer()\nrole_checker = Depends(RoleChecker([\"admin\", \"user\"]))\n\n\n@book_router.post(\n    \"/\",\n    status_code=status.HTTP_201_CREATED,\n    response_model=Book,\n    dependencies=[role_checker],\n)\nasync def create_a_book(\n    book_data: BookCreateModel,\n    session: AsyncSession = Depends(get_session),\n    token_details: dict = Depends(acccess_token_bearer),\n) -&gt; dict:\n    user_id = token_details.get(\"user\")[\"user_uid\"]\n    new_book = await book_service.create_book(book_data, user_id, session) # change this\n    return new_book\n</code></pre> <p>The modified route for creating books now includes extracting the <code>user_uid</code> from the token details of the currently authenticated user. This <code>user_uid</code> is then passed to the <code>create_book</code> method of the <code>BookService</code> class. After we retrieve the user's unique identifier from the token:</p> getting the user_uid from token details<pre><code>user_id = token_details.get(\"user\")[\"user_uid\"]\n</code></pre> <p>To ensure that each book submission is correctly associated with the user who submitted it, we link the book to the user using the <code>user_uid</code>:</p> create book with user who added it<pre><code>new_book = await book_service.create_book(book_data, user_id, session)\n</code></pre> <p>Creating a Book will result in:</p> <p></p> <p>In the database, the book will be saved with the <code>user_uid</code>.</p>"},{"location":"chapter11/#relationship-attributes","title":"Relationship attributes","text":"<p>With the relationship between books and users established, let's explore a method of performing CRUD operations in a more object-oriented manner using relationship attributes. These attributes enable us to define fields in our model classes that serve not as database rows but as means to access related objects. For instance, we will retrieve all books added by a user using user.books, where books is the attribute that provides access to all the books submitted by the user.</p> <p>To begin, we shall create the attribute on the user tables that shall enable us get the books a user has sbumitted. Let us modify the <code>User</code> database model to include the following.</p> <pre><code>import uuid\nfrom datetime import date, datetime\nfrom typing import List, Optional\n\nimport sqlalchemy.dialects.postgresql as pg\nfrom sqlmodel import Column, Field, Relationship, SQLModel\n\n\nclass User(SQLModel, table=True):\n    __tablename__ = \"users\"\n    uid: uuid.UUID = Field(\n        sa_column=Column(pg.UUID, nullable=False, primary_key=True, default=uuid.uuid4)\n    )\n    username: str\n    email: str\n    first_name: str\n    last_name: str\n    role: str = Field(\n        sa_column=Column(pg.VARCHAR, nullable=False, server_default=\"user\")\n    )\n    is_verified: bool = Field(default=False)\n    password_hash: str = Field(\n        sa_column=Column(pg.VARCHAR, nullable=False), exclude=True\n    )\n    created_at: datetime = Field(sa_column=Column(pg.TIMESTAMP, default=datetime.now))\n    update_at: datetime = Field(sa_column=Column(pg.TIMESTAMP, default=datetime.now))\n\n    # add this\n    books: List[\"Book\"] = Relationship(\n        back_populates=\"user\", sa_relationship_kwargs={\"lazy\": \"selectin\"}\n    )\n\n    def __repr__(self):\n        return f\"&lt;User {self.username}&gt;\"\n</code></pre> <p>The change defines a relationship attribute <code>books</code> for a <code>User</code> model, which is a list of <code>Book</code> objects. The <code>Relationship</code> function establishes a two-way connection between the <code>User</code> and <code>Book</code> models, with <code>back_populates=\"user\"</code> indicating that each <code>Book</code> instance is linked back to the <code>User</code> instance that added it.</p> <p>The <code>sa_relationship_kwargs={\"lazy\": \"selectin\"}</code> parameter optimizes the query performance by loading related <code>Book</code> objects in a single query when the <code>User</code> object is accessed, reducing the number of database queries and improving efficiency.</p> <p>Let us also modify our Book model to have this change. Inside <code>src/books/models.py</code>,</p> books with a user relationship<pre><code>class Book(SQLModel, table=True):\n    __tablename__ = \"books\"\n    uid: uuid.UUID = Field(\n        sa_column=Column(pg.UUID, nullable=False, primary_key=True, default=uuid.uuid4)\n    )\n    title: str\n    author: str\n    publisher: str\n    published_date: date\n    page_count: int\n    language: str\n    user_uid: Optional[uuid.UUID] = Field(default=None, foreign_key=\"users.uid\")\n    created_at: datetime = Field(sa_column=Column(pg.TIMESTAMP, default=datetime.now))\n    update_at: datetime = Field(sa_column=Column(pg.TIMESTAMP, default=datetime.now))\n    user: Optional[User] = Relationship(back_populates=\"books\") #add this\n\n    def __repr__(self):\n        return f\"&lt;Book {self.title}&gt;\"\n</code></pre> <p>On the Book model, we have defined a relationship attribute <code>user</code>, which optionally refers to a User object. The <code>Relationship</code> function establishes a connection where each <code>Book</code> instance can be associated with a single <code>User</code> instance, specified by <code>back_populates=\"books\"</code>. This bidirectional relationship means that for every Book, there is a corresponding User who owns or is associated with that book.</p>"},{"location":"chapter11/#pydantic-relationships","title":"Pydantic Relationships","text":"<p>Let us modify the user schemas to make sure we return a user as well as the books that are associated with their account. To begin, we shall go to <code>src/auth/schemas.py</code> and add the following.</p> schema for listing user submitted books<pre><code> import uuid\nfrom datetime import datetime\nfrom typing import List\n\nfrom pydantic import BaseModel, Field\n\nfrom src.books.schemas import Book\nfrom src.reviews.schemas import ReviewModel\n\n... # rest of the code\n\nclass UserModel(BaseModel):\n    uid: uuid.UUID\n    username: str\n    email: str\n    first_name: str\n    last_name: str\n    is_verified: bool\n    password_hash: str = Field(exclude=True)\n    created_at: datetime\n    update_at: datetime\n\n\nclass UserBooksModel(UserModel):\n    books: List[Book]\n\n... # rest of the file\n</code></pre> <p>In the above code, we have created a subclass of <code>UserModel</code> called <code>UserBooksModel</code> that inherits all its attributes. The <code>UserBooksModel</code> uses the <code>typing.List</code> type to return a list of <code>Book</code> objects that a user has submitted. Now, let's use this schema to return the currently logged-in user along with all the books associated with them. Let's go back to <code>src/auth/routes.py</code>.</p> return user and related books<pre><code>... # rest of imports\nfrom .dependencies import (AccessTokenBearer, RefreshTokenBearer, RoleChecker,\n                           get_current_user)\nfrom .schemas import UserBooksModel, UserCreateModel, UserLoginModel, UserModel\n\n... # rest of the routes\n\n@auth_router.get(\"/me\", response_model=UserBooksModel)\nasync def get_current_user(\n    user=Depends(get_current_user), _: bool = Depends(role_checker)\n):\n    return user\n</code></pre> <p>What we have done is add the <code>response_model</code> argument to the HTTP method of the path to get the current user. This is provided the value of the <code>UserBooksModel</code>, meaning that the <code>user</code> will be returned with a list of books they have submitted. To test this, let us use our API client, Insomnia.</p> <p></p> <p>With that, we shall notice that we can get the currently logged in user as well as the books that they added.</p>"},{"location":"chapter11/#asssociating-books-with-reviews","title":"Asssociating Books With Reviews","text":"<p>Let us now create the relationship between books, users, and reviews. In our application, we want users to have the ability to add reviews to books. These reviews are just comments about what they feel about the book that has been submitted. The diagram below shows the relationship in detail.</p> <p></p> <p>From the diagram above, we notice that we are going to have a more complex one-to-many relationship connecting three tables: users, reviews, and books. A user can make many reviews (forming a one-to-many relationship), and a book can also have many reviews. This means that we shall a one to many relationship on both the user's side and also the books side.</p> <p>To begin, we shall create a <code>Review</code> model to hold reviews that users will make on books. To do that, we are going to begin by making one really major change. We shall move all our models inside the <code>src/db</code> directory. Our new folder structure will look like this.</p> <pre><code>\u251c\u2500\u2500 alembic.ini\n\u251c\u2500\u2500 migrations\n\u2502   \u251c\u2500\u2500 env.py\n\u2502   \u251c\u2500\u2500 README\n\u2502   \u251c\u2500\u2500 script.py.mako\n\u2502   \u2514\u2500\u2500 versions\n\u2502       \u251c\u2500\u2500 # your alembic version files\n\u251c\u2500\u2500 requirements.txt\n\u2514\u2500\u2500 src/\n|-- \u251c\u2500\u2500 auth\n|-- \u2502   \u251c\u2500\u2500 dependencies.py\n|-- \u2502   \u251c\u2500\u2500 __init__.py\n|-- \u2502   \u251c\u2500\u2500 models.py\n|-- \u2502   \u251c\u2500\u2500 routes.py\n|-- \u2502   \u251c\u2500\u2500 schemas.py\n|-- \u2502   \u251c\u2500\u2500 service.py\n|-- \u2502   \u2514\u2500\u2500 utils.py\n|-- \u251c\u2500\u2500 books\n|-- \u2502   \u251c\u2500\u2500 __init__.py\n|-- \u2502   \u251c\u2500\u2500 models.py\n|-- \u2502   \u251c\u2500\u2500 routes.py\n|-- \u2502   \u251c\u2500\u2500 schemas.py\n|-- \u2502   \u2514\u2500\u2500 service.py\n|-- \u251c\u2500\u2500 config.py\n`-- \u251c\u2500\u2500 db/\n    |-- \u251c\u2500\u2500 __init__.py\n    |-- \u251c\u2500\u2500 main.py\n    `-- \u251c\u2500\u2500 models.py\n</code></pre> <p>As you will see, we have created a <code>models.py</code> file where all the database models are going to reside. The reason behind this is that as we create these relationships, the relationship attributes shall require us to import database models from all places they are within our application. This will increase the chances of errors due to circular imports.</p> <p>This also means we shall get rid of the <code>models.py</code> files we have been creating in the different directories we have so far.</p> src/models.py<pre><code>import uuid\nfrom datetime import date, datetime\nfrom typing import List, Optional\n\nimport sqlalchemy.dialects.postgresql as pg\nfrom sqlmodel import Column, Field, Relationship, SQLModel\n\n\nclass User(SQLModel, table=True):\n    __tablename__ = \"users\"\n    uid: uuid.UUID = Field(\n        sa_column=Column(pg.UUID, nullable=False, primary_key=True, default=uuid.uuid4)\n    )\n    username: str\n    email: str\n    first_name: str\n    last_name: str\n    role: str = Field(\n        sa_column=Column(pg.VARCHAR, nullable=False, server_default=\"user\")\n    )\n    is_verified: bool = Field(default=False)\n    password_hash: str = Field(\n        sa_column=Column(pg.VARCHAR, nullable=False), exclude=True\n    )\n    created_at: datetime = Field(sa_column=Column(pg.TIMESTAMP, default=datetime.now))\n    update_at: datetime = Field(sa_column=Column(pg.TIMESTAMP, default=datetime.now))\n    books: List[\"Book\"] = Relationship(\n        back_populates=\"user\", sa_relationship_kwargs={\"lazy\": \"selectin\"}\n    )\n    reviews: List[\"Review\"] = Relationship(\n        back_populates=\"user\", sa_relationship_kwargs={\"lazy\": \"selectin\"}\n    )\n\n    def __repr__(self):\n        return f\"&lt;User {self.username}&gt;\"\n\nclass Book(SQLModel, table=True):\n    __tablename__ = \"books\"\n    uid: uuid.UUID = Field(\n        sa_column=Column(pg.UUID, nullable=False, primary_key=True, default=uuid.uuid4)\n    )\n    title: str\n    author: str\n    publisher: str\n    published_date: date\n    page_count: int\n    language: str\n    user_uid: Optional[uuid.UUID] = Field(default=None, foreign_key=\"users.uid\")\n    created_at: datetime = Field(sa_column=Column(pg.TIMESTAMP, default=datetime.now))\n    update_at: datetime = Field(sa_column=Column(pg.TIMESTAMP, default=datetime.now))\n    user: Optional[User] = Relationship(back_populates=\"books\")\n    reviews: List[\"Review\"] = Relationship(\n        back_populates=\"book\", sa_relationship_kwargs={\"lazy\": \"selectin\"}\n    )\n\n    def __repr__(self):\n        return f\"&lt;Book {self.title}&gt;\"\n\n\nclass Review(SQLModel, table=True):\n    __tablename__ = \"reviews\"\n    uid: uuid.UUID = Field(\n        sa_column=Column(pg.UUID, nullable=False, primary_key=True, default=uuid.uuid4)\n    )\n    rating: int = Field(lte=5)\n    review_text: str = Field(sa_column=Column(pg.VARCHAR, nullable=False))\n    user_uid: Optional[uuid.UUID] = Field(default=None, foreign_key=\"users.uid\")\n    book_uid: Optional[uuid.UUID] = Field(default=None, foreign_key=\"books.uid\")\n    created_at: datetime = Field(sa_column=Column(pg.TIMESTAMP, default=datetime.now))\n    update_at: datetime = Field(sa_column=Column(pg.TIMESTAMP, default=datetime.now))\n    user: Optional[User] = Relationship(back_populates=\"reviews\")\n    book: Optional[Book] = Relationship(back_populates=\"reviews\")\n\n    def __repr__(self):\n        return f\"&lt;Review for book {self.book_uid} by user {self.user_uid}&gt;\"\n</code></pre> <p>Let us first look at the <code>Review</code> model. The <code>Review</code> model has four fields;</p> <ul> <li><code>rating</code>: An integer rating ( this should be less than or equal to 5)</li> <li><code>review_text</code>: The text for the review.</li> <li><code>user_uid</code>: The ID of the user who made the review</li> <li><code>book_uid</code>: The ID of the user who submitted the review</li> </ul> <p>We have also added relationship attributes;</p> <ul> <li><code>user</code>: To relate to the user who submitted a review.</li> <li><code>book</code>: To relate to the book on which a review has been made.</li> </ul> <p>Also on the <code>User</code> model is the <code>reviews</code> relationship attribute that will be responsible for getting all reviews that have been submitted by a user.</p> <p>Note</p> <p>At this point, you need to have disabled the lifespan event we created at in chapter 5. This is because we shall be using Alembic to make changes to our database, removing the lifespan event<pre><code>app = FastAPI(\n    title=\"Bookly\",\n    description=\"A REST API for a book review web service\",\n    version=version,\n    lifespan=lifespan # remove this\n)   \n</code></pre></p> <p>So let us now make the Alembic revision and make the reviews table in the database.</p> creating the reviews revision<pre><code>$ alembic revision --autogenerate -m \"add reviews table\"\n</code></pre> <p>Finally, let us apply this to the database.</p> applying the change to the database<pre><code>$ alembic upgrade\n</code></pre> <p>With this change, the database table for reviews has been created and has the folowing structure.</p> reviews table structure<pre><code>books=# \\d reviews\n                           Table \"public.reviews\"\n   Column    |            Type             | Collation | Nullable | Default\n-------------+-----------------------------+-----------+----------+---------\n uid         | uuid                        |           | not null |\n rating      | integer                     |           | not null |\n review_text | character varying           |           | not null |\n user_uid    | uuid                        |           |          |\n book_uid    | uuid                        |           |          |\n created_at  | timestamp without time zone |           |          |\n update_at   | timestamp without time zone |           |          |\nIndexes:\n    \"reviews_pkey\" PRIMARY KEY, btree (uid)\nForeign-key constraints:\n    \"reviews_book_uid_fkey\" FOREIGN KEY (book_uid) REFERENCES books(uid)\n    \"reviews_user_uid_fkey\" FOREIGN KEY (user_uid) REFERENCES users(uid)\n</code></pre>"},{"location":"chapter11/#reviews-crud","title":"Reviews CRUD","text":"<p>Now that we have created the reviews table, Let us go ahead to create all review API endpoints, Let us start by creating a <code>reviews</code> directory inside <code>src</code>. Then add <code>service.py</code>,<code>routes.py</code> and <code>schemas.py</code>.</p> src/reviews/service.py<pre><code>import logging\n\nfrom fastapi import status\nfrom fastapi.exceptions import HTTPException\nfrom sqlmodel import desc, select\nfrom sqlmodel.ext.asyncio.session import AsyncSession\n\nfrom src.auth.service import UserService\nfrom src.books.service import BookService\nfrom src.db.models import Review\n\nfrom .schemas import ReviewCreateModel\n\nbook_service = BookService()\nuser_service = UserService()\n\n\nclass ReviewService:\n    async def add_review_to_book(\n        self,\n        user_email: str,\n        book_uid: str,\n        review_data: ReviewCreateModel,\n        session: AsyncSession,\n    ):\n        try:\n            book = await book_service.get_book(book_uid=book_uid, session=session)\n            user = await user_service.get_user_by_email(\n                email=user_email, session=session\n            )\n            review_data_dict = review_data.model_dump()\n            new_review = Review(**review_data_dict)\n\n            if not book:\n                raise HTTPException(\n                    detail=\"Book not found\", status_code=status.HTTP_404_NOT_FOUND\n                )\n\n            if not user:\n                raise HTTPException(\n                    detail=\"Book not found\", status_code=status.HTTP_404_NOT_FOUND\n                )\n\n            new_review.user = user\n\n            new_review.book = book\n\n            session.add(new_review)\n\n            await session.commit()\n\n            return new_review\n\n        except Exception as e:\n            logging.exception(e)\n            raise HTTPException(\n                detail=\"Oops... somethig went wrong!\",\n                status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,\n            )\n\n    async def get_review(self, review_uid: str, session: AsyncSession):\n        statement = select(Review).where(Review.uid == review_uid)\n\n        result = await session.exec(statement)\n\n        return result.first()\n\n    async def get_all_reviews(self, session: AsyncSession):\n        statement = select(Review).order_by(desc(Review.created_at))\n\n        result = await session.exec(statement)\n\n        return result.all()\n\n    async def delete_review_to_from_book(\n        self, review_uid: str, user_email: str, session: AsyncSession\n    ):\n        user = await user_service.get_user_by_email(user_email, session)\n\n        review = await self.get_review(review_uid, session)\n\n        if not review or (review.user is not user):\n            raise HTTPException(\n                detail=\"Cannot delete this review\",\n                status_code=status.HTTP_403_FORBIDDEN,\n            )\n\n        session.add(review)\n\n        await session.commit()\n</code></pre> <p>This code defines a <code>ReviewService</code> class with methods for managing book reviews using FastAPI and SQLModel with asynchronous operations. The <code>add_review_to_book</code> method allows a user to add a review to a book, checking if the book and user exist before creating the review and committing it to the database. If the book or user is not found, or if any other exception occurs, appropriate HTTP exceptions are raised. </p> <p>The <code>get_review</code> method retrieves a specific review by its UID, and the <code>get_all_reviews</code> method retrieves all reviews, ordered by creation date in descending order. The <code>delete_review_to_from_book</code> method allows a user to delete their review, ensuring that only the user who created the review can delete it. If the review is not found or the user is not authorized, an HTTP exception is raised. Logging is used to capture exceptions that occur during these operations.</p> <p>src/reviews/schemas.py<pre><code>import uuid\nfrom datetime import datetime\nfrom typing import Optional\n\nfrom pydantic import BaseModel, Field\n\n\nclass ReviewModel(BaseModel):\n    uid: uuid.UUID\n    rating: int = Field(lte=5)\n    review_text: str\n    user_uid: Optional[uuid.UUID]\n    book_uid: Optional[uuid.UUID]\n    created_at: datetime\n    update_at: datetime\n\n\nclass ReviewCreateModel(BaseModel):\n    rating: int = Field(lt=5)\n    review_text: str\n</code></pre> Inside <code>schemas.py</code>, we define two Pydantic models, <code>ReviewModel</code> and <code>ReviewCreateModel</code>, to handle book reviews. The <code>ReviewModel</code> includes fields for a unique identifier (<code>uid</code>), an integer rating with a maximum value of 5 (<code>rating</code>), the text of the review (<code>review_text</code>), optional unique identifiers for the user (<code>user_uid</code>) and the book (<code>book_uid</code>), and timestamps for when the review was created and last updated (<code>created_at</code> and <code>update_at</code>). </p> <p>The <code>ReviewCreateModel</code> is a simplified version for creating new reviews, containing only the <code>rating</code> and <code>review_text</code> fields. This model ensures that data for creating and managing reviews is properly validated and structured.</p> src/reviews/routes.py<pre><code>from fastapi import APIRouter, Depends, status\nfrom sqlmodel.ext.asyncio.session import AsyncSession\n\nfrom src.auth.dependencies import RoleChecker, get_current_user\nfrom src.db.main import get_session\nfrom src.db.models import User\n\nfrom .schemas import ReviewCreateModel\nfrom .service import ReviewService\n\nreview_service = ReviewService()\nreview_router = APIRouter()\nadmin_role_checker = Depends(RoleChecker([\"admin\"]))\nuser_role_checker = Depends(RoleChecker([\"user\", \"admin\"]))\n\n\n@review_router.get(\"/\", dependencies=[admin_role_checker])\nasync def get_all_reviews(session: AsyncSession = Depends(get_session)):\n    books = await review_service.get_all_reviews(session)\n\n    return books\n\n\n@review_router.get(\"/{review_uid}\", dependencies=[user_role_checker])\nasync def get_review(review_uid: str, session: AsyncSession = Depends(get_session)):\n    book = await review_service.get_review(review_uid, session)\n\n    if not book:\n        raise\n\n\n@review_router.post(\"/book/{book_uid}\", dependencies=[user_role_checker])\nasync def add_review_to_books(\n    book_uid: str,\n    review_data: ReviewCreateModel,\n    current_user: User = Depends(get_current_user),\n    session: AsyncSession = Depends(get_session),\n):\n    new_review = await review_service.add_review_to_book(\n        user_email=current_user.email,\n        review_data=review_data,\n        book_uid=book_uid,\n        session=session,\n    )\n\n    return new_review\n\n\n@review_router.delete(\n    \"/{review_uid}\",\n    dependencies=[user_role_checker],\n    status_code=status.HTTP_204_NO_CONTENT,\n)\nasync def delete_review(\n    review_uid: str,\n    current_user: User = Depends(get_current_user),\n    session: AsyncSession = Depends(get_session),\n):\n    await review_service.delete_review_to_from_book(\n        review_uid=review_uid, user_email=current_user.email, session=session\n    )\n\n    return None\n</code></pre> <p>Inside <code>src/reviews/routes.py</code> we define defines API routes for managing book reviews. An <code>APIRouter</code> named <code>review_router</code> is created, along with dependencies for role checkers that ensure only users with the appropriate roles can access specific endpoints. The <code>ReviewService</code> class is instantiated to handle the core review-related operations.</p> <ul> <li> <p>The <code>get_all_reviews</code> endpoint is restricted to admin users and retrieves all reviews from the database using an asynchronous session. This ensures that only administrators can access the complete list of reviews, maintaining control over the data.</p> </li> <li> <p>The <code>get_review</code> endpoint allows both users and administrators to retrieve a specific review by its unique identifier (UID). This endpoint checks the review's existence and is designed to raise an appropriate exception if the review is not found, thus handling potential errors gracefully.</p> </li> <li> <p>The <code>add_review_to_books</code> endpoint enables users to add a review to a book. It requires the book's UID, review data, and the current user's information. The <code>ReviewService</code> handles the actual addition of the review, ensuring that the review is associated with the correct user and book, and then commits the changes to the database.</p> </li> <li> <p>The <code>delete_review</code> endpoint allows users to delete their reviews, verifying that the user attempting the deletion is the one who created the review. If the operation is successful, the endpoint returns a 204 No Content status code, indicating that the review has been deleted without any issues. This setup ensures secure and efficient management of reviews, leveraging dependency injection for role checking, authentication, and database session handling.</p> </li> </ul> <p>We need to then include this router to our app. Let us proceed to do that in <code>src/__init__.py</code>.  registering review routes<pre><code>from fastapi import FastAPI, status\nfrom fastapi.responses import JSONResponse\nfrom src.auth.routes import auth_router\nfrom src.books.routes import book_router\nfrom src.reviews.routes import review_router\n\n\nversion = \"v1\"\n\napp = FastAPI(\n    title=\"Bookly\",\n    description=\"A REST API for a book review web service\",\n    version=version,\n)\n\n\n\napp.include_router(book_router, prefix=f\"/api/{version}/books\", tags=[\"books\"])\napp.include_router(auth_router, prefix=f\"/api/{version}/auth\", tags=[\"auth\"])\napp.include_router(review_router, prefix=f\"/api/{version}/reviews\", tags=[\"reviews\"]) #add this\n</code></pre></p>"},{"location":"chapter11/#testing-review-api-routes","title":"Testing review API Routes","text":"<p>Now that we have built the review API routes, let us test them.</p> <ol> <li> <p>Adding a book review:  </p> </li> <li> <p>Get book details with reviews:  </p> </li> <li> <p>Get user details with reviews:  </p> </li> <li> <p>Get all reviews:  </p> </li> </ol>"},{"location":"chapter11/#associate-books-with-tags","title":"Associate Books With Tags","text":"<p>All we have been looking at is creating one to many relationships and now let us look at a many to many relationship that we can set up. This is the relationship between books and tags. We want  to use tags to group all books within many categories, we can also be able to search related books, basing on their tags. To begin, let us look at the structure that book tags will have.</p> <p></p> <p>From the structure, it's evident that alongside our existing books table, we've introduced two additional tables: tags and book_tags. We've established a many-to-many relationship between books and tags, facilitated by the book_tags table. This table serves as an association table, linking instances from books to tags. </p> <p>The <code>book_tags</code> table functions as an intermediary or association table connecting the <code>books</code> and <code>tags</code> tables in a many-to-many relationship. It consists of two primary columns: <code>book_id</code>, which serves as a foreign key referencing the <code>uid</code> column in the <code>books</code> table to identify the book associated with a tag, and <code>tag_id</code>, a foreign key referencing the uid column in the tags table to identify the tag associated with a book. </p> <p>To create the database structure, we we should introduce the <code>Tag</code> and <code>BookTag</code> models. To do that, let us go to <code>src/db/models.py</code> and add the following code.</p> the book tag models<pre><code>... # the rest of the file\n\nclass BookTag(SQLModel, table=True):\n    book_id: uuid.UUID = Field(default=None, foreign_key=\"books.uid\", primary_key=True)\n    tag_id: uuid.UUID = Field(default=None, foreign_key=\"tags.uid\", primary_key=True)\n\n\nclass Tag(SQLModel, table=True):\n    __tablename__ = \"tags\"\n    uid: uuid.UUID = Field(\n        sa_column=Column(pg.UUID, nullable=False, primary_key=True, default=uuid.uuid4)\n    )\n    name: str = Field(sa_column=Column(pg.VARCHAR, nullable=False))\n    created_at: datetime = Field(sa_column=Column(pg.TIMESTAMP, default=datetime.now))\n    books: List[\"Book\"] = Relationship(\n        link_model=BookTag,\n        back_populates=\"tags\",\n        sa_relationship_kwargs={\"lazy\": \"selectin\"},\n    )\n\n    def __repr__(self) -&gt; str:\n        return f\"&lt;Tag {self.name}&gt;\"\n\n... # the rest of the file\n</code></pre> <p>The code defines two SQLModel classes designed for the relationships between books and tags in a database-driven application. First, the <code>BookTag</code> class serves as an intermediary model representing the association between books and tags. It inherits from <code>SQLModel</code> and includes two primary fields: <code>book_id</code> and <code>tag_id</code>. These fields are UUID types and act as foreign keys referencing the <code>uid</code> columns in the <code>books</code> and <code>tags</code> tables, respectively. With <code>primary_key=True</code>, each combination of <code>book_id</code> and <code>tag_id</code> uniquely identifies an association. This setup establishes a many-to-many relationship, allowing multiple tags to be linked to multiple books efficiently.</p> <p>Next, the <code>Tag</code> class represents a tag entity in the database. It inherits from <code>SQLModel</code> and is associated with the <code>tags</code> table. The class includes essential fields such as <code>uid</code> for the tag's unique identifier, <code>name</code> to store the tag's name, and <code>created_at</code> to timestamp when the tag was created. The <code>books</code> attribute is a list of <code>Book</code> instances, defined as a relationship using <code>Relationship</code>. It specifies <code>link_model=BookTag</code>, indicating that the association between <code>Tag</code> and <code>Book</code> instances is managed through the <code>BookTag</code> class. </p> <p>The <code>back_populates=\"tags\"</code> attribute ensures bidirectional navigation, allowing efficient access to related <code>Book</code> instances associated with each <code>Tag</code>. Additionally, <code>sa_relationship_kwargs={\"lazy\": \"selectin\"}</code> configures lazy loading, optimizing performance by retrieving related <code>Book</code> instances selectively when accessing <code>Tag</code> objects.</p> <p>With the tables set up, let us now go ahead to add these changes to the database using Alembic. To begin, we shall begin by creating the revisions with; alembic revision for adding the tag tables<pre><code>$ alembic revision --autogenerate -m \"add book tags table\"\n</code></pre> Apply the revision with; applying the alembic revision<pre><code>$ alembic upgrade\n</code></pre></p> <p>The database table for tags will look like this, </p> tags table structure<pre><code>books=# \\d tags\n                            Table \"public.tags\"\n   Column   |            Type             | Collation | Nullable | Default \n------------+-----------------------------+-----------+----------+---------\n uid        | uuid                        |           | not null | \n name       | character varying           |           | not null | \n created_at | timestamp without time zone |           |          | \nIndexes:\n    \"tags_pkey\" PRIMARY KEY, btree (uid)\nReferenced by:\n    TABLE \"booktag\" CONSTRAINT \"booktag_tag_id_fkey\" FOREIGN KEY (tag_id) REFERENCES tags(uid)\n</code></pre> <p>The link table for tags and books will look like the following.</p> book tags table structure<pre><code>books=# \\d booktag\n             Table \"public.booktag\"\n Column  | Type | Collation | Nullable | Default \n---------+------+-----------+----------+---------\n book_id | uuid |           | not null | \n tag_id  | uuid |           | not null | \nIndexes:\n    \"booktag_pkey\" PRIMARY KEY, btree (book_id, tag_id)\nForeign-key constraints:\n    \"booktag_book_id_fkey\" FOREIGN KEY (book_id) REFERENCES books(uid)\n    \"booktag_tag_id_fkey\" FOREIGN KEY (tag_id) REFERENCES tags(uid)\n</code></pre>"},{"location":"chapter11/#tags-crud","title":"Tags CRUD","text":"<p>Now that we have the tables in our database. Let us now use the models to perform CRUD on the tags. Let us start by creating the <code>tags</code> directory and add the following files to it. schemas.py<pre><code>import uuid\nfrom datetime import datetime\nfrom typing import List\n\nfrom pydantic import BaseModel\n\n\nclass TagModel(BaseModel):\n    uid: uuid.UUID\n    name: str\n    created_at: datetime\n\n\nclass TagCreateModel(BaseModel):\n    name: str\n\n\nclass TagAddModel(BaseModel):\n    tags: List[TagCreateModel]\n</code></pre></p> <p>Inside <code>src/tags/schemas.py</code>, are three Pydantic models that will be used to serialize and deserialize objects in our application. </p> <ul> <li> <p><code>TagModel</code>: Represents a tag with a UUID (uid), name (name), and creation timestamp (created_at). Used for reading and returning tag data from the API.</p> </li> <li> <p><code>TagCreateModel</code>: Contains a single field (name) for creating new tags, ensuring the necessary data is provided.</p> </li> <li> <p><code>TagAddModel</code>: Contains a list of TagCreateModel instances (tags), used for adding multiple tags to a book.</p> </li> </ul> <p>service.py<pre><code>from fastapi import status\nfrom fastapi.exceptions import HTTPException\nfrom sqlmodel import desc, select\nfrom sqlmodel.ext.asyncio.session import AsyncSession\n\nfrom src.books.service import BookService\nfrom src.db.models import Tag\n\nfrom .schemas import TagAddModel, TagCreateModel\n\nbook_service = BookService()\n\n\nserver_error = HTTPException(\n    status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail=\"Something went wrong\"\n)\n\n\nclass TagService:\n\n    async def get_tags(self, session: AsyncSession):\n        \"\"\"Get all tags\"\"\"\n\n        statement = select(Tag).order_by(desc(Tag.created_at))\n\n        result = await session.exec(statement)\n\n        return result.all()\n\n    async def add_tags_to_book(\n        self, book_uid: str, tag_data: TagAddModel, session: AsyncSession\n    ):\n        \"\"\"Add tags to a book\"\"\"\n\n        book = await book_service.get_book(book_uid=book_uid, session=session)\n\n        if not book:\n            raise HTTPException(status_code=404, detail=\"Book not found\")\n\n        for tag_item in tag_data.tags:\n            result = await session.exec(\n                select(Tag).where(Tag.name == tag_item.name)\n            )\n\n            tag = result.one_or_none()\n            if not tag:\n                tag = Tag(name=tag_item.name)\n\n            book.tags.append(tag)\n        session.add(book)\n        await session.commit()\n        await session.refresh(book)\n        return book\n\n\n\n    async def get_tag_by_uid(self, tag_uid: str, session: AsyncSession):\n        \"\"\"Get tag by uid\"\"\"\n\n        statement = select(Tag).where(Tag.uid == tag_uid)\n\n        result = await session.exec(statement)\n\n        return result.first()\n\n    async def add_tag(self, tag_data: TagCreateModel, session: AsyncSession):\n        \"\"\"Create a tag\"\"\"\n\n        statement = select(Tag).where(Tag.name == tag_data.name)\n\n        result = await session.exec(statement)\n\n        tag = result.first()\n\n        if tag:\n            raise HTTPException(\n                status_code=status.HTTP_403_FORBIDDEN, detail=\"Tag exists\"\n            )\n\n        new_tag = Tag(name=tag_data.name)\n\n        session.add(new_tag)\n\n        await session.commit()\n\n        return new_tag\n\n    async def update_tag(\n        self, tag_uid, tag_update_data: TagCreateModel, session: AsyncSession\n    ):\n        \"\"\"Update a tag\"\"\"\n\n        tag = await self.get_tag_by_uid(tag_uid, session)\n\n        update_data_dict = tag_update_data.model_dump()\n\n        for k, v in update_data_dict.items():\n            setattr(tag, k, v)\n\n            await session.commit()\n\n            await session.refresh(tag)\n\n        return tag\n\n\n    async def delete_tag(self, tag_uid: str, session: AsyncSession):\n        \"\"\"Delete a tag\"\"\"\n\n        tag = self.get_tag_by_uid(tag_uid,session)\n\n        if not tag:\n            raise HTTPException(\n                status_code=status.HTTP_404_NOT_FOUND, detail=\"Tag does not exist\"\n            )\n\n        await session.delete(tag)\n\n        await session.commit()\n</code></pre> In <code>src/tags/service.py</code>, we have created the <code>TagService</code> class which will be used to manage tags. It imports necessary modules, including <code>status</code> from FastAPI for HTTP status codes, <code>HTTPException</code> for handling exceptions, and <code>desc</code>, <code>select</code> from <code>sqlmodel</code> for database queries using SQL statements in an asynchronous session. Additionally, it relies on <code>AsyncSession</code> from <code>sqlmodel.ext.asyncio.session</code> for asynchronous database interactions.</p> <p>Within the class, an instance of <code>BookService</code> is initialized to facilitate operations related to books. Error handling is streamlined with a predefined <code>server_error</code> <code>HTTPException</code> instance set for <code>500 Internal Server Error</code>.</p> <p>The class defines several asynchronous methods to perform CRUD operations on tags:</p> <ul> <li><code>get_tags</code>: Retrieves all tags ordered by their creation date (<code>created_at</code>) from the database using a descending order query </li> </ul> getting all tags<pre><code>select(Tag).order_by(desc(Tag.created_at))\n</code></pre> <ul> <li> <p><code>add_tags_to_book</code>: Adds tags to a specific book identified by <code>book_uid</code>. It verifies the existence of the book with <code>book_service.get_book</code>, raising an <code>HTTPException</code> if the book isn't found. For each tag in <code>tag_data.tags</code>, it checks if the tag already exists in the database and creates a new tag if not. Tags are appended to the book's <code>tags</code> list and committed to the database.</p> </li> <li> <p><code>get_tag_by_uid</code>: Retrieves a tag by its unique identifier (<code>tag_uid</code>) using a <code>SELECT</code> query with a <code>WHERE</code> clause.</p> </li> </ul> retrieve a single tag<pre><code>select(Tag).where(Tag.uid == tag_uid)\n</code></pre> <ul> <li><code>add_tag</code>: Creates a new tag based on <code>tag_data</code>. It checks if a tag with the same name already exists in the database using a <code>SELECT</code> query . If the tag doesn't exist, a new <code>Tag</code> instance is created and added to the database.</li> </ul> retrieving a tag using its name<pre><code>select(Tag).where(Tag.name == tag_data.name)\n</code></pre> <ul> <li> <p><code>update_tag</code>: Updates an existing tag identified by <code>tag_uid</code> with new data (<code>tag_update_data</code>). It retrieves the tag, raises a <code>HTTPException</code> with status <code>404</code> if not found, updates its attributes, and commits the changes.</p> </li> <li> <p><code>delete_tag</code>: Deletes a tag identified by <code>tag_uid</code> from the database. It retrieves the tag, raises an <code>HTTPException</code> if not found, deletes it from the session, and commits the deletion.</p> </li> </ul> routes.py<pre><code>from typing import List\n\nfrom fastapi import APIRouter, Depends, status\nfrom sqlmodel.ext.asyncio.session import AsyncSession\n\n\nfrom src.auth.dependencies import RoleChecker\nfrom src.books.schemas import Book\nfrom src.db.main import get_session\n\nfrom .schemas import TagAddModel, TagCreateModel, TagModel\nfrom .service import TagService\n\ntags_router = APIRouter()\ntag_service = TagService()\nuser_role_checker = Depends(RoleChecker([\"user\", \"admin\"]))\n\n\n@tags_router.get(\"/\", response_model=List[TagModel], dependencies=[user_role_checker])\nasync def get_all_tags(session: AsyncSession = Depends(get_session)):\n    tags = await tag_service.get_tags(session)\n\n    return tags\n\n\n@tags_router.post(\n    \"/\",\n    response_model=TagModel,\n    status_code=status.HTTP_201_CREATED,\n    dependencies=[user_role_checker],\n)\nasync def add_tag(\n    tag_data: TagCreateModel, session: AsyncSession = Depends(get_session)\n) -&gt; TagModel:\n\n    tag_added = await tag_service.add_tag(tag_data=tag_data, session=session)\n\n    return tag_added\n\n\n@tags_router.post(\n    \"/book/{book_uid}/tags\", response_model=Book, dependencies=[user_role_checker]\n)\nasync def add_tags_to_book(\n    book_uid: str, tag_data: TagCreateModel, session: AsyncSession = Depends(get_session)\n) -&gt; Book:\n\n    book_with_tag = await tag_service.add_tags_to_book(\n        book_uid=book_uid, tag_data=tag_data, session=session\n    )\n\n    return book_with_tag\n\n\n@tags_router.put(\n    \"/{tag_uid}\", response_model=TagModel, dependencies=[user_role_checker]\n)\nasync def update_tag(\n    tag_uid: str,\n    tag_update_data: TagCreateModel,\n    session: AsyncSession = Depends(get_session),\n) -&gt; TagModel:\n    updated_tag = await tag_service.update_tag(tag_uid, tag_update_data, session)\n\n    return updated_tag\n\n\n@tags_router.delete(\n    \"/{tag_uid}\",\n    status_code=status.HTTP_204_NO_CONTENT,\n    dependencies=[user_role_checker],\n)\nasync def delete_tag(\n    tag_uid: str, session: AsyncSession = Depends(get_session)\n) -&gt; None:\n    updated_tag = await tag_service.delete_tag(tag_uid, session)\n\n    return updated_tag\n</code></pre> <p>The <code>tags_router</code> in this code defines several endpoints for managing tags. This router relies on <code>TagService</code> to perform various CRUD operations and utilizes <code>AsyncSession</code> for asynchronous database access. The endpoints handle requests for retrieving all tags, adding new tags, associating tags with books, updating tags, and deleting tags.</p> <p>The <code>get_all_tags</code> endpoint fetches all tags from the database, returning a list of tags in the response model <code>TagModel</code>. It uses <code>Depends(get_session)</code> to inject the database session and calls the <code>get_tags</code> method from <code>TagService</code>. The <code>add_tag</code> endpoint creates a new tag, accepting <code>TagCreateModel</code> as input data. The <code>tag_service.add_tag</code> method is called to add the tag to the database, and the newly created tag is returned with a <code>201 Created</code> status.</p> <p>For associating tags with books, the <code>add_tags_to_book</code> endpoint takes a book UID and tag data (<code>TagAddModel</code>), adds the tags to the specified book using the <code>add_tags_to_book</code> method of <code>TagService</code>, and returns the updated book information. The <code>update_tag</code> endpoint updates an existing tag identified by its UID with new data provided in <code>TagCreateModel</code>. It calls the <code>update_tag</code> method from <code>TagService</code> and returns the updated tag.</p> <p>Lastly, the <code>delete_tag</code> endpoint deletes a tag specified by its UID. It calls the <code>delete_tag</code> method from <code>TagService</code>, which removes the tag from the database and returns a <code>204 No Content</code> status to indicate successful deletion. </p> <p>Let us not forget to add the <code>tag_router</code> to our application by going inside <code>src/__init__.py</code>; <pre><code>from fastapi import FastAPI\n\nfrom src.auth.routes import auth_router\nfrom src.books.routes import book_router\nfrom src.reviews.routes import review_router\nfrom src.tags.routes import tags_router # import this\n\nversion = \"v1\"\n\napp = FastAPI(\n    title=\"Bookly\",\n    description=\"A REST API for a book review web service\",\n    version=version,\n)\n\napp.include_router(book_router, prefix=f\"/api/{version}/books\", tags=[\"books\"])\napp.include_router(auth_router, prefix=f\"/api/{version}/auth\", tags=[\"auth\"])\napp.include_router(review_router, prefix=f\"/api/{version}/reviews\", tags=[\"reviews\"])\napp.include_router(tags_router, prefix=f\"/api/{version}/tags\", tags=[\"tags\"]) #add this\n</code></pre></p>"},{"location":"chapter11/#testing-the-tags-api-routes","title":"Testing the tags API Routes","text":"<p>Now that our reviews and tags relationships have been set up, let us go ahead and test the different API endpoints we have so far built.</p> <ol> <li> <p>Create tag </p> </li> <li> <p>Create tag that exists </p> </li> <li> <p>Get all tags </p> </li> <li> <p>Add tags to a book </p> </li> <li> <p>Update a tag </p> </li> <li> <p>Delete a tag </p> </li> <li> <p>Getting book details with tag </p> </li> </ol> <p>With changes in place, our current folder structure looks like. <pre><code>.\n|-- \u251c\u2500\u2500 alembic.ini\n|-- \u251c\u2500\u2500 migrations\n|-- \u251c\u2500\u2500 README.md\n|-- \u251c\u2500\u2500 requirements.txt\n`-- \u2514\u2500\u2500 src/\n    |-- \u251c\u2500\u2500 auth\n    |-- \u2502   \u251c\u2500\u2500 dependencies.py\n    |-- \u2502   \u251c\u2500\u2500 __init__.py\n    |-- \u2502   \u251c\u2500\u2500 routes.py\n    |-- \u2502   \u251c\u2500\u2500 schemas.py\n    |-- \u2502   \u251c\u2500\u2500 service.py\n    |-- \u2502   \u2514\u2500\u2500 utils.py\n    |-- \u251c\u2500\u2500 books\n    |-- \u2502   \u251c\u2500\u2500 __init__.py\n    |-- \u2502   \u251c\u2500\u2500 models.py\n    |-- \u2502   \u251c\u2500\u2500 routes.py\n    |-- \u2502   \u251c\u2500\u2500 schemas.py\n    |-- \u2502   \u2514\u2500\u2500 service.py\n    |-- \u251c\u2500\u2500 config.py\n    |-- \u251c\u2500\u2500 db\n    |-- \u2502   \u251c\u2500\u2500 __init__.py\n    |-- \u2502   \u251c\u2500\u2500 main.py\n    |-- \u2502   \u251c\u2500\u2500 models.py\n    |-- \u2502   \u2514\u2500\u2500 redis.py\n    |-- \u251c\u2500\u2500 __init__.py\n    |-- \u251c\u2500\u2500 reviews\n    |-- \u2502   \u251c\u2500\u2500 __init__.py\n    |-- \u2502   \u251c\u2500\u2500 routes.py\n    |-- \u2502   \u251c\u2500\u2500 schemas.py\n    |-- \u2502   \u2514\u2500\u2500 service.py\n    `-- \u2514\u2500\u2500 tags/\n        |-- \u251c\u2500\u2500 __init__.py\n        |-- \u251c\u2500\u2500 routes.py\n        |-- \u251c\u2500\u2500 schemas.py\n        `-- \u2514\u2500\u2500 service.py\n</code></pre></p>"},{"location":"chapter11/#conclusion","title":"Conclusion","text":"<p>This has been the longest chapter in our series. We've looked at how database models and API schemas can create complex relationships. We set up different relationships between our entities, mainly focusing on one-to-many and many-to-many relationships. We've also made sure these relationships are returned correctly by our API routes when we retrieve data.</p>"},{"location":"chapter12/","title":"Error Handling in FastAPI","text":"<p>At this point, you are probably familiar with the concept of error handling as we have used it in previous chapters. We have been using the built-in <code>HTTPException</code> class to raise exceptions within our application. While <code>HTTPException</code> is useful for general errors, there may be situations where we need to handle errors specific to the functionalities of our application. In such cases, creating custom error classes can provide more specific and easy-to-document error handling. In this chapter, we will explore how to create custom error-handling for our application to manage errors more effectively.</p>"},{"location":"chapter12/#the-fastapi-httpexception-class","title":"The FastAPI <code>HTTPException</code> Class","text":"<p>The <code>HTTPException</code> class in FastAPI is an excellent tool for raising exceptions by creating a JSON response with the appropriate status code and message. It also allows us to provide headers for the response. Here's a simple example of how it works:</p> A simple use of the HTTPException<pre><code>if not tag:\n    raise HTTPException(\n        status_code=status.HTTP_404_NOT_FOUND, detail=\"Tag does not exist\"\n    )\n</code></pre> <p>In this example, if the <code>tag</code> variable is <code>None</code>, an <code>HTTPException</code> is raised with a <code>404 Not Found</code> status code and a custom error message.</p> <p>While this method is sufficient for most cases, there are situations where we may want to provide more details about what caused the error and what users can do to resolve it. This is where custom error handling comes into play.</p>"},{"location":"chapter12/#creating-custom-exceptions","title":"Creating Custom Exceptions","text":"<p>To implement custom error-handling, we will create exception classes and handlers that return JSON responses with detailed information about the exceptions. Start by creating a file named <code>errors.py</code> in the <code>src</code> directory. Inside <code>errors.py</code>, add the following code:</p> custom exception classes<pre><code>class BooklyException(Exception):\n    \"\"\"This is the base class for all bookly errors\"\"\"\n    pass\n\nclass InvalidToken(BooklyException):\n    \"\"\"User has provided an invalid or expired token\"\"\"\n    pass\n\nclass RevokedToken(BooklyException):\n    \"\"\"User has provided a token that has been revoked\"\"\"\n    pass\n\nclass AccessTokenRequired(BooklyException):\n    \"\"\"User has provided a refresh token when an access token is needed\"\"\"\n    pass\n\nclass RefreshTokenRequired(BooklyException):\n    \"\"\"User has provided an access token when a refresh token is needed\"\"\"\n    pass\n\nclass UserAlreadyExists(BooklyException):\n    \"\"\"User has provided an email for a user who exists during sign up.\"\"\"\n    pass\n\nclass InvalidCredentials(BooklyException):\n    \"\"\"User has provided wrong email or password during log in.\"\"\"\n    pass\n\nclass InsufficientPermission(BooklyException):\n    \"\"\"User does not have the necessary permissions to perform an action.\"\"\"\n    pass\n\nclass BookNotFound(BooklyException):\n    \"\"\"Book Not found\"\"\"\n    pass\n\nclass TagNotFound(BooklyException):\n    \"\"\"Tag Not found\"\"\"\n    pass\n\nclass TagAlreadyExists(BooklyException):\n    \"\"\"Tag already exists\"\"\"\n    pass\n\nclass UserNotFound(BooklyException):\n    \"\"\"User Not found\"\"\"\n    pass\n</code></pre>"},{"location":"chapter12/#exception-classes-and-their-descriptions","title":"Exception Classes and Their Descriptions","text":"<p>Each exception class in our application handles a specific type of error. Here\u2019s a table summarizing the exceptions and their descriptions:</p> Exception Class Description <code>BooklyException</code> This is the base class for all Bookly errors <code>InvalidToken</code> User has provided an invalid or expired token <code>RevokedToken</code> User has provided a token that has been revoked <code>AccessTokenRequired</code> User has provided a refresh token when an access token is needed <code>RefreshTokenRequired</code> User has provided an access token when a refresh token is needed <code>UserAlreadyExists</code> User has provided an email for a user who exists during sign up <code>InvalidCredentials</code> User has provided wrong email or password during log in <code>InsufficientPermission</code> User does not have the necessary permissions to perform an action <code>BookNotFound</code> Book Not found <code>TagNotFound</code> Tag Not found <code>TagAlreadyExists</code> Tag already exists <code>UserNotFound</code> User Not found"},{"location":"chapter12/#creating-error-handlers","title":"Creating Error Handlers","text":"<p>Each exception class, when handled, will be raised when a specific error has been encountered within the application. To manage these errors effectively, we need to create error-handler functions for each exception. Manually creating these functions can be repetitive and time-consuming. To streamline this process, we can use a function that dynamically creates error-handlers, making our code cleaner and easier to maintain.</p> function to create error-handlers<pre><code>def create_exception_handler(\n    status_code: int, initial_detail: Any\n) -&gt; Callable[[Request, Exception], JSONResponse]:\n\n    async def exception_handler(request: Request, exc: BooklyException):\n\n        return JSONResponse(content=initial_detail, status_code=status_code)\n\n    return exception_handler\n</code></pre> <p>The <code>create_exception_handler</code> function helps us generate custom error handlers quickly. It takes two parameters: <code>status_code</code> and <code>initial_detail</code>. The <code>status_code</code> parameter is the HTTP status code that will be returned when the error occurs. The <code>initial_detail</code> parameter contains the message or content to include in the JSON response.</p> <p>Within <code>create_exception_handler</code>, we define an inner function called <code>exception_handler</code>. This function handles our custom exceptions. It takes two parameters: <code>request</code>, which is an instance of <code>Request</code> from FastAPI, and <code>exc</code>, which is the exception instance. The <code>exception_handler</code> function returns a <code>JSONResponse</code> with the specified <code>status_code</code> and <code>initial_detail</code>.</p> <p>The outer function, <code>create_exception_handler</code>, returns the inner <code>exception_handler</code> function. This allows us to easily create specific handlers for different exceptions by calling <code>create_exception_handler</code> with the appropriate arguments.</p>"},{"location":"chapter12/#registering-error-handlers","title":"Registering Error Handlers","text":"<p>To use this function, we can define error handlers for each custom exception by passing the relevant status code and error details. Each handler will return a consistent and informative JSON response, ensuring that each error type is managed properly. We wrap all error handlers in the <code>register_error_handlers</code> function which takes in the FastAPI <code>app</code> instance we may want to register exception handlers.</p> <p>using custom error handlers<pre><code>from fastapi import FastAPI\n\n... # rest of the file\ndef register_error_handlers(app: FastAPI):\n    app.add_exception_handler(\n        UserAlreadyExists,\n        create_exception_handler(\n            status_code=status.HTTP_403_FORBIDDEN,\n            initial_detail={\n                \"message\": \"User with email already exists\",\n                \"error_code\": \"user_exists\",\n            },\n        ),\n    )\n\n    app.add_exception_handler(\n        UserNotFound,\n        create_exception_handler(\n            status_code=status.HTTP_404_NOT_FOUND,\n            initial_detail={\n                \"message\": \"User not found\",\n                \"error_code\": \"user_not_found\",\n            },\n        ),\n    )\n    app.add_exception_handler(\n        BookNotFound,\n        create_exception_handler(\n            status_code=status.HTTP_404_NOT_FOUND,\n            initial_detail={\n                \"message\": \"Book not found\",\n                \"error_code\": \"book_not_found\",\n            },\n        ),\n    )\n    app.add_exception_handler(\n        InvalidCredentials,\n        create_exception_handler(\n            status_code=status.HTTP_400_BAD_REQUEST,\n            initial_detail={\n                \"message\": \"Invalid Email Or Password\",\n                \"error_code\": \"invalid_email_or_password\",\n            },\n        ),\n    )\n    app.add_exception_handler(\n        InvalidToken,\n        create_exception_handler(\n            status_code=status.HTTP_401_UNAUTHORIZED,\n            initial_detail={\n                \"message\": \"Token is invalid Or expired\",\n                \"resolution\": \"Please get new token\",\n                \"error_code\": \"invalid_token\",\n            },\n        ),\n    )\n    app.add_exception_handler(\n        RevokedToken,\n        create_exception_handler(\n            status_code=status.HTTP_401_UNAUTHORIZED,\n            initial_detail={\n                \"message\": \"Token is invalid or has been revoked\",\n                \"resolution\": \"Please get new token\",\n                \"error_code\": \"token_revoked\",\n            },\n        ),\n    )\n    app.add_exception_handler(\n        AccessTokenRequired,\n        create_exception_handler(\n            status_code=status.HTTP_401_UNAUTHORIZED,\n            initial_detail={\n                \"message\": \"Please provide a valid access token\",\n                \"resolution\": \"Please get an access token\",\n                \"error_code\": \"access_token_required\",\n            },\n        ),\n    )\n    app.add_exception_handler(\n        RefreshTokenRequired,\n        create_exception_handler(\n            status_code=status.HTTP_403_FORBIDDEN,\n            initial_detail={\n                \"message\": \"Please provide a valid refresh token\",\n                \"resolution\": \"Please get an refresh token\",\n                \"error_code\": \"refresh_token_required\",\n            },\n        ),\n    )\n    app.add_exception_handler(\n        InsufficientPermission,\n        create_exception_handler(\n            status_code=status.HTTP_401_UNAUTHORIZED,\n            initial_detail={\n                \"message\": \"You do not have enough permissions to perform this action\",\n                \"error_code\": \"insufficient_permissions\",\n            },\n        ),\n    )\n    app.add_exception_handler(\n        TagNotFound,\n        create_exception_handler(\n            status_code=status.HTTP_404_NOT_FOUND,\n            initial_detail={\"message\": \"Tag Not Found\", \"error_code\": \"tag_not_found\"},\n        ),\n    )\n\n    app.add_exception_handler(\n        TagAlreadyExists,\n        create_exception_handler(\n            status_code=status.HTTP_401_UNAUTHORIZED,\n            initial_detail={\n                \"message\": \"Tag Already exists\",\n                \"error_code\": \"tag_exists\",\n            },\n        ),\n    )\n\n    app.add_exception_handler(\n        BookNotFound,\n        create_exception_handler(\n            status_code=status.HTTP_404_NOT_FOUND,\n            initial_detail={\n                \"message\": \"Book Not Found\",\n                \"error_code\": \"book_not_found\",\n            },\n        ),\n    )\n\n    @app.exception_handler(500)\n    async def internal_server_error(request, exc):\n\n        return JSONResponse(\n            content={\n                \"message\": \"Oops! Something went wrong\",\n                \"error_code\": \"server_error\",\n            },\n            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,\n        )\n</code></pre> By using the <code>create_exception_handler</code> function, we can maintain a cleaner and more manageable codebase. This approach simplifies the process of handling various exceptions and ensures that our application provides clear and helpful error messages to the users.</p> <p>To make this work, we shall call the <code>register_error_handlers</code> function inside <code>src/__init__.py</code>. Let us do that:</p> register exceptions to the application<pre><code>from fastapi import FastAPI, status\nfrom fastapi.responses import JSONResponse\nfrom src.auth.routes import auth_router\nfrom src.books.routes import book_router\nfrom src.reviews.routes import review_router\nfrom src.tags.routes import tags_router\nfrom .errors import register_error_handlers\n\nversion = \"v1\"\n\napp = FastAPI(\n    title=\"Bookly\",\n    description=\"A REST API for a book review web service\",\n    version=version,\n)\n\nregister_error_handlers(app)  # add this line\n\napp.include_router(book_router, prefix=f\"/api/{version}/books\", tags=[\"books\"])\napp.include_router(auth_router, prefix=f\"/api/{version}/auth\", tags=[\"auth\"])\napp.include_router(review_router, prefix=f\"/api/{version}/reviews\", tags=[\"reviews\"])\napp.include_router(tags_router, prefix=f\"/api/{version}/tags\", tags=[\"tags\"])\n</code></pre> <p>Calling the <code>register_error_handlers</code> function enables us to register the created error handlers so that our application makes use of them. We provide the main application instance <code>app</code> to make sure the application uses them.</p>"},{"location":"chapter12/#modifying-our-code","title":"Modifying our code","text":"<p>After that, we shall then modify our code to make use of the created exceptions. We shall begin with the authentication dependencies. Let us go to <code>src/auth/dependencies.py</code> and add the following code.</p> adding custom errors in auth dependencies<pre><code>from typing import Any, List\n\nfrom fastapi import Depends, Request\nfrom fastapi.security import HTTPBearer\nfrom fastapi.security.http import HTTPAuthorizationCredentials\nfrom sqlmodel.ext.asyncio.session import AsyncSession\n\nfrom src.db.main import get_session\nfrom src.db.models import User\nfrom src.db.redis import token_in_blocklist\n\nfrom .service import UserService\nfrom .utils import decode_token\nfrom src.errors import (\n    InvalidToken,\n    RefreshTokenRequired,\n    AccessTokenRequired,\n    InsufficientPermission\n)\n\nuser_service = UserService()\n\n\nclass TokenBearer(HTTPBearer):\n    def __init__(self, auto_error=True):\n        super().__init__(auto_error=auto_error)\n\n    async def __call__(self, request: Request) -&gt; HTTPAuthorizationCredentials | None:\n        creds = await super().__call__(request)\n\n        token = creds.credentials\n\n        token_data = decode_token(token)\n\n        if not self.token_valid(token):\n            raise InvalidToken()\n\n        if await token_in_blocklist(token_data[\"jti\"]):\n            raise InvalidToken()\n\n        self.verify_token_data(token_data)\n\n        return token_data\n\n    def token_valid(self, token: str) -&gt; bool:\n        token_data = decode_token(token)\n\n        return token_data is not None\n\n    def verify_token_data(self, token_data):\n        raise NotImplementedError(\"Please Override this method in child classes\")\n\n\nclass AccessTokenBearer(TokenBearer):\n    def verify_token_data(self, token_data: dict) -&gt; None:\n        if token_data and token_data[\"refresh\"]:\n            raise AccessTokenRequired()\n\n\nclass RefreshTokenBearer(TokenBearer):\n    def verify_token_data(self, token_data: dict) -&gt; None:\n        if token_data and not token_data[\"refresh\"]:\n            raise RefreshTokenRequired()\n\n\nasync def get_current_user(\n    token_details: dict = Depends(AccessTokenBearer()),\n    session: AsyncSession = Depends(get_session),\n):\n    user_email = token_details[\"user\"][\"email\"]\n\n    user = await user_service.get_user_by_email(user_email, session)\n\n    return user\n\n\nclass RoleChecker:\n    def __init__(self, allowed_roles: List[str]) -&gt; None:\n        self.allowed_roles = allowed_roles\n\n    def __call__(self, current_user: User = Depends(get_current_user)) -&gt; Any:\n        if current_user.role in self.allowed_roles:\n            return True\n\n        raise InsufficientPermission()\n</code></pre> <p>What we've accomplished is replacing every instance where we used <code>HTTPException</code> with our own custom exceptions designed for each specific type of error. </p> <p>To keep this chapter concise, I'll leave you with the task of updating the rest of our application's code to include custom error handlers similar to the ones we've created here.</p>"},{"location":"chapter12/#conclusion","title":"Conclusion","text":"<p>Throughout this chapter, we've explored the creation of custom error handlers. These handlers empower us to provide tailored error messages based on the specific issues encountered within our application. We began by creating custom exception classes to encapsulate different types of errors. Following that, we implemented handlers to manage these exceptions and ensure appropriate responses are sent back to clients. Finally, we concluded by integrating these custom error handlers into our application, thereby enhancing its robustness and user experience.</p>"},{"location":"chapter13/","title":"Middleware","text":"<p>We have explored many aspects of FastAPI so far. In this chapter, we will delve into another interesting topic: Middleware. Middleware are components (functions or classes) that lie between the requests and responses, allowing for the modification of requests before they are processed and responses before they are sent to clients.</p>"},{"location":"chapter13/#what-is-middleware-in-fastapi","title":"What is Middleware in FastAPI?","text":"<p>A simple diagram can explain this.</p> <p></p> <p>From the diagram, we have the client and the server as the two main components. Inside the server, middleware sits right between the client and the route-handler functions.</p> <p>Each request made to the server will pass through the middleware before it is handled by the route handlers.</p> <p>Once the server has handled the request, a response is generated and still passes through the middleware before being returned to the client.</p>"},{"location":"chapter13/#functions-of-middleware","title":"Functions of Middleware","text":"<p>Using middleware, we can enhance FastAPI functionalities. Here are some of the ways we can use it:</p> <ol> <li> <p>Logging: Middleware can modify how the server logs details of requests and responses for monitoring and debugging purposes.</p> </li> <li> <p>Authentication: Middleware can handle authentication by verifying if the tokens or credentials provided by clients are valid before the requests reach the application.</p> </li> <li> <p>Handling CORS: Middleware can determine which domains are allowed to access your application's resources.</p> </li> <li> <p>Request Modification: Middleware can modify requests by adding or altering headers before they reach the application.</p> </li> <li> <p>Response Modification: Middleware can modify responses by providing custom headers, changing the response body, and so on.</p> </li> </ol> <p>These are some of the ways that middleware can be useful in a FastAPI application.</p>"},{"location":"chapter13/#creating-middleware","title":"Creating Middleware","text":"<p>As explained in the introduction of this chapter, middleware can be functions or classes. Let us create our first middleware function to modify how the application logs the details of requests and responses.</p> <p>To begin, we will create a new file <code>src/middleware.py</code> and add the following code to it.</p> a logging middleware<pre><code>from fastapi import FastAPI, status\nfrom fastapi.requests import Request\nfrom fastapi.responses import JSONResponse\nimport time\nimport logging\n\nlogger = logging.getLogger(\"uvicorn.access\")\nlogger.disabled = True\n\n\n@app.middleware(\"http\")\nasync def custom_logging(request: Request, call_next):\n    start_time = time.time()\n\n    response = await call_next(request)\n    processing_time = time.time() - start_time\n\n    message = f\"{request.client.host}:{request.client.port} - {request.method} - {request.url.path} - {response.status_code} completed after {processing_time}s\"\n\n    print(message)\n    return response\n</code></pre> <p>First, we disable the default logging provided by FastAPI by getting the logger that FastAPI uses and disabling it.</p> <pre><code>import logging\n\nlogger = logging.getLogger(\"uvicorn.access\")\nlogger.disabled = True\n</code></pre> <p>Next, we create a function <code>custom_logging</code> to use as our logging middleware. To make it a middleware, we use the <code>app</code> FastAPI instance to create a decorator using the <code>middleware</code> method. This takes a <code>middleware_type</code> argument, which in our case is <code>http</code>.</p> decorator for the middleware function<pre><code>@app.middleware(\"http\")\n</code></pre> <p>The function <code>custom_logging</code> takes in two parameters:</p> <ul> <li><code>request</code>: The request object for the current request.</li> <li><code>call_next</code>: A function that represents the route handler or any other middleware registered on the application.</li> </ul> <p>Before processing the request, we define a variable <code>start_time</code> to record the start time.</p> recording the start time<pre><code>start_time = time.time()\n</code></pre> <p>To get the response, we call <code>call_next</code> with the <code>request</code> object as an argument.</p> getting the response object<pre><code>response = await call_next(request)\n</code></pre> <p>Before returning the <code>response</code>, we need to record the processing time of the request by subtracting the <code>start_time</code> from the current time. We then create a custom message that logs the requests to our application. This message contains the client's IP address, request method, request URL, status code, and processing time. We use the Python <code>print</code> statement to print the message to our output.</p> rest of the middleware<pre><code>response = await call_next(request)\nprocessing_time = time.time() - start_time\n\nmessage = f\"{request.client.host}:{request.client.port} - {request.method} - {request.url.path} - {response.status_code} completed after {processing_time}s\"\n\nprint(message)\nreturn response\n</code></pre> <p>Finally, we return the <code>response</code> object. This middleware function logs detailed information about each request and response, which is useful for monitoring and debugging purposes.</p> <p>To add this middleware, we wrap the middleware we created in our <code>register_middleware</code> function. This function takes in the FastAPI <code>app</code> instance.</p> register middleware<pre><code>def register_middleware(app: FastAPI):\n\n    @app.middleware(\"http\")\n    async def custom_logging(request: Request, call_next):\n        start_time = time.time()\n\n        response = await call_next(request)\n        processing_time = time.time() - start_time\n\n        message = f\"{request.client.host}:{request.client.port} - {request.method} - {request.url.path} - {response.status_code} completed after {processing_time}s\"\n\n        print(message)\n        return response\n</code></pre> <p>Next, we make our middleware work with the application by registering it with the main <code>app</code> instance in <code>src/__init__.py</code>.</p> <pre><code>from fastapi import FastAPI\nfrom src.auth.routes import auth_router\nfrom src.books.routes import book_router\nfrom src.reviews.routes import review_router\nfrom src.tags.routes import tags_router\nfrom .errors import register_error_handlers\nfrom .middleware import register_middleware\n\nversion = \"v1\"\n\napp = FastAPI(\n    title=\"Bookly\",\n    description=\"A REST API for a book review web service\",\n    version=version,\n)\n\nregister_error_handlers(app)\nregister_middleware(app)  # Add this\n\napp.include_router(book_router, prefix=f\"/api/{version}/books\", tags=[\"books\"])\napp.include_router(auth_router, prefix=f\"/api/{version}/auth\", tags=[\"auth\"])\napp.include_router(review_router, prefix=f\"/api/{version}/reviews\", tags=[\"reviews\"])\napp.include_router(tags_router, prefix=f\"/api/{version}/tags\", tags=[\"tags\"])\n</code></pre> <p>By doing this, we have modified our logging to provide more detailed output for debugging and monitoring purposes. Initially, FastAPI logged our responses and requests like this:</p> <p></p> <p>After changing our logging using the middleware we created, the logging will look like this:</p> <p></p>"},{"location":"chapter13/#using-custom-middleware","title":"Using Custom Middleware","text":"<p>FastAPI is an ASGI (Asynchronous Server Gateway Interface) based framework, and any middleware that is ASGI-based can be used with it by simply importing it and using the <code>add_middleware</code> method of the main FastAPI instance.</p>"},{"location":"chapter13/#cors-middleware","title":"CORS Middleware","text":"<p>FastAPI provides middleware to handle CORS (Cross-Origin Resource Sharing), allowing us to specify which domains will have access to the resources in our application.</p> adding CORS middleware<pre><code>from fastapi import FastAPI, status\nfrom fastapi.requests import Request\nfrom fastapi.responses import JSONResponse\nfrom fastapi.middleware.cors import CORSMiddleware  # Add this\nimport time\nimport logging\n\nlogger = logging.getLogger(\"uvicorn.access\")\nlogger.disabled = True\n\n\ndef register_middleware(app: FastAPI):\n\n    @app.middleware(\"http\")\n    async def custom_logging(request: Request, call_next):\n        start_time = time.time()\n\n        response = await call_next(request)\n        processing_time = time.time() - start_time\n\n        message = f\"{request.client.host}:{request.client.port} - {request.method} - {request.url.path} - {response.status_code} completed after {processing_time}s\"\n\n        print(message)\n        return response\n\n    # Add this\n    app.add_middleware(\n        CORSMiddleware,\n        allow_origins=[\"*\"],\n        allow_methods=[\"*\"],\n        allow_headers=[\"*\"],\n        allow_credentials=True,\n    )\n</code></pre> <p>To set up CORS (Cross-Origin Resource Sharing) middleware in FastAPI, you use the <code>CORSMiddleware</code> from <code>fastapi.middleware.cors</code>. This middleware allows you to specify which origins, methods, and headers are permitted to make requests to your API. First, you need to create a FastAPI application instance.</p> <p>Then, you can add the <code>CORSMiddleware</code> to your app using the <code>add_middleware</code> method.</p> CORS Configuration<pre><code>app.add_middleware(\n    CORSMiddleware,\n    allow_origins=[\"*\"],\n    allow_methods=[\"*\"],\n    allow_headers=[\"*\"],\n    allow_credentials=True,\n)\n</code></pre> <p>This method accepts several configuration options: <code>allow_origins</code> to specify a list of allowed origins (you can use <code>[\"*\"]</code> to allow all origins), <code>allow_credentials</code> to enable cookies and authentication headers, <code>allow_methods</code> to specify which HTTP methods are permitted (use <code>[\"*\"]</code> to allow all methods), and <code>allow_headers</code> to define which headers are allowed in requests (use <code>[\"*\"]</code> to allow all headers). By configuring the middleware in this way, you ensure that your FastAPI application can handle cross-origin requests according to the specified rules, providing flexibility and security in accessing your API from different origins.</p>"},{"location":"chapter13/#trusted-host-middleware","title":"Trusted Host Middleware","text":"<p>To add the Trusted Host Middleware, you can do the following:</p> <pre><code>from fastapi.middleware.trustedhost import TrustedHostMiddleware\n\ndef register_middleware(app: FastAPI):\n    ...  # rest of the middleware code\n    app.add_middleware(\n        TrustedHostMiddleware,\n        allowed_hosts=[\"localhost\", \"127.0.0.1\"],\n    )\n</code></pre> <p>By doing so, we have imported the <code>TrustedHostMiddleware</code> and added it to our application. We have also specified which hosts are allowed to access our application.</p>"},{"location":"chapter13/#conclusion","title":"Conclusion","text":"<p>Middleware in FastAPI is a powerful feature that allows you to enhance the functionality of your application by modifying requests before they are processed and responses before they are sent to clients. We have explored various uses of middleware, such as logging, authentication, handling CORS, and modifying requests and responses.</p> <p>We created a custom logging middleware to log detailed information about each request and response. We also set up CORS middleware to manage cross-origin requests, ensuring our API is accessible according to specified rules. Finally, we added the Trusted Host Middleware to restrict the allowed hosts that can make requests to our application, adding an extra layer of security.</p> <p>By understanding and utilizing middleware, you can build more robust and secure FastAPI applications, tailored to meet the specific needs of your projects.</p>"},{"location":"chapter14/","title":"Email Support","text":"<p>We've built many features in our application, but we intentionally skipped some that require sending emails. This allows us to dedicate a chapter to exploring email functionality in detail. Sending emails is crucial for communicating with users, verifying identities, and enabling password resets.</p>"},{"location":"chapter14/#fastapi-mail","title":"FastAPI-Mail","text":"<p>If you're familiar with Flask, the most popular extension for adding email support is Flask-Mail. Flask-Mail allows emails to be sent with a straightforward setup. The FastAPI equivalent is FastAPI-Mail, which has a similar configuration process but also supports asynchronous operations and Pydantic models.</p> <p>Let's begin by installing FastAPI-Mail. In your terminal, within the active virtual environment, install it with:</p> <pre><code>$ pip install fastapi-mail\n</code></pre>"},{"location":"chapter14/#configuring-fastapi-mail","title":"Configuring FastAPI-Mail","text":"<p>Let's create a file to set up FastAPI-Mail and centralize all email-sending logic. Inside the <code>src/</code> directory, create a file called <code>mail.py</code> and add the following code:</p> <pre><code>from fastapi_mail import FastMail, ConnectionConfig, MessageSchema, MessageType\nfrom src.config import Config\nfrom pathlib import Path\n\n\n# get the parent directory\nBASE_DIR = Path(__file__).resolve().parent\n\n\n# create the config for sending emails\nmail_config = ConnectionConfig(\n    MAIL_USERNAME=Config.MAIL_USERNAME,\n    MAIL_PASSWORD=Config.MAIL_PASSWORD,\n    MAIL_FROM=Config.MAIL_FROM,\n    MAIL_PORT=587,\n    MAIL_SERVER=Config.MAIL_SERVER,\n    MAIL_FROM_NAME=Config.MAIL_FROM_NAME,\n    MAIL_STARTTLS=True,\n    MAIL_SSL_TLS=False,\n    USE_CREDENTIALS=True,\n    VALIDATE_CERTS=True,\n    TEMPLATE_FOLDER=Path(BASE_DIR, \"templates\"),\n)\n\n\n# create the object to send emails with the config\nmail = FastMail(config=mail_config)\n\ndef create_message(recipients: list[str], subject: str, body: str):\n    message = MessageSchema(\n        recipients=recipients, subject=subject, body=body, subtype=MessageType.html\n    )\n    return message\n</code></pre>"},{"location":"chapter14/#explanation","title":"Explanation","text":"<p>We begin by importing <code>FastMail</code>, <code>ConnectionConfig</code>, <code>MessageSchema</code>, and <code>MessageType</code>.</p> The imports<pre><code>from fastapi_mail import FastMail, ConnectionConfig, MessageSchema, MessageType\nfrom src.config import Config\nfrom pathlib import Path\n</code></pre> <ul> <li><code>FastMail</code>: Creates the <code>mail</code> object for accessing email-sending methods.</li> <li><code>ConnectionConfig</code>: Sets up the email configuration for FastAPI-Mail.</li> <li><code>MessageSchema</code>: Structures an email before sending.</li> <li><code>MessageType</code>: Specifies the type of content to send via email (e.g., HTML).</li> <li><code>Config</code>: Imports application-specific configurations, including email settings.</li> <li><code>Path</code>: Used to create paths, particularly for determining the location of the templates folder.</li> </ul> <p>We then proceed to configure FastAPI-Mail using values we get from our <code>Config</code> object.</p> email config<pre><code>mail_config = ConnectionConfig(\n    MAIL_USERNAME=Config.MAIL_USERNAME,\n    MAIL_PASSWORD=Config.MAIL_PASSWORD,\n    MAIL_FROM=Config.MAIL_FROM,\n    MAIL_PORT=587,\n    MAIL_SERVER=Config.MAIL_SERVER,\n    MAIL_FROM_NAME=Config.MAIL_FROM_NAME,\n    MAIL_STARTTLS=True,\n    MAIL_SSL_TLS=False,\n    USE_CREDENTIALS=True,\n    VALIDATE_CERTS=True,\n    TEMPLATE_FOLDER=Path(BASE_DIR, \"templates\"),\n)\n</code></pre> Key Explanation <code>MAIL_USERNAME</code> The username of the email address sending the emails. Set via an environment variable. <code>MAIL_PASSWORD</code> The password for the SMTP server. For Gmail, this is an app-specific password. Set via an environment variable. <code>MAIL_FROM</code> The email address of the sender. Set via an environment variable. <code>MAIL_PORT</code> The port used to connect to the SMTP server (usually 587 for TLS). Set via an environment variable. <code>MAIL_SERVER</code> The SMTP server used to send emails (e.g., smtp.gmail.com). Set via an environment variable. <code>MAIL_FROM_NAME</code> The name displayed as the sender of the email. Set via an environment variable. <code>MAIL_STARTTLS</code> Enables the STARTTLS command, which upgrades the connection to a secure TLS/SSL connection. Set to True. <code>MAIL_SSL_TLS</code> Indicates whether to use SSL/TLS for the connection from the start. Set to False if <code>MAIL_STARTTLS</code> is True. <code>USE_CREDENTIALS</code> Specifies whether to use credentials (username and password) to authenticate with the SMTP server. Set to True. <code>VALIDATE_CERTS</code> Specifies whether to validate the server's SSL certificates. Set to True. <code>TEMPLATE_FOLDER</code> Specifies the folder containing email templates, useful for sending HTML emails with Jinja templates. we set this up to make use of <code>BASE_DIR</code> to point to a <code>templates</code> folder we should have in our <code>src</code> <p>The <code>mail</code> object is created using the <code>FastMail</code> class and is configured with <code>mail_config</code>:</p> <pre><code>mail = FastMail(config=mail_config)\n</code></pre> <p>A function <code>create_message</code> is defined to create an email message. It takes <code>recipients</code>, <code>subject</code>, and <code>body</code> as parameters and returns a <code>MessageSchema</code> object:</p> <pre><code>def create_message(recipients: list[str], subject: str, body: str):\n    message = MessageSchema(\n        recipients=recipients, subject=subject, body=body, subtype=MessageType.html\n    )\n    return message\n</code></pre> <p>In the <code>Settings</code> class located in <code>src.config.py</code>, email-related configuration variables are added. These variables are used to configure the email sending settings:</p> <pre><code>class Settings(BaseSettings):\n    DATABASE_URL: str\n    JWT_SECRET: str\n    JWT_ALGORITHM: str\n    REDIS_HOST: str\n    REDIS_PORT: str\n    # add these\n    MAIL_USERNAME: str\n    MAIL_PASSWORD: str\n    MAIL_FROM: str\n    MAIL_PORT: int\n    MAIL_SERVER: str\n    MAIL_FROM_NAME: str\n    MAIL_STARTTLS: bool = True\n    MAIL_SSL_TLS: bool = False\n    USE_CREDENTIALS: bool = True\n    VALIDATE_CERTS: bool = True\n    DOMAIN: str\n    model_config = SettingsConfigDict(env_file=\".env\", extra=\"ignore\")\n</code></pre> <p>The <code>.env</code> file should be updated with the relevant environment variables for email configuration:</p> <pre><code>DATABASE_URL=&lt;your postgresql url&gt;\nJWT_SECRET=&lt;your jwt secret&gt;\nJWT_ALGORITHM=&lt;your jwt algorithm&gt;\nREDIS_HOST=localhost\nREDIS_PORT=6379\n\nMAIL_USERNAME=&lt;your mail username&gt;\nMAIL_PASSWORD=&lt;your mail password&gt;\nMAIL_SERVER=smtp.gmail.com\nMAIL_PORT=587\nMAIL_FROM=&lt;your email address&gt;\nMAIL_FROM_NAME=Bookly\n\nDOMAIN=localhost:8000\n</code></pre> <p>Note</p> <p>The <code>DOMAIN</code> environment variable shall be set to help us when we create the verification and password reset links.</p>"},{"location":"chapter14/#sending-our-first-email","title":"Sending Our First Email","text":"<p>To send an email, all we shall have to do is to call the <code>send_message</code> method on the <code>mail</code> object. Let us do that in <code>src/auth/routes.py</code>.</p> sending emails<pre><code>.... # rest of the imports\nfrom src.mail import mail, create_message\nfrom src.celery_tasks import send_email\nfrom src.auth.schemas import EmailModel\n\nauth_router = APIRouter()\n\n\n@auth_router.post(\"/send_mail\")\nasync def send_mail(emails: EmailModel):\n    emails = emails.addresses\n\n    html = \"&lt;h1&gt;Welcome to the app&lt;/h1&gt;\"\n    subject = \"Welcome to our app\"\n\n    message = create_message(recipients=emails, subject=subject, body=html)\n    mail.send_message(message)\n\n    return {\"message\": \"Email sent successfully\"}\n</code></pre> <p>To send an email, we'll utilize the <code>send_message</code> method within the <code>mail</code> object. This code will reside in the <code>src/auth/routes.py</code> file.</p> <p>We've constructed an API endpoint accessible at the <code>/auth/send_mail</code> path. Its corresponding handler function is named <code>send_mail</code>. This function accepts an <code>EmailModel</code> object as input, which contains a list of email addresses intended for the email. </p> <p>We extract these addresses from the <code>EmailModel</code> object. A basic HTML structure  <code>html</code> and a <code>subject</code> line are defined for the email content. Subsequently, the <code>create_message</code> function is invoked, providing the <code>recipient</code> <code>email</code> <code>addresses</code>, subject, and HTML content. This function generates a message object which is then passed to the mail.send_message method to dispatch the email. A success message is returned to indicate successful email transmission.</p> <p>The <code>EmailModel</code> class, located in <code>src/auth/schemas.py</code>, is a Pydantic model designed to validate the incoming email addresses. It mandates a list of email strings within the addresses field.</p> pydantic model for getting recipient email addresses<pre><code>class EmailModel(BaseModel):\n    addresses : List[str]\n</code></pre> <p>Here\u2019s the revised text with improved grammar and language:</p> <p>Let us test this. Accessing the endpoint and making a request results in the following response:</p> <p></p> <p>To confirm if our email has been sent:</p> <p></p> <p>Note</p> <p>You may notice a slight delay between the sending of the emails and the response indicating that an email has been successfully sent. This is because, to send the email, we are making another request to the SMTP server we use. We will explore an approach to speed this up in a later chapter.</p>"},{"location":"chapter14/#user-account-verification","title":"User Account Verification","text":"<p>If you have followed this series from the beginning, you will notice that we created a user authentication database model called <code>User</code>. In this model, we defined the <code>is_verified</code> field to handle the activation of user accounts. We will start by implementing this verification process using the email address provided by the user during signup.</p> <p>User account verification is important as it prevents the creation of fake accounts. It also allows us to collect user email addresses for communications and other purposes.</p>"},{"location":"chapter14/#itsdangerous","title":"ItsDangerous","text":"<p>To safely move data from our server to an untrusted environment, we will use ItsDangerous. ItsDangerous is a Python package that allows us to cryptographically sign data and hand it over to someone else, ensuring that the data has not been tampered with when we receive it. The recipient of the data can receive and read it but cannot modify it unless they have the sender's secret key.</p> <p>This package will be crucial as it will enable us to create URL-safe tokens that we will include in the user verification links we send via email.</p> <p>To install it we shall run <pre><code>$ pip install itsdangerous\n</code></pre></p> <p>To set it up, let us navigate to <code>src/auth/utils.py</code> and add the following code.</p> <p>serializing and deserializing user's email address<pre><code>... #rest of the imports\n\nfrom itsdangerous import URLSafeTimedSerializer\n\n... # rest of the code \n\nserializer = URLSafeTimedSerializer(\n    secret_key=Config.JWT_SECRET, salt=\"email-configuration\"\n)\n\ndef create_url_safe_token(data: dict):\n    \"\"\"Serialize a dict into a URLSafe token\"\"\"\n\n    token = serializer.dumps(data)\n\n    return token\n\ndef decode_url_safe_token(token:str):\n    \"\"\"Deserialize a URLSafe token to get data\"\"\"\n    try:\n        token_data = serializer.loads(token)\n\n        return token_data\n\n    except Exception as e:\n        logging.error(str(e))\n</code></pre> In the above code, we begin by importing the <code>URLSafeTimedSerializer</code> class that will allow us to create the <code>serializer</code> object we shall use to serialize the user's email address. We configure it using the <code>secret_key</code> that comes from the same secret key we used to create our access tokens and provide a <code>salt</code> which we keep to the string of \"email-verification\".</p> <p>After that, we then create two functions <code>create_url_safe_token</code> and <code>decode_url_safe_token</code> . The first function is responsible for serializing the <code>data</code> dictionary into a <code>token</code>.</p> <p>The second function allows us to deserialize a token so that we get the data, also catching any errors that may occur.</p>"},{"location":"chapter2/","title":"Creating a Simple Web Server","text":""},{"location":"chapter2/#introduction","title":"Introduction","text":"<p>Now that we have FastAPI installed, we are going to create a simple web server on whicn our application shall run using FastAPI.</p> <p>At this stage, our directory only contains our virtual environment directory <code>env</code> and <code>requirements.txt</code> as shown below as follows: Current directory structure<pre><code>\u2514\u2500\u2500 env\n\u2514\u2500\u2500 requirements.txt\n</code></pre></p> <p>Let's create a file named <code>main.py</code> and populate it with the following code:</p> main.py<pre><code>from fastapi import FastAPI\n\napp = FastAPI()\n\n@app.get('/')\nasync def read_root():\n    return {\"message\": \"Hello World!\"}\n</code></pre> <p>In this code snippet, we perform the following actions:</p>"},{"location":"chapter2/#creating-a-fastapi-instance","title":"Creating a FastAPI instance:","text":"<p>We have imported the <code>FastAPI</code> class from the <code>fastapi</code> package. This class serves as the primary entry point for all FastAPI applications. Through it we can get access to various FastAPI features such as routes , middleware, exception handlers and path operations.</p> <p>We then create an instance of the <code>FastAPI</code> class named <code>app</code>. The main FastAPI instance can be called anything as long as it is a valid Python name. </p> Creating the FastAPI instance<pre><code>from fastapi import FastAPI\n\napp = FastAPI()\n</code></pre>"},{"location":"chapter2/#creating-an-api-route","title":"Creating an API Route:","text":"<p>We define our first API route by creating a function named <code>read_root</code>. This function, when accessed, will return a JSON message containing \"Hello World!\".</p> Your first API endpoint<pre><code>@app.get('/')\nasync def read_root():\n    return {\"message\": \"Hello World!\"}\n</code></pre> <p>The <code>@app</code> decorator associates the function with the HTTP GET method  via the <code>get</code> method. We then provide the path (route) of the root path (<code>/</code>). This means that whenever the <code>/</code> route is accessed, the defined message will be returned.</p> <p>All HTTP methods such as <code>post</code>,<code>put</code>,<code>head</code>,<code>patch</code>, <code>delete</code>, <code>trace</code> and <code>options</code> are all available on the <code>@app</code> decorator.</p>"},{"location":"chapter2/#running-the-fastapi-application","title":"Running the FastAPI Application:","text":"<p>To run our FastAPI application, we shall use the <code>fastapi</code>command we introduced in the previous chapter. Open a terminal and execute the following command within the virtual environment:</p> Running the server with the FastAPI CLI<pre><code>(env)$ fastapi dev main.py\n</code></pre> <p>The <code>fastapi dev</code> command enables us to execute our FastAPI application in development mode. This feature facilitates running our application with auto-reload functionality, ensuring that any modifications we make are automatically applied, restarting the server accordingly. It operates by identifying the FastAPI instance within the specified module or Python package, which in our scenario is <code>main.py</code>, where we have defined the app object. When we initiate our application, it will display the following output. terminal ouput<pre><code>INFO     Using path main.py                                                                              \nINFO     Resolved absolute path /home/jod35/Documents/fastapi-beyond-CRUD/main.py                         \nINFO     Searching for package file structure from directories with __init__.py files                 \nINFO     Importing from /home/jod35/Documents/fastapi-beyond-CRUD                                     \n\n \u256d\u2500 Python package file structure \u2500\u256e                                                                  \n \u2502                                 \u2502                                                                  \n \u2502      \ud83d\udc0d main.py                 \u2502                                                                  \n \u2502                                 \u2502                                                                  \n \u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f                                                                  \n\nINFO     Importing module main.py                                                                       \nINFO     Found importable FastAPI app                                                                 \n\n \u256d\u2500 Importable FastAPI app \u2500\u256e                                                                         \n \u2502                          \u2502                                                                         \n \u2502  from main import app    \u2502                                                                         \n \u2502                          \u2502                                                                         \n \u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f                                                                         \n\nINFO     Using import string main:app                                                                  \n\n \u256d\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 FastAPI CLI - Development mode \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e                                              \n \u2502                                                     \u2502                                              \n \u2502  Serving at: http://127.0.0.1:8000                  \u2502                                              \n \u2502                                                     \u2502                                              \n \u2502  API docs: http://127.0.0.1:8000/docs               \u2502                                              \n \u2502                                                     \u2502                                              \n \u2502  Running in development mode, for production use:   \u2502                                              \n \u2502                                                     \u2502                                              \n \u2502  fastapi run                                        \u2502                                              \n \u2502                                                     \u2502    \n</code></pre></p> <p>Running the server will make your application available at this web address: <code>http://localhost:8000</code>.</p> <p>Following these steps means you've successfully created a basic FastAPI application with a greeting endpoint. You've also learned how to start the application using Uvicorn, which helps you develop more easily because it automatically reloads your code when you make changes.</p>"},{"location":"chapter2/#choosing-an-api-client","title":"Choosing an API Client","text":"<p>Depending on your choice, you may want to test your application with an Api Client, I will begin with Insomnia which is a simple open source application for testing and development APIs.</p> <p>In insomnia, we shall create our simple request collection and we shall now see our response of <code>Hello World</code>.</p> <ol> <li> <p>Create a new request collection </p> </li> <li> <p>Name the request collection </p> </li> <li> <p>Create an HTTP request </p> </li> <li> <p>Make a request </p> </li> </ol> <p>And just like that, you have created your FastAPI application, run it and even made your HTTP request using an HTTP client.</p>"},{"location":"chapter2/#managing-requests-and-responses","title":"Managing Requests and Responses","text":"<p>There are very many ways that clients can pass request data to a FastAPI API route. These include: - Path Parameters - Query Parameters - Headers e.t.c.</p> <p>Through such ways, we can obtain data from incoming requests to our APIs.</p>"},{"location":"chapter2/#parameter-type-declarations","title":"Parameter type declarations","text":"<p>All parameters in a FastAPI request are requiresd to have a type declaration via type hints. Primitive Python types such (<code>None</code>,<code>int</code>,<code>str</code>,<code>bool</code>,<code>float</code>), container types such as (<code>dict</code>,<code>tuples</code>,<code>dict</code>,<code>set</code>) and some other complex types are all supported. </p> <p>Additionally FastAPI also allows all types present within Python's <code>typing</code> module.  These data types represent common conventions in Python and are utilized for variable type annotations. They facilitate type checking and model validation during compilation. Examples include <code>Optional</code>, <code>List</code>, <code>Dict</code>, <code>Set</code>, <code>Union</code>, <code>Tuple</code>, <code>FrozenSet</code>, <code>Iterable</code>, and <code>Deque</code>.</p>"},{"location":"chapter2/#path-parameters","title":"Path Parameters","text":"<p>All request data supplied in the endpoint URL of a FastAPI API is acquired through a path parameter, thus rendering URLs dynamic. FastAPI adopts curly braces (<code>{}</code>) to denote path parameters when defining a URL. Once enclosed within the braces, FastAPI requires that they be provided as parameters to the route handler functions we establish for those paths.</p> path parameters<pre><code>#inside main.py\n@app.get('/greet/{username}')\nasync def greet(username:str):\n   return {\"message\":f\"Hello {username}\"}\n</code></pre> <p>In this example the <code>greet()</code> route handler function will require <code>username</code> which is annotated with <code>str</code> indicating that the username shall be a string. Sending a greetings to the user \"jona\" shall return the response shown below.</p> <p></p> <p>Just in we make a request to the route without the param,  </p>"},{"location":"chapter2/#query-parameters","title":"Query Parameters","text":"<p>These are key-value pairs provided at the end of a URL, indicated by a question mark (<code>?</code>). Just like path parameters, they also take in request data. Whenever we want to provide multiple query parameters, we use the ampersand (<code>&amp;</code>) sign.</p> Query params<pre><code># inside main.py\n\nuser_list = [\n   \"Jerry\",\n   \"Joey\",\n   \"Phil\"\n] \n\n@app.get('/search')\nasync def search_for_user(username:str):\n   for user in user_list:\n    if username in user_list :\n        return {\"message\":f\"details for user {username}\"}\n\n    else:\n        return {\"message\":\"User Not Found\"}\n</code></pre> <p>In this example, we've set up a route for searching users within a simple list. Notice that there are no path parameters specified in the route's URL. Instead, we're passing the <code>username</code> directly to our route handler, <code>search_for_user</code>. In FastAPI, any parameter passed to a route handler, like <code>search_for_user</code>, and is not provided in the path as a path param is treated as a query parameter. Therefore, to access this route, we need to use <code>/search?username=sample_name</code>, where <code>username</code> is the key and <code>sample_name</code> is the value.</p> <p>Let us save and test the example above. Saecrning for a user who exists returns the needed response.</p> <p></p> <p>And searching for a user who does not exist returns the following response.  </p>"},{"location":"chapter2/#optional-parameters","title":"Optional Parameters","text":"<p>There may also be cases when the API route can operate as needed even in the presence of a path or query param. In this case, we can make the parameters optional when annotating their types in the route handler functions. Forexample, our first example can be modified to the following: Optional Query Params<pre><code>from typing import Optional\n\n@app.get('/greet/')\nasync def greet(username:Optional[str]=\"User\"):\n   return {\"message\":f\"Hello {username}\"}\n</code></pre></p> <p>This time, we've made the <code>username</code> path parameter optional. We achieved this by removing it from the route definition. Additionally, we updated the type annotation for the <code>username</code> parameter in the <code>greet</code> route handler function to make it an optional string, with a default value of \"User\". To accomplish this, we're using the <code>Optional</code> type from Python's <code>typing</code> module. <pre><code>username:Optional[str]\n</code></pre></p> <p>When we save the example, we shall test it and get the following response. </p> <p>Note that this time if we do not provide the <code>username</code>, we shall get the default username of \"User\". </p>"},{"location":"chapter2/#request-body","title":"Request Body","text":"<p>Frequently, clients need to send data to the server for tasks like creating or updating resources through methods like POST, PATCH, PUT, DELETE, or for various other operations. FastAPI simplifies this process by enabling you to define a Pydantic model to establish the structure of the data being sent. Furthermore, it aids in validating data types using type hints. Let's delve into a straightforward example to illustrate this concept.</p> Request Body<pre><code># inside main.py\nfrom pydantic import BaseModel\n\n# the User model\nclass UserSchema(BaseModel):\n   username:str\n   email:str\n\n\n@app.post(\"/create_user\")\nasync def create_user(user_data:UserSchema):\n   new_user = {\n      \"username\" : user_data.username,\n      \"email\": user_data.email\n   }\n\n   users.append(new_user)\n\n   return {\"message\":\"User Created successfully\",\"user\":new_user}\n</code></pre> <p>What we have done in the above example is to create a Pydantic model by inheriting Pydantic's <code>BaseModel</code> class. On this class we have defined attributes <code>username</code> and <code>email</code> and also annotated them with the <code>str</code> type.  A simple Pydantic model<pre><code>class UserSchema(BaseModel):\n   username:str\n   email:str\n</code></pre></p> <p>Following that, have crafted an API route intended to handle a POST request at /create_user. The handler for this route accepts a parameter representing the user_data obtained from the client, with its type annotated as the Pydantic model UserSchema. <pre><code>create_user(user_data:UserSchema)\n</code></pre></p> <p>Using this <code>user_data</code>, we construct a new_user dictionary and append it to our users list. <pre><code>   new_user = {\n      \"username\" : user_data.username,\n      \"email\": user_data.email\n   }\n\n   users.append(new_user)\n</code></pre></p> <p>We finally return a response with the newly created <code>new_user</code> dictionary. </p> <pre><code>   return {\"message\":\"User Created successfully\",\"user\":new_user}\n</code></pre> <p>Let's test this. If we make the request without providing the request body, we should receive the following response. </p> <p>Please note that we will receive the <code>422 Unprocessable Entity</code> status code because FastAPI failed to retrieve data from the request body, as it has not been provided.</p> <p>When we provide the body without the required fields, we will receive the following output. </p> <p>We will receive the same output, but this time we will be notified that the required fields (<code>email</code>,<code>username</code>) for the data are missing.</p> <p>Let us now provide valid data.</p> <p></p> <p>Supplying valid values for the <code>email</code> and <code>username</code> fields will result in a successful response.</p>"},{"location":"chapter2/#note","title":"Note","text":"<p>There can indeed be scenarios that necessitate the use of all the features we've discussed. You can have an API route that accepts path, query, and optional parameters, and FastAPI is capable of handling such complexity seamlessly.</p>"},{"location":"chapter2/#request-headers","title":"Request Headers","text":"<p>During a request-response transaction, the client not only sends parameters to the server but also provides information about the context of the request's origin. This contextual information is crucial as it enables the server to customize the type of response it returns to the client.</p> <p>Common request headers include: - <code>User-Agent</code>: This string allows network protocol peers to identify the application responsible for the request, the operating system it's running on, or the version of the software being used.</p> <ul> <li> <p><code>Host</code>: This specifies the domain name of the server, and (optionally) the TCP port number on which the server is listening.</p> </li> <li> <p><code>Accept</code>: Informs the server about the types of data that can be sent back.</p> </li> <li> <p><code>Accept-Language</code>: This header informs the server about the preferred human language for the response.</p> </li> <li> <p><code>Accept-Encoding</code>: The encoding algorithm, usually a compression algorithm, that can be used on the resource sent back.</p> </li> <li> <p><code>Referer</code>: This specifies the address of the previous web page from which a link to the currently requested page was followed.</p> </li> <li> <p><code>Connection</code>: This header controls whether the network connection stays open after the current transaction finishes. </p> </li> </ul> <p>To access such headers, FastAPI provides us with the <code>Header</code> function giving us the ability to get the values of these headers using the exact names but in a snake-case syntax forexample, <code>User-Agent</code> is <code>user_agent</code>, <code>Accept-Encoding</code> is <code>accept_encoding</code> and so on. Let us take a look at a small code example.</p> <p>Request Headers<pre><code># inside main.py\n@app.get('/get_headers')\nasync def get_all_request_headers(\n    user_agent: Optional[str] = Header(None),\n    accept_encoding: Optional[str] = Header(None),\n    referer: Optional[str] = Header(None),\n    connection: Optional[str] = Header(None),\n    accept_language: Optional[str] = Header(None),\n    host: Optional[str] = Header(None),\n):\n    request_headers = {}\n    request_headers[\"User-Agent\"] = user_agent\n    request_headers[\"Accept-Encoding\"] = accept_encoding\n    request_headers[\"Referer\"] = referer\n    request_headers[\"Accept-Language\"] = accept_language\n    request_headers[\"Connection\"] = connection\n    request_headers[\"Host\"] = host\n\n    return request_headers\n</code></pre> We've started by importing the <code>Header</code> function from FastAPI into our route handler. Each header has been added and designated as an optional string. A default value has been assigned by invoking the <code>Header</code> function with <code>None</code> as a parameter.  Using the <code>None</code> argument allows the Header() function to declare the variable optionally, which aligns with best practices.</p> <pre><code>    user_agent: Optional[str] = Header(None)\n</code></pre> <p>we have then created a request_headers dictionary with the names of the headers as keys and the values as what we get by calling the <code>Header</code> function.</p> <p>Making a request to the <code>/get_headers</code> route shall return the following response depending on how you have made the request. For my case, </p>"},{"location":"chapter2/#conclusion","title":"Conclusion","text":"<p>In this chapter, we utilized FastAPI to construct a basic web server and delved into different methods of communicating and inputting data. We introduced concepts such as path and query parameters, along with request headers. Moving forward, the next chapter will focus on developing a straightforward CRUD API for managing book resources utilizing an in-memory database.</p>"},{"location":"chapter3/","title":"Building a CRUD REST API","text":""},{"location":"chapter3/#what-is-crud","title":"What is CRUD?","text":"<p>CRUD represents the four basic data operations:</p> <ul> <li> <p>Create (C):</p> </li> <li> <p>Objective: Add new data.</p> </li> <li> <p>Action: Insert a new record or entity.</p> </li> <li> <p>Read (R):</p> </li> <li> <p>Objective: Retrieve existing data.</p> </li> <li> <p>Action: Fetch data without modification.</p> </li> <li> <p>Update (U):</p> </li> <li> <p>Objective: Modify existing data.</p> </li> <li> <p>Action: Update attributes or values.</p> </li> <li> <p>Delete (D):</p> </li> <li>Objective: Remove data.</li> <li>Action: Delete a record or entity.</li> </ul> <p>CRUD operations are fundamental in data management, commonly used in applications dealing with data persistence. In FastAPI Beyond CRUD, the focus is on extending FastAPI capabilities beyond typical CRUD applications, exploring advanced features and use cases. But before diving into such aspects, let us build a simple CRUD API using FastAPI.</p>"},{"location":"chapter3/#a-simple-crud-api-implementation","title":"A simple CRUD API implementation","text":"<p>Our simple CRUD API will have a few endpoints to perform CRUD operations on a simple in-memory database of books. Here's a list of endpoints that we shall have in our CRUD API.</p> Endpoint Method Description /books Get Read all books /books POST Create a book /book/{book_id} GET Get a book by id /book/{book_id} PATCH Update a book by id /book/{book_id} DELETE Delete a book by id <p>The provided table describes various API endpoints, their associated HTTP methods, and their functionalities:</p> <ol> <li> <p><code>/books</code> - GET: Read all books</p> </li> <li> <p>Description: This endpoint is designed to retrieve information about all available books. When a client makes an HTTP GET request to <code>/books</code>, the server responds by providing details on all books in the system.</p> </li> <li> <p><code>/books</code> - POST: Create a book</p> </li> <li> <p>Description: To add a new book to the system, clients can make an HTTP POST request to <code>/books</code>. This operation involves creating and storing a new book based on the data provided in the request body.</p> </li> <li> <p><code>/book/{book_id}</code> - GET: Get a book by id</p> </li> <li> <p>Description: By making an HTTP GET request to <code>/book/{book_id}</code>, clients can retrieve detailed information about a specific book. The <code>book_id</code> parameter in the path specifies which book to fetch.</p> </li> <li> <p><code>/book/{book_id}</code> - PATCH: Update a book by id</p> </li> <li> <p>Description: To modify the information of a specific book, clients can send an HTTP PATCH request to <code>/book/{book_id}</code>. The <code>book_id</code> parameter identifies the target book, and the request body contains the updated data.</p> </li> <li> <p><code>/book/{book_id}</code> - DELETE: Delete a book by id</p> </li> <li>Description: This endpoint allows clients to delete a specific book from the system. By sending an HTTP DELETE request to <code>/book/{book_id}</code>, the book identified by <code>book_id</code> will be removed from the records.</li> </ol> <p>Now that we have a plan of our simple API, we can now build our simple CRUD API by adding the following code to <code>main.py</code>. We shall begin by creating a very simple list of books that we will use as our database.</p> in memory database of the books<pre><code>books = [\n    {\n        \"id\": 1,\n        \"title\": \"Think Python\",\n        \"author\": \"Allen B. Downey\",\n        \"publisher\": \"O'Reilly Media\",\n        \"published_date\": \"2021-01-01\",\n        \"page_count\": 1234,\n        \"language\": \"English\",\n    },\n    {\n        \"id\": 2,\n        \"title\": \"Django By Example\",\n        \"author\": \"Antonio Mele\",\n        \"publisher\": \"Packt Publishing Ltd\",\n        \"published_date\": \"2022-01-19\",\n        \"page_count\": 1023,\n        \"language\": \"English\",\n    },\n    {\n        \"id\": 3,\n        \"title\": \"The web socket handbook\",\n        \"author\": \"Alex Diaconu\",\n        \"publisher\": \"Xinyu Wang\",\n        \"published_date\": \"2021-01-01\",\n        \"page_count\": 3677,\n        \"language\": \"English\",\n    },\n    {\n        \"id\": 4,\n        \"title\": \"Head first Javascript\",\n        \"author\": \"Hellen Smith\",\n        \"publisher\": \"Oreilly Media\",\n        \"published_date\": \"2021-01-01\",\n        \"page_count\": 540,\n        \"language\": \"English\",\n    },\n    {\n        \"id\": 5,\n        \"title\": \"Algorithms and Data Structures In Python\",\n        \"author\": \"Kent Lee\",\n        \"publisher\": \"Springer, Inc\",\n        \"published_date\": \"2021-01-01\",\n        \"page_count\": 9282,\n        \"language\": \"English\",\n    },\n    {\n        \"id\": 6,\n        \"title\": \"Head First HTML5 Programming\",\n        \"author\": \"Eric T Freeman\",\n        \"publisher\": \"O'Reilly Media\",\n        \"published_date\": \"2011-21-01\",\n        \"page_count\": 3006,\n        \"language\": \"English\",\n    },\n]\n</code></pre> <p>Once we have that, we shall build our endpoints on the simple database.</p> All CRUD endpoints on the in-memory store<pre><code>from fastapi import FastAPI, status\nfrom fastapi.exceptions import HTTPException\nfrom pydantic import BaseModel\nfrom typing import List\n\n\napp = FastAPI()\n\nclass Book(BaseModel):\n    id: int\n    title: str\n    author: str\n    publisher: str\n    published_date: str\n    page_count: int\n    language: str\n\nclass BookUpdateModel(BaseModel):\n    title: str\n    author: str\n    publisher: str\n    page_count: int\n    language: str\n\n\n@app.get(\"/books\", response_model=List[Book])\nasync def get_all_books():\n    return books\n\n\n@app.post(\"/books\", status_code=status.HTTP_201_CREATED)\nasync def create_a_book(book_data: Book) -&gt; dict:\n    new_book = book_data.model_dump()\n\n    books.append(new_book)\n\n    return new_book\n\n\n@app.get(\"/book/{book_id}\")\nasync def get_book(book_id: int) -&gt; dict:\n    for book in books:\n        if book[\"id\"] == book_id:\n            return book\n\n    raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=\"Book not found\")\n\n\n@app.patch(\"/book/{book_id}\")\nasync def update_book(book_id: int,book_update_data:BookUpdateModel) -&gt; dict:\n\n    for book in books:\n        if book['id'] == book_id:\n            book['title'] = book_update_data.title\n            book['publisher'] = book_update_data.publisher\n            book['page_count'] = book_update_data.page_count\n            book['language'] = book_update_data.language\n\n            return book\n\n    raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=\"Book not found\")\n\n\n@app.delete(\"/book/{book_id}\",status_code=status.HTTP_204_NO_CONTENT)\nasync def delete_book(book_id: int):\n    for book in books:\n        if book[\"id\"] == book_id:\n            books.remove(book)\n\n            return {}\n\n    raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=\"Book not found\")\n</code></pre>"},{"location":"chapter3/#reading-all-books-http-get","title":"Reading All Books (HTTP GET)","text":"<p>This route responds to GET requests made to <code>/books</code>, providing a list of all books available in the application. It ensures that the response adheres to the <code>List[Book]</code> model, guaranteeing consistency with the structure defined by the <code>Book</code> model. Read all books<pre><code>class Book(BaseModel):\n    id: int\n    title: str\n    author: str\n    publisher: str\n    published_date: str\n    page_count: int\n    language: str\n\n\n@app.get(\"/books\", response_model=List[Book])\nasync def get_all_books():\n    return books\n</code></pre></p> <p>FastAPI significantly simplifies the process of returning any JSON serializable object as a response.</p>"},{"location":"chapter3/#note","title":"Note","text":"<p>JSON (JavaScript Object Notation) serialization involves transforming a data structure or object from a programming language (such as Python, JavaScript, or others) into a JSON-formatted string. This string representation can then be transmitted over a network or stored in a file, subsequently allowing deserialization back into the original data structure.</p> <p>In Python, the following data types are serializable:</p> <ul> <li>Lists</li> <li>Dictionaries</li> <li>Strings</li> <li>Tuples</li> <li>Booleans</li> <li>None</li> </ul> <p>This capability enables us to effortlessly respond with a list of book objects when issuing a <code>GET</code> request to <code>http://localhost:8000/books</code>, as illustrated below:</p> <p></p>"},{"location":"chapter3/#read-one-book-http-get","title":"Read one Book (HTTP GET)","text":"<p>To retrieve a single book by its ID, the FastAPI application employs the <code>read_book</code> function whenever a request is made to <code>book/{book_id}</code>. The <code>{book_id}</code> serves as a path parameter passed to the <code>read_book</code> function to locate the book with the corresponding ID. The process involves iterating through the list of books to verify the existence of a book with the provided ID. If the book is not found, an <code>HTTPException</code> is raised, signaling that the book resource is not available. Notably, FastAPI's <code>status</code> module facilitates access to status codes, enabling the use of codes such as <code>HTTP_404_NOT_FOUND</code> to indicate resource absence.</p> Retrieve a book by ID<pre><code>@app.get(\"/book/{book_id}\")\nasync def get_book(book_id: int) -&gt; dict:\n    for book in books:\n        if book[\"id\"] == book_id:\n            return book\n\n    raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=\"Book not found\")\n</code></pre> <p></p>"},{"location":"chapter3/#adding-a-new-book-http-post","title":"Adding a New Book (HTTP POST)","text":"<p>To facilitate the insertion of a new book into the system, the Book model is utilized to define the structure and constraints for creating a new book resource.</p> Pydantic model to define a book structure<pre><code>from pydantic import BaseModel\n\nclass Book(BaseModel):\n    id: int\n    title: str\n    author: str\n    publisher: str\n    published_date: str\n    page_count: int\n    language: str\n</code></pre> <p>Subsequently, an endpoint is established to enable the addition of a new book. This endpoint is designed to receive data formatted according to the specifications outlined by our Book model. Upon receipt, the incoming data undergoes validation to ensure its adherence to the predefined schema, thereby maintaining data integrity and security. Creating a new book<pre><code>@app.post(\"/books\", status_code=status.HTTP_201_CREATED)\nasync def create_a_book(book_data: Book) -&gt; dict:\n    new_book = book_data.model_dump()\n\n    books.append(new_book)\n\n    return new_book\n</code></pre></p> <p>Upon successful validation, the provided book data is appended to the list of existing books within the system. This systematic approach guarantees the integrity of the data being transmitted to the server. Furthermore, the endpoint is configured to return a status code of 201 (Created) upon successful creation of the new book, signifying the successful addition of the resource.</p> <p>The <code>Book</code> class ensures that the data sent to the server follows the expected format. If invalid data is submitted, the server responds with errors, as shown below when no data is sent:</p> <p></p> <p>Similarly, submitting incomplete or incorrect data results in validation errors:</p> <p></p> <p>On the other hand, sending valid JSON data to the server creates a new book record. The response includes a 201 Created status code:</p> <p></p>"},{"location":"chapter3/#note_1","title":"Note","text":"<p>It's crucial to use the right HTTP status code in each response. In this case, we use <code>status_code=201</code> to indicate the successful creation of a resource. The default status code is 200, which represents a standard successful response.</p>"},{"location":"chapter3/#update-a-book-http-patch","title":"Update a book (HTTP PATCH)","text":"<p>Let us look at the update endpoint. This is quite similar to the create endpoint as it allows data to be sent to the server via the PATCH HTTP method. But it also requires we provide the <code>book_id</code> of the book that we will be updating. we loop through the book list and find the book that matches the <code>book_id</code> as shown below:</p> Updating a Book<pre><code>@app.patch(\"/book/{book_id}\")\nasync def update_book(book_id: int,book_update_data:BookUpdateModel) -&gt; dict:\n\n    for book in books:\n        if book['id'] == book_id:\n            book['title'] = book_update_data.title\n            book['publisher'] = book_update_data.publisher\n            book['page_count'] = book_update_data.page_count\n            book['language'] = book_update_data.language\n\n            return book\n\n    raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=\"Book not found\")\n</code></pre> <p>If you notice, we have added the <code>book_update_data</code> parameter to our handler function and this is to be the validator for the data we shall use to update the book record. Notice this has a different schema called <code>BookUpdateModel</code>.</p> Pydantic model for updating a book<pre><code>class BookUpdateSchema(BaseModel):\n    title:str\n    author:str\n    publisher:str\n    page_count:int\n    language:str\n</code></pre> <p>Notice how we have neglected some of the fields that are available in our Book structure as shown in our list of books. This is to ensure that we only send those fields that will be updated. Let us update our book record.</p> <p></p> <p>Let us confirm if our book record has been updated successfully. To do so we are going to retrieve the book by its ID. The book record has been updated successfully.</p> <p></p>"},{"location":"chapter3/#delete-a-book-http-delete","title":"Delete a book (HTTP Delete)","text":"<p>Let us finally look at the deletion of a book record. This is carried out in the following example:</p> Delete a book<pre><code>from fastapi import HTTPException, status\n\n@app.delete(\"/book/{book_id}\", status_code=status.HTTP_204_NO_CONTENT)\nasync def delete_book(book_id: int):\n    for book in books:\n        if book[\"id\"] == book_id:\n            books.remove(book)\n            return {}\n\n    raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=\"Book not found\")\n</code></pre> <p>In this code, we loop through the books and find the book associated with the given <code>book_id</code>. We then remove it from the list of books using the <code>remove</code> list method. Notice that we return a 204 response status code, indicating that the book has been deleted and therefore no content is returned.</p> <p>Here is a visual example of the deletion process:</p> <p></p> <p>And just like that, we have created a CRUD REST API using a simple in memory database. </p>"},{"location":"chapter3/#conclusion","title":"Conclusion","text":"<p>In this chapter, we've developed a basic CRUD REST API using FastAPI. We utilized a simple in-memory database, represented by a Python list, to explore all CRUD actions. Moving forward, we'll restructure our project files to achieve a more organized and easily maintainable file structure.</p>"},{"location":"chapter4/","title":"Large Project Structure Using Routers","text":""},{"location":"chapter4/#current-folder-structure","title":"Current folder structure","text":"<p>So far, our project structure is quite simple:</p> Current Project structure<pre><code>\u251c\u2500\u2500 env/\n\u251c\u2500\u2500 main.py\n\u251c\u2500\u2500 requirements.txt\n</code></pre>"},{"location":"chapter4/#currrent-code-structure","title":"Currrent code structure","text":"<p>Additionally, our <code>main.py</code> file looks like this:</p> main.py<pre><code>from fastapi import FastAPI, Query\n\n\napp = FastAPI()\n\nbooks = [\n    {\n        \"id\": 1,\n        \"title\": \"Think Python\",\n        \"author\": \"Allen B. Downey\",\n        \"publisher\": \"O'Reilly Media\",\n        \"published_date\": \"2021-01-01\",\n        \"page_count\": 1234,\n        \"language\": \"English\",\n    },\n    # ... (other book entries)\n]\n\nclass Book(BaseModel):\n    id: int\n    title: str\n    author: str\n    publisher: str\n    published_date: str\n    page_count: int\n    language: str\n\nclass BookUpdateModel(BaseModel):\n    title: str\n    author: str\n    publisher: str\n    page_count: int\n    language: str\n\n@app.get(\"/books\", response_model=List[Book])\nasync def get_all_books():\n    return books\n\n\n@app.post(\"/books\", status_code=status.HTTP_201_CREATED)\nasync def create_a_book(book_data: Book) -&gt; dict:\n    new_book = book_data.model_dump()\n\n    books.append(new_book)\n\n    return new_book\n\n\n@app.get(\"/book/{book_id}\")\nasync def get_book(book_id: int) -&gt; dict:\n    for book in books:\n        if book[\"id\"] == book_id:\n            return book\n\n    raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=\"Book not found\")\n\n\n@app.patch(\"/book/{book_id}\")\nasync def update_book(book_id: int,book_update_data:BookUpdateModel) -&gt; dict:\n\n    for book in books:\n        if book['id'] == book_id:\n            book['title'] = book_update_data.title\n            book['publisher'] = book_update_data.publisher\n            book['page_count'] = book_update_data.page_count\n            book['language'] = book_update_data.language\n\n            return book\n\n    raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=\"Book not found\")\n\n\n@app.delete(\"/book/{book_id}\",status_code=status.HTTP_204_NO_CONTENT)\nasync def delete_book(book_id: int):\n    for book in books:\n        if book[\"id\"] == book_id:\n            books.remove(book)\n\n            return {}\n\n    raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=\"Book not found\")\n</code></pre>"},{"location":"chapter4/#restructuring-the-project","title":"Restructuring the project","text":"<p>The problem here is that if we add more code to this file, our code will become messy and hard to maintain beacuse all our code will be in one file <code>main.py</code>. To address this, we need to create a more organized project structure. To start, let's create a new folder called <code>src</code>, which will contain an <code>__init__.py</code> file to make it a Python package:</p> creating the src directory<pre><code>\u251c\u2500\u2500 env/\n\u251c\u2500\u2500 main.py\n\u251c\u2500\u2500 requirements.txt\n\u2514\u2500\u2500 src/\n`-- \u2514\u2500\u2500 __init__.py\n</code></pre> <p>Now, create a folder named <code>books</code> inside the <code>src</code> directory. Inside this folder, add an <code>__init__.py</code> file, a <code>routes.py</code> file, a <code>schemas.py</code> file, and a <code>book_data.py</code> file. The <code>routes.py</code> file will contain all the book routes, similar to what we created in the previous chapter. The <code>schemas.py</code> file will contain the schemas that are currently in our root directory.</p> creating the books directory<pre><code>\u251c\u2500\u2500 env/\n\u251c\u2500\u2500 main.py\n\u251c\u2500\u2500 requirements.txt\n\u2514\u2500\u2500 src/\n|-- \u2514\u2500\u2500 __init__.py\n`-- \u2514\u2500\u2500 books/\n    |-- \u2514\u2500\u2500 __init__.py\n    |-- \u2514\u2500\u2500 routes.py\n    |-- \u2514\u2500\u2500 schemas.py\n    `-- \u2514\u2500\u2500 book_data.py\n</code></pre> <p>First, let's move our <code>books</code> list from <code>main.py</code> to <code>book_data.py</code> inside the <code>books</code> directory.</p> src/books/book_data.py<pre><code>books = [\n    {\n        \"id\": 1,\n        \"title\": \"Think Python\",\n        \"author\": \"Allen B. Downey\",\n        \"publisher\": \"O'Reilly Media\",\n        \"published_date\": \"2021-01-01\",\n        \"page_count\": 1234,\n        \"language\": \"English\",\n    },\n    # ... (other book entries)\n]\n</code></pre> <p>Next, let's also move our Pydantic validation models from <code>main.py</code> to the <code>schemas.py</code> module inside the <code>books</code> directory.</p> src/books/schemas.py<pre><code>from pydantic import BaseModel\n\nclass Book(BaseModel):\n    id: int\n    title: str\n    author: str\n    publisher: str\n    published_date: str\n    page_count: int\n    language: str\n\nclass BookUpdateModel(BaseModel):\n    title: str\n    author: str\n    publisher: str\n    page_count: int\n    language: str\n</code></pre> <p>Now, let's update <code>routes.py</code> as follows:</p> src/books/routes.py<pre><code>from fastapi import APIRouter\nfrom src.books.book_data import books\nfrom src.books.schemas import BookSchema, BookUpdateSchema\n\nbook_router = APIRouter()\n\n@book_router.get(\"/books\", response_model=List[Book])\nasync def get_all_books():\n    return books\n\n\n@book_router.post(\"/books\", status_code=status.HTTP_201_CREATED)\nasync def create_a_book(book_data: Book) -&gt; dict:\n    new_book = book_data.model_dump()\n\n    books.append(new_book)\n\n    return new_book\n\n\n@book_router.get(\"/book/{book_id}\")\nasync def get_book(book_id: int) -&gt; dict:\n    for book in books:\n        if book[\"id\"] == book_id:\n            return book\n\n    raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=\"Book not found\")\n\n\n@book_router.patch(\"/book/{book_id}\")\nasync def update_book(book_id: int,book_update_data:BookUpdateModel) -&gt; dict:\n\n    for book in books:\n        if book['id'] == book_id:\n            book['title'] = book_update_data.title\n            book['publisher'] = book_update_data.publisher\n            book['page_count'] = book_update_data.page_count\n            book['language'] = book_update_data.language\n\n            return book\n\n    raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=\"Book not found\")\n\n\n@book_router.delete(\"/book/{book_id}\",status_code=status.HTTP_204_NO_CONTENT)\nasync def delete_book(book_id: int):\n    for book in books:\n        if book[\"id\"] == book_id:\n            books.remove(book)\n\n            return {}\n\n    raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=\"Book not found\")\n</code></pre>"},{"location":"chapter4/#introduction-to-fastapi-routers","title":"Introduction to FastAPI routers","text":"<p>What has been accomplished is the division of our project into modules using routers. FastAPI routers allow easy modularization of our API by grouping related API routes together. Routers function similarly to FastAPI instances (similar to what we have in <code>main.py</code>). As our project expands, we will introduce additional API routes, and all of them will be organized into modules grouping related functionalities.</p> <p>Let's enhance our <code>main.py</code> file to adopt this modular structure:</p> Including the book router to our app<pre><code># Inside main.py title\nfrom fastapi import FastAPI\nfrom src.books.routes import book_router\n\nversion = 'v1'\n\napp = FastAPI(\n    title='Bookly',\n    description='A RESTful API for a book review web service',\n    version=version,\n)\n\napp.include_router(book_router,prefix=f\"/api/{version}/books\", tags=['books'])\n</code></pre> <p>Firstly, a variable called <code>version</code> has been introduced to hold the API version. Next, we import the <code>book_router</code> created in the previous example. Using our FastAPI instance, we include all endpoints created with it by calling the <code>include_router</code> method.</p> <p>Arguments added to the FastAPI instance are:</p> <ul> <li><code>title</code>: The title of the API.</li> <li><code>description</code>: The description of the API.</li> <li><code>version</code>  : The version of the API.</li> </ul> <p>While these arguments may not be particularly useful at present, they become valuable when we explore API documentation with OpenAPI.</p> <p>Furthermore, we added the following arguments to the include_router method:</p> <ul> <li> <p><code>prefix</code>: The path through which all related endpoints can be accessed. In our case, it's named the /{version}/books prefix, resulting in /v1/books or /v2/books based on the application version. This implies that all book-related endpoints can be accessed using http://localhost:8000/api/v1/books.</p> </li> <li> <p><code>tags</code>: The list of tags associated with the endpoints that fall within a given router.</p> </li> </ul> <p>Let us now now move all the source code in our <code>main.py</code> module to <code>src/__init__.py</code>. (delete your <code>main.py</code>)</p> <p>src/__init__.py<pre><code>from fastapi import FastAPI\nfrom src.books.routes import book_router\n\nversion = 'v1'\n\napp = FastAPI(\n    title=\"Bookly\",\n    description=\"A REST API for a book review web service\",\n    version= version,\n    lifespan=life_span\n)\n\napp.include_router(book_router, prefix=f\"/api/{version}/books\", tags=['books'])\n</code></pre> Having moved our code, we shall now have this folder structure. modified directory structure<pre><code>\u251c\u2500\u2500 requirements.txt\n\u251c\u2500\u2500 run.py\n\u2514\u2500\u2500 src\n|-- \u251c\u2500\u2500 books\n|-- \u2502   \u251c\u2500\u2500 book_data.py\n|-- \u2502   \u251c\u2500\u2500 __init__.py\n|-- \u2502   \u251c\u2500\u2500 routes.py\n|-- \u2502   \u251c\u2500\u2500 schemas.py\n|-- \u2502   \u251c\u2500\u2500 book_data.py\n`-- \u2514\u2500\u2500 __init__.py\n</code></pre></p> <p>Once more, let's start our server using <code>fastapi dev src/</code>. Pay attention to the fact that this time we're specifying<code>src/</code>. This is because we've designated it as a package by including <code>__init__.py</code>. Additionally, our FastAPI instance named <code>app</code> is created there. Consequently, FastAPI will utilize it to operate our application.</p> <p>Runnning our application will the following terminal output. Running the server<pre><code>INFO     Using path src                                                                                                                                     \nINFO     Resolved absolute path /home/jod35/Documents/fastapi-beyond-CRUD/src                                                                               \nINFO     Searching for package file structure from directories with __init__.py files                                                                       \nINFO     Importing from /home/jod35/Documents/fastapi-beyond-CRUD                                                                                           \n\n \u256d\u2500 Python package file structure \u2500\u256e                                                                                                                        \n \u2502                                 \u2502                                                                                                                        \n \u2502  \ud83d\udcc1 src                         \u2502                                                                                                                        \n \u2502  \u2514\u2500\u2500 \ud83d\udc0d __init__.py             \u2502                                                                                                                        \n \u2502                                 \u2502                                                                                                                        \n \u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f                                                                                                                        \n\nINFO     Importing module src                                                                                                                               \nINFO     Found importable FastAPI app                                                                                                                       \n\n \u256d\u2500 Importable FastAPI app \u2500\u256e                                                                                                                               \n \u2502                          \u2502                                                                                                                               \n \u2502  from src import app     \u2502                                                                                                                               \n \u2502                          \u2502                                                                                                                               \n \u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f                                                                                                                               \n</code></pre></p>"},{"location":"chapter4/#note","title":"Note:","text":"<p>The current organization of our API endpoints is as follows:</p> Endpoint Method Description /api/v1/books GET Read all books /api/v1/books POST Create a book /api/v1/books/{book_id} GET Get a book by ID /api/v1/books/{book_id} PATCH Update a book by ID /api/v1/books/{book_id} DELETE Delete a book by ID"},{"location":"chapter4/#conclusion","title":"Conclusion","text":"<p>This chapter has focused on creating a folder structure that we can use even when our project gets bigger. In the next chapter, we shall focus on database and look at how we can persist our data and use Python to manage a relational database.</p>"},{"location":"chapter5/","title":"Databases with SQLModel","text":"<p>In the preceding chapter, we developed a functional CRUD API that operated on a simple in-memory database, represented by a Python list. However, in real-world applications, it's essential to use a persistent database to store all necessary data.</p>"},{"location":"chapter5/#choosing-a-database-for-fastapi","title":"Choosing a Database for FastAPI","text":"<p>FastAPI supports various types of databases, including relational/SQL databases and non-relational/NoSQL databases. Depending on your specific requirements, you can opt for either type.</p> <p>For this series, we'll focus on using a relational database, specifically PostgreSQL. PostgreSQL is a widely used free and open-source relational database management system, offering numerous benefits:</p> <p>While using PostgreSQL, we shall need to choose a way to interact with the database using the Python Language. That introduces us to the concept of an Object Relational mapper.</p>"},{"location":"chapter5/#explaining-an-object-relational-mapper-orm","title":"Explaining an Object-Relational Mapper (ORM)","text":"<p>An Object-Relational Mapper (ORM) serves as a translator between a programming language, such as Python, and a database, like PostgreSQL or MySQL.</p> <p>In simpler terms, think of an ORM as an interpreter in a conversation where one person speaks English (Python) and the other speaks French (database). The ORM understands both languages, allowing you to interact with the database using familiar Python code without needing to understand the intricacies of how the database works internally.</p>"},{"location":"chapter5/#how-it-works","title":"How it Works:","text":"<ol> <li> <p>Mapping Objects to Tables: You create Python classes to represent tables in the database. Each object of these classes corresponds to a row in the database table.</p> </li> <li> <p>Interacting with Data: You can then interact with these Python objects as if they were regular objects in your code, like setting attributes and calling methods.</p> </li> <li> <p>Behind the Scenes: When you perform operations on these objects, like saving or deleting, the ORM translates these actions into the appropriate SQL queries that the database understands.</p> </li> <li> <p>Data Conversion: The ORM handles converting Python data types into database-specific types and vice versa, ensuring compatibility between the two.</p> </li> </ol> <p>An ORM simplifies the process of working with databases by allowing you to focus on your application's logic in Python, rather than getting bogged down in SQL queries and database management details. It acts as a bridge between the object-oriented world of programming and the relational world of databases.</p> <p>There are several different ORM solutions available for Python, but the most popular is SQLAlchemy. SQLAlchemy simplifies database access and manipulation by providing an ORM for mapping Python objects to database tables and offering a high-level SQL expression language for querying databases. While SQLAlchemy is a powerful tool on its own, there's an ORM solution that seamlessly integrates SQLAlchemy with Pydantic, the data validation library discussed in previous chapters.</p>"},{"location":"chapter5/#creating-a-database","title":"Creating a Database","text":"<p>In this series, we will make use of SQLModel, a library tailored for FastAPI. Interestingly, it was developed by the same individual who created FastAPI.</p> <p>Let's initiate the database setup. Setting up a database can be intricate, often involving multiple steps. Fortunately, numerous options are available that simplify the database creation process without extensive configuration.</p> <p>Throughout this course, I'll utilize Neon, a free fully managed PostgreSQL database with a generous free tier. With Neon, we can swiftly create a database and get started without delay.</p> <p></p> <p>Once you have created your free account on Neon, you can create a new project and in it, you will also create your new database.</p> <p></p> <p>Once you have created your database, you can then go ahead and copy your connection details.  </p> <p>After, Create a file called <code>.env</code> in which we shall store our project configurations as secrets. (This file is important and should not be added to version control) In your <code>.env</code> file, paste the database connection URL you have obtained from Neon. We are going to create an environment variable called <code>DATABASE_URL</code> with the value of our URL.</p> Adding the DATABASE URL environment variable<pre><code>DATABASE_URL=postgresql://bookdb_owner:w8JK2sCASYBc@ep-rough-block-a554nxl6.us-east-2.aws.neon.tech/bookdb?sslmode=require\n</code></pre> <p>At this point, your folder structure needs to look something like this: Current Project Structure<pre><code>|__ .env\n\u251c\u2500\u2500 env/\n\u251c\u2500\u2500 main.py\n\u251c\u2500\u2500 requirements.txt\n\u2514\u2500\u2500 schemas.py\n\u2514\u2500\u2500 src/\n|-- \u2514\u2500\u2500 __init__.py\n`-- \u2514\u2500\u2500 books/\n    |-- \u2514\u2500\u2500 __init__.py\n    |-- \u2514\u2500\u2500 routes.py\n    |-- \u2514\u2500\u2500 schemas.py\n    `-- \u2514\u2500\u2500 book_data.py\n</code></pre></p>"},{"location":"chapter5/#settings-management-with-pydantic","title":"Settings Management With Pydantic","text":"<p>With that in place, we can now set up our configurations so that we can read them out from anywhere within our application. Let us begin by creating a <code>config.py</code> file that contains the configuration variables that will be used in this series.</p> <p>We are going to rely on Pydantic to read our environment variables. Pydantic alone will not help us; we shall need to install <code>pydantic-settings</code>, a library that is based on Pydantic to help us with the specific role of reading environment variables from our <code>.env</code> file. </p> <p>So let us start by installing </p> <p>Install Pydantic settings<pre><code>$ pip install pydantic-settings\n</code></pre> After installing <code>pydantic-settings</code>, let us now go ahead and create a file called <code>config.py</code> at the root of our project. Inside that file, add the following code.</p> src/config.py<pre><code># inside src/config.py\nfrom pydantic_settings import BaseSettings, SettingsConfigDict\n\n\nclass Settings(BaseSettings):\n    DATABASE_URL: str \n\n    model_config = SettingsConfigDict(\n        env_file=\".env\", \n        extra=\"ignore\"\n    )\n</code></pre>"},{"location":"chapter5/#explanation","title":"Explanation:","text":"<p>In the provided code snippet, we've performed the following actions:</p> <ol> <li>We are importing the <code>BaseSettings</code> class from <code>pydantic_settings</code>.</li> <li>Creating a subclass called <code>Settings</code>, inheriting from <code>BaseSettings</code>.</li> <li>Defining an attribute named <code>DATABASE_URL</code> with a type annotation of <code>str</code>.</li> <li>To modify our configuration to read from the <code>.env</code> file, we modified the <code>model_config</code> attribute of the <code>Settings</code> class which is one to help us with modifying the configuration of any pydantic model class. This is set to an instance of the <code>SettingsConfigDict</code> class which enables us to read the configuration from the <code>.env</code> file. This is by simply setting the <code>env_file</code> argument to the name of the <code>.env</code> file. We have also added the <code>extra</code> argument and given it a value of <code>ignore</code> as we may want to ignore any extra attributes provided within our <code>Settings</code> class.</li> </ol> <p>This configuration allows us to read the <code>DATABASE_URL</code> from the environment variables.  Let's observe how this configuration operates. We'll initiate a Python interpreter shell for testing:</p> Reading environment variable from .env<pre><code>$ python3\nPython 3.10.12 (main, Nov 20 2023, 15:14:05) [GCC 11.4.0] on linux\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\n&gt;&gt;&gt; from config import Settings\n&gt;&gt;&gt; settings = Settings()\n&gt;&gt;&gt; settings.DATABASE_URL\n'postgresql://bookdb_owner:w8JK2sCASYBc@ep-rough-block-a554nxl6.us-east-2.aws.neon.tech/bookdb?sslmode'\n&gt;&gt;&gt; \n</code></pre> <p>In the above demonstration, we start by importing the <code>Settings</code> class from the <code>config.py</code> file. Subsequently, we instantiate a <code>settings</code> object. Utilizing this <code>settings</code> object, we access and retrieve the <code>DATABASE_URL</code> setting. Upon calling it, our database URL will be displayed in the console. Note that this shall work because we currently have the <code>DATABASE_URL</code> setting in our <code>.env</code> file.</p> <p>Once this has been implemented, let us then add the following line to <code>config.py</code>. Create a Config object<pre><code>from pydantic_settings import BaseSettings, SettingsConfigDict\n\nclass Settings(BaseSettings):\n    DATABASE_URL: str \n\n    model_config = SettingsConfigDict(\n        env_file=\".env\", \n        extra=\"ignore\"\n    )\n\n# add this line    \nConfig = Settings()\n</code></pre> We add this line so that we don't have to create a new instance of our <code>Settings</code> class whenever we shall need to access environment variables. From now on, we shall shall just have to import the <code>Config</code> variable and use it.</p>"},{"location":"chapter5/#creating-database-models-with-sqlmodel","title":"Creating database models with SQLModel","text":"<p>Alright, let us now connect to our database and also create our table in it. Let us install <code>sqlmodel</code>. Installing SQLModel<pre><code>$ pip install sqlmodel\n</code></pre></p> <p>Once we have <code>sqlmodel</code> installed, let us now create a database model using it. to start, we will create a file named models.py inside the <code>books</code> directory.</p> <p>New folder structure with models.py<pre><code>|__ .env\n\u251c\u2500\u2500 env/\n\u251c\u2500\u2500 main.py\n\u251c\u2500\u2500 requirements.txt\n\u2514\u2500\u2500 schemas.py\n\u2514\u2500\u2500 src/\n|-- \u2514\u2500\u2500 __init__.py\n`-- \u2514\u2500\u2500 books/\n    |-- \u2514\u2500\u2500 __init__.py\n    |-- \u2514\u2500\u2500 routes.py\n    |-- |__ models.py\n    |-- \u2514\u2500\u2500 schemas.py\n    `-- \u2514\u2500\u2500 book_data.py\n</code></pre> Inside <code>models.py</code>, add the following code.  Creating the book database model in src/books/models.py<pre><code>from sqlmodel import SQLModel, Field, Column\nimport sqlalchemy.dialects.postgresql as pg\nimport uuid\n\nclass Book(SQLModel , table=True):\n    __tablename__ = \"books\"\n\n    uid:uuid.UUID = Field(\n        sa_column=Column(\n            pg.UUID,\n            primary_key=True,\n            unique=True,\n            nullable=False\n        )\n    )\n\n    title: str\n    author: str\n    publisher: str\n    published_date: str\n    page_count: int\n    language:str\n    created_at: datetime = Field(sa_column=Column(pg.TIMESTAMP, default=datetime.now))\n    updated_at:datetime = Field(sa_column=Column(pg.TIMESTAMP, default=datetime.now))\n\n    def __repr__(self) -&gt; str:\n        return f\"&lt;Book {self.title}&gt;\"\n</code></pre></p>"},{"location":"chapter5/#explanation_1","title":"Explanation","text":"<p>IN the above code, we have defined a database model using <code>SQLModel</code>. Here are the steps we took.  1. We imported the <code>SQLModel</code>, <code>Field</code>, <code>Column</code> from sqlmodel. 2. We import <code>sqlalchemy.dialects.postgresql</code>as <code>pg</code> to allow us access the PostgreSQL-specific column types. 3. In the model definition, we create a <code>Book</code> class that inherits from <code>SQLModel</code>, we then also add the <code>table</code> parameter to the class and set it to <code>True</code>to inidicate that the class is going to represent a database table.</p> <p>Note</p> <p>All SQLModel models are pydantic tables and therefore can be used for data validation.</p> <ol> <li>Inside the class, several attributes are defined:<ul> <li><code>uid</code>: A universally unique identifier (UUID) for each book. We use the <code>Field</code> function, to add some details or attributes to it. It's also specified as the primary key column <code>(primary_key=True)</code>, with a default value generated by <code>uuid.uuid4()</code>, and it's unique and not nullable.</li> </ul> </li> </ol> <p>Note</p> <p>To make our primary key store UUIDs, we have chosen to use the PostgreSQL UUID type and we achive this by using the sa_column argument in the Field function. Using SQLALchemy's Column class we then specify the type of the field.</p> <ul> <li> <p><code>title</code>, <code>author</code>, <code>publisher</code>, <code>published_date</code>, <code>page_count</code>, <code>language</code>: These attributes represent various properties of a book, such as title, author, publisher, etc. They are all specified as strings (str) or integers (int) and will be columns in the database table.</p> </li> <li> <p><code>created_at</code> and <code>updated_at</code> represent timestamps at which a book record was created or updated. Note that we are also going in detail about defining the PostgreSQL column types as <code>pg.TIMESTAMP</code>. We also specify that we want to keep track of the </p> </li> <li> <p>def repr(self) -&gt; str: This is a special method that defines how instances of the <code>Book</code> class are represented as strings. In this case, it returns a string containing the title of the book, enclosed in angle brackets and preceded by <code>Book</code>.</p> </li> </ul>"},{"location":"chapter5/#connecting-to-databases","title":"Connecting to databases","text":"<p>Let us add a directory in our <code>src</code> folder and call it <code>db</code> (short for database). we shall make it a normal Python package by adding the <code>__init__.py</code> file. After, we shall go ahead and add a Python file called <code>main.py</code> and we shall then add the following code.</p> src/db/main.py<pre><code>from sqlmodel import create_engine, text\nfrom sqlalchemy.ext.asyncio import AsyncEngine\nfrom src.config import Config\n\nengine = AsyncEngine(create_engine(\n    url=Config.DATABASE_URL,\n    echo=True\n))\n\n\nasync def initdb():\n    \"\"\"create a connection to our db\"\"\"\n\n    async with engine.begin() as conn:\n        statement = text(\"select 'Hello World'\")\n\n        result = await conn.execute(statement)\n\n        print(result)\n</code></pre>"},{"location":"chapter5/#explanation_2","title":"Explanation","text":"<ol> <li> <p>We begin by importing the necessary objects from the libraries they belong to.</p> <p>Importing necessary objects<pre><code>from sqlmodel import create_engine, text\nfrom sqlalchemy.ext.asyncio import AsyncEngine\nfrom src.config import Config\n</code></pre> <code>create_engine</code> is a function that enables to connect to a database when we need. <code>text</code> is a function that helps us generate plain text SQL statements that we can run against a database when we connect to it. <code>AsyncEngine</code> is a class for creating asynchronous engine objects. We shall look at how we shall use it in a moment. <code>Config</code> is the settings objects we created above. This will allow us access our configurations.</p> </li> <li> <p>We then create the <code>engine</code> object. This will allow us to connect to the database when we need to. (We will look at how we will use it later.)     Creating the engine object<pre><code>engine = AsyncEngine(create_engine(\n    url=Config.DATABASE_URL,\n    echo=True\n))\n</code></pre>     This object is created by calling the <code>create_engine()</code> function. In the function call, we also add two important argumnents. The first argument is the <code>url</code> to the database to connect to. In this case, we shall use the <code>DATABASE_URL</code> value from the configuration we set up above. This is accessed on the <code>Config</code> object created in our settings.</p> <p>The second argument is the <code>echo</code> argument, this allows us to log SQL statements that will be executed in the database everytime they are executed. We finally create this object inside the <code>AsyncEngine</code> class because we want to be able to interact with the database using an asynchronous DBAPI. </p> </li> </ol> <p>Note</p> <p>A DBAPI (Database Application Programming Interface) is simply a medium through which the Python programming language can connect to the database server.</p> <ol> <li> <p>Finally, we create a function called <code>initdb</code> which is responsible for connecting to the database and executing a simple SQL statement. </p> Connecting to the database and running an SQL Query<pre><code>async def initdb():\n    \"\"\"create a connection to our db\"\"\"`\n\n    async with engine.begin() as conn:\n    statement = text(\"select 'Hello World'\")\n\n    result = await conn.execute(statement)\n\n    print(result.all())`\n</code></pre> <p>Inside the <code>initdb</code> function, we begin by creating a connection object <code>conn</code> using an async context manager. (created with <code>async with engine.begin()</code>). We then create a plain text SQL statement and call the <code>text</code> function.</p> <p>The result of the statement is what we access through the <code>result</code> object which we finally print to our terminal when we call the <code>all</code> method on it.</p> </li> </ol>"},{"location":"chapter5/#lifespan-events-in-fastapi","title":"Lifespan events in FastAPI","text":"<p>In FastAPI, we have the flexibility to specify operations to execute prior to the application receiving requests, as well as when it concludes receiving them. This capability is crucial in situations where executing such operations may be resource-intensive and potentially degrade user experience. Examples of such operations include establishing database connections and loading AI models. For our demonstration, we'll focus on establishing a database connection before the application starts. If this concept isn't clear, let's start by examining a brief example.</p> <p>In the <code>__init__.py</code> file at the root of the <code>src</code> directory, let us modify the code as shown below.</p> src/__init__.py<pre><code>from fastapi import FastAPI\nfrom src.books.routes import book_router\nfrom contextlib import asynccontextmanager\n\n\n#the lifespan event\n@asynccontextmanager\nasync def lifespan(app: FastAPI):    \n    print(\"Server is starting...\")\n    yield\n    print(\"server is stopping\")\n\n\n\napp = FastAPI(\n    lifespan=lifespan # add the lifespan event to our application\n)\n\napp.include_router(\n    book_router,\n    prefix=\"/books\",\n    tags=['books']\n)\n</code></pre>"},{"location":"chapter5/#explanation_3","title":"Explanation","text":"<p>Let's create an async function called lifespan. This function will be decorated with asynccontextmanager from the contextlib module in Python. Inside this function, there will be two print statements, separated by a <code>yield</code> statement.</p> <p>The code before the <code>yield</code> statement will execute first (when the server starts), followed by the code after the <code>yield</code> statement, which will execute last (when the server stops).</p> <p>This function is a lifespan event because it runs once before the application starts and then continues throughout the application's lifespan.</p> <p>Now, if we stop the server by pressing CTRL+C and then restart it, the following output will be logged in the terminal. Demo of executing tasks on server starting<pre><code>$ python3 run.py \nINFO:     Will watch for changes in these directories: ['/home/jod35/Documents/fastapi-beyond-CRUD']\nINFO:     Uvicorn running on http://127.0.0.1:8000 (Press *CTRL+C* to quit)\nINFO:     Started reloader process [18506] using WatchFiles\nINFO:     Started server process [18508]\nINFO:     Waiting for application startup.\nserver is starting...\n</code></pre> At the server's start, you'll observe the text <code>server is starting</code> printed in the terminal. After halting the server using Ctrl+C, you should see the subsequent output Demo of executing tasks on server being stopped<pre><code>INFO:     Application startup complete.\n^CINFO:     Shutting down\nINFO:     Waiting for application shutdown.\nserver is stopping\nINFO:     Application shutdown complete.\nINFO:     Finished server process [18669]\n$\n</code></pre></p> <p>Now that we grasp how lifespan events function, let's integrate our <code>init_db</code> function to establish a connection to the PostgreSQL database.</p> <p>Update the lifespan function in <code>src/__init__.py</code> to include the following code.</p> <p>Connecting to the database using the lifespan function<pre><code>...\nfrom src.db.main import initdb\n\n\n@asynccontextmanager\nasync def lifespan(app: FastAPI):    \n    await initdb()\n    yield\n    print(\"server is stopping\")\n</code></pre> Upon saving, you'll observe the following output in your terminal.</p> <p>Executing the select query<pre><code>INFO:     Started server process [21034]\nINFO:     Waiting for application startup.\n2024-05-06 11:50:41,802 INFO sqlalchemy.engine.Engine BEGIN (implicit)\n2024-05-06 11:50:41,803 INFO sqlalchemy.engine.Engine select 'Hello World'\n2024-05-06 11:50:41,803 INFO sqlalchemy.engine.Engine [generated in 0.00015s] ()\n[('Hello World',)]\n2024-05-06 11:50:41,803 INFO sqlalchemy.engine.Engine COMMIT\n</code></pre> This code establishes a connection to the database and executes a SELECT statement, which will return the string \"Hello World\" as demonstrated in the provided output.</p>"},{"location":"chapter5/#creating-database-tables","title":"Creating database tables","text":"<p>Let's update the code in <code>src/db/main.py</code> to incorporate our custom lifespan event into the database model, utilizing the <code>Book</code> model. We'll then utilize SQLmodel to generate the necessary database tables based on this model.</p> Creating the database table using SQLModel<pre><code># Inside src/db/main.py\nfrom sqlmodel import create_engine, text\nfrom sqlalchemy.ext.asyncio import AsyncEngine\nfrom src.config import Config\nfrom sqlmodel import SQLModel\nfrom src.books.models import Book\n\n\nengine = AsyncEngine(create_engine(\n    url=Config.DATABASE_URL,\n    echo=True\n))\n\n\nasync def initdb():\n    \"\"\"create our database models in the database\"\"\"\n\n    async with engine.begin() as conn:\n        await conn.run_sync(SQLModel.metadata.create_all)\n</code></pre> <p>In the above code, we began with importing the <code>Book</code> model from <code>src/books/models</code>. After, we then modify the <code>initdb()</code> function by adding the following: using SQLModel to create all tables in our database<pre><code>async with engine.begin() as conn:\n    await conn.run_sync(SQLModel.metadata.create_all)\n</code></pre></p> <p>In this code snippet, we utilize an asynchronous context manager with <code>engine.begin()</code>, enabling us to create a transactional context to interact with our database. Within this context, we execute <code>conn.run_sync(SQLModel.metadata.create_all()</code>.</p> <p>Here, <code>SQLModel.metadata</code> encompasses all the metadata linked with SQLModel. By invoking the <code>create_all()</code> method on this metadata object, any tables present in the metadata but absent in the database will be created.</p> <p>Note  - <code>conn.run_sync()</code> is an asynchronous function that we utilize to run synchronous functions such as <code>SQLModel.metadata.create_all()</code>.</p> <p>With that said, let us save the file and have a look at our terminal output.  SQL running to create our database table from the defined model<pre><code>INFO:     Waiting for application startup.\n2024-05-06 12:13:21,042 INFO sqlalchemy.engine.Engine BEGIN (implicit)\n2024-05-06 12:13:21,042 INFO sqlalchemy.engine.Engine PRAGMA main.table_info(\"books\")\n2024-05-06 12:13:21,042 INFO sqlalchemy.engine.Engine [raw sql] ()\n2024-05-06 12:13:21,043 INFO sqlalchemy.engine.Engine PRAGMA temp.table_info(\"books\")\n2024-05-06 12:13:21,043 INFO sqlalchemy.engine.Engine [raw sql] ()\n2024-05-06 12:13:21,044 INFO sqlalchemy.engine.Engine \nCREATE TABLE books (\n        uid UUID NOT NULL, \n        title VARCHAR NOT NULL, \n        author VARCHAR NOT NULL, \n        publisher VARCHAR NOT NULL, \n        published_date VARCHAR NOT NULL, \n        page_count INTEGER NOT NULL, \n        language VARCHAR NOT NULL, \n        created_at TIMESTAMP, \n        updated_at TIMESTAMP, \n        PRIMARY KEY (uid), \n        UNIQUE (uid)\n)\n\n\n2024-05-06 12:13:21,044 INFO sqlalchemy.engine.Engine [no key 0.00014s] ()\n2024-05-06 12:13:21,086 INFO sqlalchemy.engine.Engine COMMIT\n</code></pre> Running the code above shall allow us to create the table in the database also logging the SQL query in the terminal as shown above. </p>"},{"location":"chapter5/#conclusion","title":"Conclusion","text":"<p>In this chapter, we've introduced persistence to our data by employing a relational database management system (PostgreSQL). Additionally, we've explored the utilization of Pydantic for configuration settings. We've also examined SQLModel, an ORM that combines Pydantic and SQLAlchemy to manage relational databases effectively. Our database, which stores book data, is now operational. Looking ahead, I've outlined the CRUD actions for our persistent database in the following chapter.</p>"},{"location":"chapter6/","title":"Finishing Up the CRUD","text":""},{"location":"chapter6/#creating-a-service-class","title":"Creating a service class","text":"<p>In this chapter, we will focus on creating a dedicated service file to house the essential logic required for executing CRUD operations using our PostgreSQL database. The primary objective is to abstract away database interactions from our API routes, enhancing code readability and maintainability.</p> <p>We will construct a class within this service file, which will serve as a centralized point for invoking all methods related to managing our book data.</p> <p>To initiate this process, let's commence by creating the file <code>service.py</code> within the <code>src/books/</code> directory. /src/books/service.py<pre><code>from sqlmodel.ext.asyncio.session import AsyncSession\nfrom src.books.models import Book\nfrom src.books.schemas import BookCreateModel\nfrom sqlmodel import select\n\n\nclass BookService:\n    \"\"\"\n    This class provides methods to create, read, update, and delete books\n    \"\"\"\n\n    pass\n</code></pre></p> <p>We call this class <code>BookService</code> as it shall be called only when managing data about books. </p>"},{"location":"chapter6/#read-all-books","title":"Read all books","text":"<p>Let us begin by adding the method <code>get_all_books</code> that is responsible for getting all the books from the database.</p> Get all books<pre><code>... #the rest of the BookService class\nasync def get_all_books(self, session: AsyncSession):\n    \"\"\"\n    Get a list of all books\n\n    Returns:\n        list: list of books\n    \"\"\"\n    statement = select(Book).order_by(desc(Book.created_at))\n\n    result = await session.exec(statement)\n\n    return result.all()\n</code></pre> <p>To start, we craft a query utilizing the <code>select</code> function from SQLModel, initiating an SQL SELECT operation on our Books table. Subsequently, we sort the books based on their creation date (created_at) via the order_by method.</p> <p>This constructed statement is subsequently executed through the <code>session</code> object. The resulting <code>result</code> object will return a list of books obtained by invoking the <code>all</code> method.</p>"},{"location":"chapter6/#creating-a-new-book","title":"Creating a new Book","text":"<p>Let us now add the method for creating a new book Create a book<pre><code>... # rest of the BookService class\nasync def create_book(self, book_data: BookCreateModel, session:AsyncSession):\n    \"\"\"\n    Create a new book\n\n    Args:\n        book_data (BookCreateModel): data to create a new\n\n    Returns:\n        Book: the new book\n    \"\"\"\n    book_data_dict = book_data.model_dump()\n\n    new_book = Book(\n        **book_data_dict\n    )\n\n    new_book.published_date = datetime.strptime(book_data_dict['published_date'],\"%Y-%m-%d\")\n\n    session.add(new_book)\n\n    await session.commit()\n\n    return new_book\n</code></pre> The <code>create_book</code> method is responsible for adding a new book to the database using the provided book data. Specifically, <code>book_data</code> must adhere to the structure defined by a Pydantic model called <code>BookCreateModel</code>, which we'll soon create in our <code>src/books/schema.py</code> directory.</p> <p>To create a new book record, we begin by initializing a new instance of the Book database model. This is achieved by unpacking <code>book_data</code>, which we convert into a Python dictionary utilizing the model_dump method.</p> <p>Following this, we utilize our <code>session</code> object to add the new book record to the database via <code>session.add</code>. Finally, we commit the transaction to ensure that the changes are persisted in the database, accomplished with <code>session.commit</code>, not forgetting to return the newly created book record.</p> <p>Before we proceed, we need to add the <code>BookCreateSchema</code> class to <code>src/books/schemas.py</code> </p> <p>Let us add the <code>BookCreateSchema</code> class to <code>src/books/schemas.py</code>. The BookCreateModel class<pre><code>...\nclass BookCreateModel(BaseModel):\n    \"\"\"\n        This class is used to validate the request when creating or updating a book\n    \"\"\"\n    title: str\n    author: str\n    publisher: str\n    published_date: str\n    page_count: int\n    language: str\n</code></pre></p>"},{"location":"chapter6/#retrieve-a-book-by-its-uid","title":"Retrieve a book by its uid","text":"Retrieve a book by its uid<pre><code>... # the rest of the BookService class\nasync def get_book(self, book_uid: str, session:AsyncSession):\n    \"\"\"Get a book by its UUID.\n\n    Args:\n        book_uid (str): the UUID of the book\n\n    Returns:\n        Book: the book object\n    \"\"\"\n    statement = select(Book).where(Book.uid == book_uid)\n\n    result = await session.exec(statement)\n\n    book = result.first()\n\n    return book if book is not None else None\n</code></pre> <p>To retrieve a book from the database, we construct a <code>select</code> statement to fetch all books but filter by the <code>uid</code> to ensure that only the desired book is retrieved. This filtering is achieved using the <code>where</code> method.</p> <p>Subsequently, we execute the statement using the <code>session</code> object, obtaining the <code>result</code>. Finally, we retrieve the book by invoking the <code>first</code> method on the result object. Note that we are returning <code>None</code> if a book matching the <code>uid</code> is not found.</p>"},{"location":"chapter6/#update-a-book","title":"Update a book","text":"<p>To update a book, we need to retrieve the book to update by its <code>uid</code>. secondly, we need to get the data we shall be updating the book with (<code>update_data</code>). Finally, we shall update the book fields with the new data and  return the updated book if found or None when not.</p> <p>Update a book<pre><code>... # rest of the BookService class\nasync def update_book(self, book_uid: str, update_data: BookCreateSchema, session: AsyncSession):\n    \"\"\"Update a book\n\n    Args:\n        book_uid (str): the UUID of the book\n        update_data (BookCreateModel): the data to update the book\n\n    Returns:\n        Book: the updated book\n    \"\"\"\n\n    book_to_update = await self.get_book(book_uid,session)\n\n    if book_to_update is not None:\n        update_data_dict = update_data.model_dump()\n\n        for k, v in update_data_dict.items():\n            setattr(book_to_update,k ,v)\n\n        await session.commit()\n\n        return book_to_update\n    else:\n        return None\n</code></pre> To implement the <code>update_book</code> method, which updates a book by its UID, we first fetch the book based on its UID, following the approach described for retrieving a book.</p> <p>Next, we update the book object with the following code:</p> Update book<pre><code># Unpack the book data dictionary and set fields\nfor key, value in update_data.model_dump().items():\n    setattr(book, k, v)\n</code></pre> <p>This code iterates over the key-value pairs in the dictionary obtained from <code>update_data.model_dump()</code>, setting each field of the book object accordingly.</p> <p>Finally, after updating the book object with the new data, we commit the changes to the database using session.commit(). This ensures that the modifications made to the book are saved persistently in the database.</p>"},{"location":"chapter6/#delete-a-book","title":"Delete a Book","text":"<p>To delete a book from the database, we follow a similar approach as when retrieving a book. Once we have obtained the book object from the database using its <code>uid</code>, we use the <code>session.delete</code> method to mark the <code>book</code> object for deletion. To finalize the deletion and apply the changes to the database, we call <code>session.commit()</code>. This ensures that the book is effectively removed from the database.</p> Delete a book<pre><code>... #rest of the BookService class\nasync def delete_book(self, book_uid:str , session:AsyncSession):\n    \"\"\"Delete a book\n\n    Args:\n        book_uid (str): the UUID of the book\n    \"\"\"\n    book_to_delete = await self.get_book(book_uid,session)\n\n    if book_to_delete is not None:\n        await session.delete(book_to_delete)\n\n        await session.commit()\n\n        return {}\n\n    else:\n        return None\n</code></pre> <p>Let update our routes to ensure they use our newly created book database to Create, Read, Update and Delete our book database record. The source code for <code>src/books/service.py</code> should look like this at this point.</p> src/books/service.py<pre><code>from sqlmodel.ext.asyncio.session import AsyncSession\nfrom .schemas import BookCreateModel, BookUpdateModel\nfrom sqlmodel import select, desc\nfrom .models import Book\nfrom datetime import datetime\n\nclass BookService:\n    async def get_all_books(self, session: AsyncSession):\n        statement = select(Book).order_by(desc(Book.created_at))\n\n        result = await session.exec(statement)\n\n        return result.all()\n\n    async def get_book(self, book_uid: str, session: AsyncSession):\n        statement = select(Book).where(Book.uid == book_uid)\n\n        result = await session.exec(statement)\n\n        book = result.first()\n\n        return book if book is not None else None\n\n    async def create_book(self, book_data: BookCreateModel, session: AsyncSession):\n        book_data_dict = book_data.model_dump()\n\n        new_book = Book(\n            **book_data_dict\n        )\n\n        new_book.published_date = datetime.strptime(book_data_dict['published_date'],\"%Y-%m-%d\")\n\n        session.add(new_book)\n\n        await session.commit()\n\n        return new_book\n\n    async def update_book(\n        self, book_uid: str, update_data: BookUpdateModel, session: AsyncSession\n    ):\n        book_to_update = await self.get_book(book_uid,session)\n\n        if book_to_update is not None:\n            update_data_dict = update_data.model_dump()\n\n            for k, v in update_data_dict.items():\n                setattr(book_to_update,k ,v)\n\n            await session.commit()\n\n            return book_to_update\n        else:\n            return None\n\n    async def delete_book(self,book_uid:str, session:AsyncSession):\n\n        book_to_delete = await self.get_book(book_uid,session)\n\n        if book_to_delete is not None:\n            await session.delete(book_to_delete)\n\n            await session.commit()\n\n            return {}\n\n        else:\n            return None\n</code></pre>"},{"location":"chapter6/#dependency-injection","title":"Dependency Injection","text":"<p>Now that we have created the <code>BookService</code> class, we need to create the <code>session</code> object that we shall use a dependency in every API route that shall interact with the database in any way.</p> <p>Dependency injection in FastAPI allows for the sharing of state among multiple API routes by providing a mechanism to create Python objects, referred to as dependencies, and accessing them only when necessary within dependant functions. While the concept may initially seem technical and esoteric, it is a fundamental aspect of FastAPI that proves remarkably beneficial across various scenarios. Interestingly, we often employ dependency injection without realizing it, demonstrating its widespread usefulness. Some potential applications include:</p> <ul> <li>Gathering input parameters for HTTP requests (Path and query parameters)</li> <li>Validating parameters inputs</li> <li>Checking authentication and authorization (we shall look at this in coming chapters)</li> <li>Emitting logs and metrics e.t.c.</li> </ul> <p>Let us create our first dependency: src/db/main.py<pre><code>from sqlmodel.ext.asyncio.session import AsyncSession\nfrom sqlalchemy.orm import sessionmaker\n\n... # rest of main.py\n\nasync def get_session() -&gt; AsyncSession:\n\"\"\"Dependency to provide the session object\"\"\"\nasync_session = sessionmaker(\n    bind=async_engine, class_=AsyncSession, expire_on_commit=False\n)\n\nasync with async_session() as session:\n    yield session\n</code></pre></p> <p>In the above code, we define an async function called <code>get_session</code> that should return an object of the <code>AsyncSesion</code> class. This class is what allows us to use an aync DBAPI to interact with the database. That is the object we shall create all <code>BookService</code> objects with.</p> <p>Now that we have an understanding of how we shall get our session, let us go to the <code>src/books/routes.py</code> and modify it to make calls to the methods we have so far defined inside the <code>BookService</code> class.</p> Modified routes with updated CRUD in src/books/routes.py<pre><code>from fastapi import APIRouter, status, Depends\nfrom fastapi.exceptions import HTTPException\nfrom src.books.schemas import Book, BookUpdateModel, BookCreateModel\nfrom sqlmodel.ext.asyncio.session import AsyncSession\nfrom src.books.service import BookService\nfrom src.db.main import get_session\nfrom typing import List\n\nbook_router = APIRouter()\nbook_service = BookService()\n\n\n@book_router.get(\"/\", response_model=List[Book])\nasync def get_all_books(session: AsyncSession = Depends(get_session)):\n    books = await book_service.get_all_books(session)\n    return books\n\n\n@book_router.post(\"/\", status_code=status.HTTP_201_CREATED, response_model=Book)\nasync def create_a_book(\n    book_data: BookCreateModel, session: AsyncSession = Depends(get_session)\n) -&gt; dict:\n    new_book = await book_service.create_book(book_data, session)\n    return new_book\n\n\n@book_router.get(\"/{book_uid}\", response_model=Book)\nasync def get_book(book_uid: str, session: AsyncSession = Depends(get_session)) -&gt; dict:\n    book = await book_service.get_book(book_uid, session)\n\n    if book:\n        return book\n    else:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND, detail=\"Book not found\"\n        )\n\n\n@book_router.patch(\"/{book_uid}\", response_model=Book)\nasync def update_book(\n    book_uid: str,\n    book_update_data: BookUpdateModel,\n    session: AsyncSession = Depends(get_session),\n) -&gt; dict:\n\n    updated_book = await book_service.update_book(book_uid, book_update_data, session)\n\n    if updated_book is None:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND, detail=\"Book not found\"\n        )\n\n    else:\n        return updated_book\n\n\n@book_router.delete(\"/{book_uid}\", status_code=status.HTTP_204_NO_CONTENT)\nasync def delete_book(book_uid: str, session: AsyncSession = Depends(get_session)):\n    book_to_delete = await book_service.delete_book(book_uid, session)\n\n    if book_to_delete is None:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND, detail=\"Book not found\"\n        )\n    else:\n\n        return {}\n</code></pre> <p>We've made minimal changes to the file but have introduced some updates that I'll outline here. Let's start by examining the dependency injection we've integrated. Take note of how we've included the following code in each route handler function. <pre><code>session: AsyncSession = Depends(get_session)\n</code></pre> What we're accomplishing here is the sharing of the <code>session</code> generated by calling the <code>get_session</code> function we defined earlier in this chapter.</p> <p>Once the <code>session</code> is established, we proceed to instantiate the <code>BookService</code> class. This instance allows us to utilize its methods for performing various CRUD operations as needed.</p> <p><pre><code>books = await BookService(session).get_all_books()\n</code></pre> We instantiate the <code>BookService</code> function to invoke its <code>get_all_books()</code> method, supplying the session as a dependency to the route handler that includes the above code.</p>"},{"location":"chapter6/#conclusion","title":"Conclusion","text":"<p>In this chapter, we expanded our application to incorporate CRUD operations on our book data by leveraging our persistent PostgreSQL database. We explored how to utilize SQLModel to accomplish this task efficiently.</p>"},{"location":"chapter7/","title":"Creating the User Authentication Model","text":"<p>Now that we have a working CRUD API, let's move on to more advanced topics. The first thing we need to tackle is figuring out who our users are and what they can do in the application. This breaks down into two main points:</p> <ul> <li>Authentication: Making sure users are who they say they are.</li> <li>Authorization: Deciding what actions users are allowed to take based on their identity.</li> </ul>"},{"location":"chapter7/#creating-the-user-account-model","title":"Creating the user account model","text":"<p>To achieve that, we shall begin by having a database model for keeping information about user accounts. Our current project structure looks like. Current Project Structure<pre><code>\u251c\u2500\u2500 requirements.txt\n\u2514\u2500\u2500 src\n|-- \u251c\u2500\u2500 books\n|-- \u2502   \u251c\u2500\u2500 book_data.py\n|-- \u2502   \u251c\u2500\u2500 __init__.py\n|-- \u2502   \u251c\u2500\u2500 models.py\n|-- \u2502   \u251c\u2500\u2500 routes.py\n|-- \u2502   \u251c\u2500\u2500 schemas.py\n|-- \u2502   \u2514\u2500\u2500 service.py\n|-- \u251c\u2500\u2500 config.py\n|-- \u251c\u2500\u2500 db\n|-- \u2502   \u251c\u2500\u2500 __init__.py\n|-- \u2502   \u2514\u2500\u2500 main.py\n`-- \u2514\u2500\u2500 __init__.py\n</code></pre></p> <p>Inside the <code>src</code> folder, we shall create a directory called <code>auth</code>. This shall keep all source code associated with user account management. Inside it, we shall create a <code>__init__.py</code> file to mark it as a Python package. Our updated directory structure is now:</p> Create the auth directory<pre><code>\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 requirements.txt\n\u2514\u2500\u2500 src\n|-- \u251c\u2500\u2500 auth\n|-- \u2502   \u2514\u2500\u2500 __init__.py\n|-- \u251c\u2500\u2500 books\n|-- \u2502   \u251c\u2500\u2500 book_data.py\n|-- \u2502   \u251c\u2500\u2500 __init__.py\n|-- \u2502   \u251c\u2500\u2500 models.py\n|-- \u2502   \u251c\u2500\u2500 routes.py\n|-- \u2502   \u251c\u2500\u2500 schemas.py\n|-- \u2502   \u2514\u2500\u2500 service.py\n|-- \u251c\u2500\u2500 config.py\n|-- \u251c\u2500\u2500 db\n|-- \u2502   \u251c\u2500\u2500 __init__.py\n|-- \u2502   \u2514\u2500\u2500 main.py\n`-- \u2514\u2500\u2500 __init__.py\n</code></pre> <p>Let us now add a <code>models.py</code> file in which we shall create the user account model. </p> src/auth/models.py<pre><code>from sqlmodel import SQLModel, Field, Column\nimport sqlalchemy.dialects.postgresql as pg\nimport uuid\n\n\nclass User(SQLModel, table=True):\n    __tablename__ = \"user_accounts\"\n\n    uid: uuid.UUID = Field(\n        sa_column=Column(\n            pg.UUID,\n            primary_key=True,\n            unique=True,\n            nullable=False,\n            default=uuid.uuid4,\n            info={\"description\": \"Unique identifier for the user account\"},\n        )\n    )\n\n    username: str\n    first_name: str = Field(nullable=True)\n    last_name: str = Field(nullable=True)\n    is_verified: bool = False\n    email: str\n    password_hash: str\n    created_at: datetime = Field(sa_column=Column(pg.TIMESTAMP, default=func.now))\n\n    def __repr__(self) -&gt; str:\n        return f\"&lt;User {self.username}&gt;\"\n</code></pre> <p>Most of the code here was explained in Chapter 5, so I will only cover what is new.</p> <ul> <li>We created a database model called <code>User</code> with the table name <code>user_accounts</code>.</li> <li> <p>The primary fields added include <code>uuid</code>, along with other fields such as <code>first_name</code>, <code>last_name</code>, <code>email</code>, <code>password_hash</code>, <code>created_at</code>, and <code>is_verified</code>.</p> </li> <li> <p>The <code>is_verified</code> field is necessary as it allows us to verify user-provided email addresses, ensuring we only deal with valid email addresses.</p> </li> </ul> <p>Once we have created this database model, let's save it and ensure the table is reflected in our database.</p>"},{"location":"chapter7/#database-migrations-with-alembic","title":"Database Migrations with Alembic","text":"<p>Previously, we applied changes to the database using the lifespan event created in Chapter 5. This method allowed us to create the table each time our server started, which was helpful during development. However, in a production environment, we need a proper database migration system to migrate changes to our database schema without restarting our server.</p> <p>To achieve this, we will use Alembic, a database migration tool for use with SQLAlchemy. Since we are using SQLModel, which is based on SQLAlchemy, Alembic will be very useful.</p> <p>Let's begin by installing Alembic in our virtual environment using <code>pip</code>: Installling Alembic<pre><code>(env) $ pip install alembic\n</code></pre></p> <p>To confirm that Alembic has been installed, run the following command: checking Alembic version<pre><code>(env) $ alembic --version\nalembic 1.13.1\n</code></pre></p> <p>Alembic is installed and the version is <code>1.13.1</code>. Now, let's initialize Alembic in our project with this command: Creating the migration environment<pre><code>(env) $ alembic init -t async migrations\n  Creating directory '/home/jod35/Documents/fastapi-beyond-CRUD/migrations' ...  done\n  Creating directory '/home/jod35/Documents/fastapi-beyond-CRUD/migrations/versions' ...  done\n  Generating /home/jod35/Documents/fastapi-beyond-CRUD/migrations/script.py.mako ...  done\n  Generating /home/jod35/Documents/fastapi-beyond-CRUD/migrations/env.py ...  done\n  Generating /home/jod35/Documents/fastapi-beyond-CRUD/alembic.ini ...  done\n  Generating /home/jod35/Documents/fastapi-beyond-CRUD/migrations/README ...  done\n  Please edit configuration/connection/logging settings in '/home/jod35/Documents/fastapi-beyond-CRUD/alembic.ini' before proceeding.\n</code></pre></p> <p>The above command uses Alembic to create a migration environment. The migration environment, in this case, is the <code>migrations</code> folder added to our project directory. This folder and the <code>alembic.ini</code> file are generated by Alembic and form the migration environment.</p> <p>We used the <code>-t</code> option to specify the template for setting up the environment. We chose the async template because our project uses an async DBAPI.</p> <p>Now, our folder structure looks like this: Current Project structure with migration environment<pre><code>\u251c\u2500\u2500 alembic.ini\n\u251c\u2500\u2500 migrations\n\u2502   \u251c\u2500\u2500 env.py\n\u2502   \u251c\u2500\u2500 README\n\u2502   \u251c\u2500\u2500 script.py.mako\n\u2502   \u2514\u2500\u2500 versions\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 requirements.txt\n\u2514\u2500\u2500 src\n    \u251c\u2500\u2500 auth\n    \u2502   \u251c\u2500\u2500 __init__.py\n    \u2502   \u251c\u2500\u2500 models.py\n    \u251c\u2500\u2500 books\n    \u2502   \u251c\u2500\u2500 book_data.py\n    \u2502   \u251c\u2500\u2500 __init__.py\n    \u2502   \u251c\u2500\u2500 models.py\n    \u2502   \u251c\u2500\u2500 routes.py\n    \u2502   \u251c\u2500\u2500 schemas.py\n    \u2502   \u2514\u2500\u2500 service.py\n    \u251c\u2500\u2500 config.py\n    \u251c\u2500\u2500 db\n    \u2502   \u251c\u2500\u2500 __init__.py\n    \u2502   \u2514\u2500\u2500 main.py\n    \u2514\u2500\u2500 __init__.py\n</code></pre></p> <p>The <code>migrations</code> directory contains the following:</p> <ul> <li><code>versions/</code>: This folder will contain Python scripts created for each migration to track database changes.</li> <li><code>env.py</code>: This script serves as the entry point for Alembic. When you run Alembic commands like <code>alembic init</code>, <code>alembic revision</code>, or <code>alembic upgrade</code>, this script executes the necessary actions.</li> <li><code>README</code>: This file contains a description of the migration environment we have set up.</li> <li><code>script.py.mako</code>: This is a template used by Alembic to create new Python migration scripts each time we create a new migration.</li> </ul> <p>Sure, here is the rewritten text:</p> <p>The <code>alembic.ini</code> file contains configurations for Alembic that enable it to interact with our database and project.</p> <p>Now that we understand our migration environment, let's set up SQLModel to work with Alembic. We start by editing <code>migrations/env.py</code>:</p> migrations/env.py<pre><code>import asyncio\nfrom logging.config import fileConfig\n\nfrom sqlalchemy import pool\nfrom sqlalchemy.engine import Connection\nfrom sqlalchemy.ext.asyncio import async_engine_from_config\n\nfrom alembic import context\nfrom sqlmodel import SQLModel\nfrom src.config import Config\n\n\ndatabase_url = Config.DATABASE_URL\n\n# this is the Alembic Config object, which provides\n# access to the values within the .ini file in use.\nconfig = context.config\n\nconfig.set_main_option(\"sqlalchemy.url\", database_url)\n\n# Interpret the config file for Python logging.\n# This line sets up loggers basically.\nif config.config_file_name is not None:\n    fileConfig(config.config_file_name)\n\n# add your model's MetaData object here\n# for 'autogenerate' support\n# from myapp import mymodel\n# target_metadata = mymodel.Base.metadata\ntarget_metadata = SQLModel.metadata\n... # the rest of env.py\n</code></pre> <p>In this example, we import the <code>User</code> model we created in <code>/src/auth/models.py</code>. This is necessary because Alembic will automatically generate changes to the model. Additionally, we import the <code>SQLModel</code> class to access the <code>metadata</code> object, which Alembic uses to track changes to our database model using SQLModel. One other important change we have made is one to enable our <code>sqlalchemy.url</code> be read from the <code>DATABASE_URL</code> environment variable.</p> read sqlalchemy URL from .env<pre><code>database_url = Config.DATABASE_URL\n\n# this is the Alembic Config object, which provides\n# access to the values within the .ini file in use.\nconfig = context.config\n\nconfig.set_main_option(\"sqlalchemy.url\", database_url)\n</code></pre> <p>Next, we edit the <code>migrations/script.py.mako</code> file to include SQLModel:</p> migrations/script.mako.py<pre><code>\"\"\"${message}\n\nRevision ID: ${up_revision}\nRevises: ${down_revision | comma,n}\nCreate Date: ${create_date}\n\n\"\"\"\nfrom typing import Sequence, Union\n\nfrom alembic import op\nimport sqlalchemy as sa\nimport sqlmodel # ADD THIS\n\n...\n</code></pre> <p>Having made these changes, let's create our first database migration. Our database currently contains only the <code>books</code> table. We'll create a migration to add the <code>user_accounts</code> table:</p> Creating our first Migration<pre><code>(env) $ alembic revision --autogenerate -m \"init\"\nINFO  [alembic.runtime.migration] Context impl PostgresqlImpl.\nINFO  [alembic.runtime.migration] Will assume transactional DDL.\nINFO  [alembic.autogenerate.compare] Detected added table 'user_accounts'\n  Generating /home/jod35/Documents/fastapi-beyond-CRUD/migrations/versions/8cf8276d5f3c_init.py ...  done\n</code></pre> <p>The newly created <code>migrations/versions/8cf8276d5f3c_init.py</code> file contains the following:</p> src/migrations/versions/8cf8276d5f3c_init.py<pre><code>\"\"\"init\n\nRevision ID: 8cf8276d5f3c\nRevises: \nCreate Date: 2024-05-21 19:27:53.577277\n\n\"\"\"\nfrom typing import Sequence, Union\n\nfrom alembic import op\nimport sqlalchemy as sa\nimport sqlmodel\n\nfrom sqlalchemy.dialects import postgresql\n\n# revision identifiers, used by Alembic.\nrevision: str = '8cf8276d5f3c'\ndown_revision: Union[str, None] = None\nbranch_labels: Union[str, Sequence[str], None] = None\ndepends_on: Union[str, Sequence[str], None] = None\n\n\ndef upgrade() -&gt; None:\n    # ### commands auto generated by Alembic - please adjust! ###\n    op.create_table('user_accounts',\n    sa.Column('uid', sa.UUID(), nullable=False),\n    sa.Column('username', sqlmodel.sql.sqltypes.AutoString(), nullable=False),\n    sa.Column('first_name', sqlmodel.sql.sqltypes.AutoString(), nullable=True),\n    sa.Column('last_name', sqlmodel.sql.sqltypes.AutoString(), nullable=True),\n    sa.Column('is_verified', sa.Boolean(), nullable=False),\n    sa.Column('email', sqlmodel.sql.sqltypes.AutoString(), nullable=False),\n    sa.Column('password_hash', sqlmodel.sql.sqltypes.AutoString(), nullable=False),\n    sa.Column('created_at', postgresql.TIMESTAMP(), nullable=True),\n    sa.PrimaryKeyConstraint('uid'),\n    sa.UniqueConstraint('uid')\n    )\n    # ### end Alembic commands ###\n\n\ndef downgrade() -&gt; None:\n    # ### commands auto generated by Alembic - please adjust! ###\n    op.drop_table('user_accounts')\n    # ### end Alembic commands ###\n</code></pre> <p>This code includes:</p> <ul> <li><code>revision</code>: The unique identifier for this migration.</li> <li><code>down_revision</code>: The identifier of the previous migration, set to <code>None</code> for the initial migration.</li> <li><code>branch_labels</code> and <code>depends_on</code>: Optional fields, set to <code>None</code>.</li> </ul> <p>The <code>upgrade</code> function defines the changes to the database structure, creating the <code>user_accounts</code> table with specified columns. The <code>downgrade</code> function reverts these changes by dropping the <code>user_accounts</code> table if the migration is undone.</p> <p>To apply these changes to the database, use the following command:</p> Apply migrations<pre><code>(env) $ alembic upgrade head\nINFO  [alembic.runtime.migration] Context impl PostgresqlImpl.\nINFO  [alembic.runtime.migration] Will assume transactional DDL.\nINFO  [alembic.runtime.migration] Running upgrade  -&gt; 8cf8276d5f3c, init\n</code></pre> <p>This command creates the <code>user_accounts</code> table in the database. To verify, list the tables in your current database:</p> Connecting to your PostgreSQL<pre><code>(env) $ psql --username=&lt;your-username&gt; --dbname=&lt;your-db&gt;\n</code></pre> <p>For example:</p> List table in database<pre><code>(env) $ psql --username=jod35 --dbname=books\npsql (14.11 (Ubuntu 14.11-0ubuntu0.22.04.1))\nType \"help\" for help.\n\nbooks=# \\dt\n            List of relations\n Schema |      Name       | Type  | Owner \n--------+-----------------+-------+-------\n public | alembic_version | table | jod35\n public | books           | table | jod35\n public | user_accounts   | table | jod35\n(3 rows)\n</code></pre> <p>The <code>alembic_version</code> and <code>user_accounts</code> tables have been created. Let's examine their structures.</p> <p>For <code>alembic_version</code>:</p> Structure of the alembic_version table<pre><code>books=# \\d alembic_version\n                    Table \"public.alembic_version\"\n   Column    |         Type          | Collation | Nullable | Default \n-------------+-----------------------+-----------+----------+---------\n version_num | character varying(32) |           | not null | \nIndexes:\n    \"alembic_version_pkc\" PRIMARY KEY, btree (version_num)\n</code></pre> <p>This table includes one column, <code>version_num</code>, which keeps records of the version numbers of changes made to the database structure.</p> <p>For <code>user_accounts</code>:</p> Structure of the user accounts table<pre><code>books=# \\d user_accounts\n                         Table \"public.user_accounts\"\n    Column     |            Type             | Collation | Nullable | Default \n---------------+-----------------------------+-----------+----------+---------\n uid           | uuid                        |           | not null | \n username      | character varying           |           | not null | \n first_name    | character varying           |           |          | \n last_name     | character varying           |           |          | \n is_verified   | boolean                     |           | not null | \n email         | character varying           |           | not null | \n password_hash | character varying           |           | not null | \n created_at    | timestamp without time zone\n\n```console\ncreated_at    | timestamp without time zone |           |          | \nIndexes:\n    \"user_accounts_pkey\" PRIMARY KEY, btree (uid)\n</code></pre> <p>Ladies and gentlemen, we have successfully created the <code>user_accounts</code> table from the <code>User</code> model. Now that we have done this, let us look at some ways to implement authentication in FastAPI.</p>"},{"location":"chapter7/#conclusion","title":"Conclusion","text":"<p>In this chapter, we have created a simple database model to enable us manage user accounts in our application. We have introduced Alembic, a database migration tool that runs on SQLAlchemy database models, allowing us to easily introduce changes to an existing database structure without haveing to delete data.</p>"},{"location":"chapter8/","title":"User Account Creation","text":""},{"location":"chapter8/#user-account-creation","title":"User account Creation","text":"<p>In the previous chapter, we created a database model for user accounts. Using this, we are going to authenticate (show that our users are who they claim to be) and also authorize (show that they have the right access to specific parts of our application.)</p>"},{"location":"chapter8/#creating-user-accounts","title":"Creating User Accounts","text":"<p>Ths first task shall be one of making users join our application through signing up. Using thisstep, users shall have user accounts that can allow them use the application.</p> <p>Our current project structure is something like this. Current Project structure<pre><code>\u251c\u2500\u2500 alembic.ini\n\u251c\u2500\u2500 migrations\n\u2502   \u251c\u2500\u2500 env.py\n\u2502   \u251c\u2500\u2500 README\n\u2502   \u251c\u2500\u2500 script.py.mako\n\u2502   \u2514\u2500\u2500 versions\n\u2502       \u2514\u2500\u2500 8cf8276d5f3c_init.py\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 requirements.txt\n\u2514\u2500\u2500 src\n|-- \u251c\u2500\u2500 auth\n|-- \u2502   \u251c\u2500\u2500 __init__.py\n|-- \u2502   \u251c\u2500\u2500 models.py\n|-- \u251c\u2500\u2500 books\n|-- \u2502   \u251c\u2500\u2500 book_data.py\n|-- \u2502   \u251c\u2500\u2500 __init__.py\n|-- \u2502   \u251c\u2500\u2500 models.py\n|-- \u2502   \u251c\u2500\u2500 routes.py\n|-- \u2502   \u251c\u2500\u2500 schemas.py\n|-- \u2502   \u2514\u2500\u2500 service.py\n|-- \u251c\u2500\u2500 config.py\n|-- \u251c\u2500\u2500 db\n|-- \u2502   \u251c\u2500\u2500 __init__.py\n|-- \u2502   \u2514\u2500\u2500 main.py\n`-- \u2514\u2500\u2500 __init__.py\n</code></pre></p> <p>Let us begin by creating <code>src/auth/service.py</code> and adding the folowing code to it. src/auth/service.py<pre><code>from .models import User\nfrom .schemas import UserCreateModel\nfrom .utils import generate_passwd_hash\nfrom sqlmodel.ext.asyncio.session import AsyncSession\nfrom sqlmodel import select\n\n\nclass UserService:\n    async def get_user_by_email(self, email: str, session: AsyncSession):\n        statement = select(User).where(User.email == email)\n\n        result = await session.exec(statement)\n\n        user = result.first()\n\n        return user\n\n    async def user_exists(self, email, session: AsyncSession):\n        user = await self.get_user_by_email(email, session)\n\n        return True if user is not None else False\n\n    async def create_user(self, user_data: UserCreateModel, session: AsyncSession):\n        user_data_dict = user_data.model_dump()\n\n        new_user = User(**user_data_dict)\n\n        new_user.password_hash = generate_passwd_hash(user_data_dict[\"password\"])\n\n        session.add(new_user)\n\n        await session.commit()\n\n        return new_user\n</code></pre></p>"},{"location":"chapter8/#retrieving-a-user-by-their-email","title":"Retrieving a user by their email","text":"<p>Inside this file, we have created a class <code>UserService</code> containing some methods that shall be necessary when creating user accounts. Let us begin by looking at the first method <code>get_user_by_email</code> .</p> src/auth/service.py<pre><code>async def get_user_by_email(self, email: str, session: AsyncSession):\n    statement = select(User).where(User.email == email)\n\n    result = await session.exec(statement)\n\n    user = result.first()\n\n    return user\n</code></pre> <p>This function is responsible for retrieving a user by their username. First we create a statement the queries for a user by their email. select a user by their email<pre><code>statement = select(User).where(User.email == email)\n</code></pre></p> <p>Next, we create a result object from using our session object to execute the statement.</p> Using the session to execute the statement<pre><code>result = await session.exec(statement)\n\nuser = result.first()\n</code></pre> <p>We then access to the returned user object using the <code>first</code> method. Finally, we return the user object.</p>"},{"location":"chapter8/#checking-if-a-user-exists","title":"Checking if a user exists","text":"<p>The next method is the <code>user_exists</code> method that shows if a user exists by returning <code>True</code> if the user exists else <code>False</code>.</p> Checking is the user account exists<pre><code>async def user_exists(self, email, session: AsyncSession):\n    user = await self.get_user_by_email(email, session)\n\n    return True if user is not None else False\n</code></pre>"},{"location":"chapter8/#creating-the-user-account","title":"Creating the user account","text":"<p>Lastly we have the <code>create_user</code> function that is responsible fo creating a user account. Creating a user account<pre><code>async def create_user(self, user_data: UserCreateModel, session: AsyncSession):\n    user_data_dict = user_data.model_dump()\n\n    new_user = User(**user_data_dict)\n\n    new_user.password_hash = generate_passwd_hash(user_data_dict[\"password\"])\n\n    session.add(new_user)\n\n    await session.commit()\n\n    return new_user\n</code></pre></p> <p>This function has two parameters, the <code>user_data</code> and the <code>session</code> object. The <code>user_data</code> parameter is of type <code>BookCreateModel</code> which we are going to define in a  <code>schemas.py</code> we have to created inside our <code>auth</code> directory.</p> src/auth/schemas.py<pre><code>class UserCreateModel(BaseModel):\n    first_name: str =Field(max_length=25)\n    last_name:  str =Field(max_length=25)\n    username: str = Field(max_length=8)\n    email: str = Field(max_length=40)\n    password: str  = Field(min_length=6)\n</code></pre> <p>This example demonstrates a typical Pydantic model used for defining the structure required to create a new user account. The model includes fields from the <code>User</code> database model that are necessary for account creation.</p> <p>We use the <code>Field</code> class to enforce additional validation on certain fields, such as specifying <code>max_length</code> and <code>min_length</code>. This ensures that any data received from a client adheres to these constraints. </p> <p>The <code>session</code> object, which is instantiated from the <code>get_session</code> dependency, is then utilized.</p> <p>A dictionary named <code>new_user</code> is created from the <code>user_data</code> object. This dictionary is then unpacked to instantiate a new <code>User</code> object with the corresponding attributes. Subsequently, the <code>session</code> object is used to add this new <code>User</code> object to the session. We commit the session to persist the new user to the database. Finally, we return the newly created user object.</p> <pre><code>user_data_dict = user_data.model_dump()\n\nnew_user = User(**user_data_dict)\n\nnew_user.password_hash = generate_passwd_hash(user_data_dict[\"password\"])\n\nsession.add(new_user)\n\nawait session.commit()\n\nreturn new_user\n</code></pre> <p>Let's take a closer look at how the password is hashed using the generate_password_hash function defined in src/auth/utils.py.</p> <p>First, note how we utilize the generate_password_hash function within our user creation process to securely hash the user's password before storing it in the database. This ensures that passwords are not stored in plain text, enhancing security.</p> src/auth/utils.py<pre><code>from passlib.context import CryptContext\n\npasswd_context = CryptContext(\n    schemes=['bcrypt']\n)\n\ndef generate_password_hash(password: str) -&gt; str:\n    hash = passwd_context.hash(password)\n    return hash\n\ndef verify_password(password: str, hash: str) -&gt; bool:\n    return passwd_context.verify(password, hash)\n</code></pre> <p>This file contains two crucial functions:</p> <ol> <li>generate_password_hash: This function takes a plain text password and returns its hashed version.</li> <li>verify_password: This function checks if a given plain text password matches a stored hash, returning <code>True</code> if they match and <code>False</code> otherwise.</li> </ol> <p>To make these functions work, we use Passlib, a library that supports various password hashing algorithms. You can install it with the following command:</p> Installing passlib<pre><code>pip install passlib\n</code></pre> <p>Passlib's <code>CryptContext</code> class allows us to specify which hashing algorithms to use. In this case, we create a <code>passwd_context</code> object configured to use the Bcrypt algorithm:</p> Creating the password context<pre><code>passwd_context = CryptContext(\n    schemes=['bcrypt']\n)\n</code></pre> <p>This object is initialized with the <code>schemes</code> parameter, a list of the hashing algorithms we want to use. Here, we've chosen Bcrypt.</p> <p>We then use this object to hash and verify passwords by calling its methods: 1. hash: This method takes a plain text password and returns a hashed version of it. 2. verify: This method takes a plain text password and a hash, returning <code>True</code> if they match and <code>False</code> if they don't.</p>"},{"location":"chapter8/#creating-the-auth-router","title":"Creating the Auth Router","text":"<p>After creating our <code>UserService</code>, we can now create an API endpoint to utilize this service. First, we will create a <code>routes.py</code> file and add the following code to it:</p> src/auth/routes.py<pre><code>from fastapi import APIRouter, Depends, status\nfrom .schemas import UserCreateModel, UserModel\nfrom .service import UserService\nfrom src.db.main import get_session\nfrom sqlmodel.ext.asyncio.session import AsyncSession\nfrom fastapi.exceptions import HTTPException\n\nauth_router = APIRouter()\nuser_service = UserService()\n\n@auth_router.post(\n    \"/signup\", response_model=UserModel, status_code=status.HTTP_201_CREATED\n)\nasync def create_user_account(\n    user_data: UserCreateModel, session: AsyncSession = Depends(get_session)\n):\n    email = user_data.email\n\n    user_exists = await user_service.user_exists(email, session)\n\n    if user_exists:\n        raise HTTPException(\n            status_code=status.HTTP_403_FORBIDDEN,\n            detail=\"User with email already exists\",\n        )\n\n    new_user = await user_service.create_user(user_data, session)\n\n    return new_user\n</code></pre> <p>In this file, we create a router object called <code>auth_router</code> to group all routes related to authentication. We also instantiate <code>user_service</code> to access the methods defined in the UserService object. Then, we create an endpoint for creating user accounts. The primary endpoint in this file is for creating user accounts. This endpoint extracts the email from the <code>user_data</code> object and checks if a user with that email already exists using the <code>user_service.user_exists</code> method. </p> <p>If the user exists, it raises an <code>HTTPException</code> with a 403 status code and an appropriate message. If the user does not exist, it creates and saves the new user in the database using the user_service.create_user method and returns the newly created user object. To test this endpoint, use a tool like Insomnia to send a POST request to the /signup endpoint with the required fields in the request body, ensuring the user account is created successfully or that the correct error message is returned if the user already exist.</p> <p>Making a sucessful request to the endpoint creates a new user account. </p> <p>Making the same request again shows that the user already exists with the defined status code. </p>"},{"location":"chapter8/#conclusion","title":"Conclusion","text":"<p>For now, we have been successful in creating user accounts using the database model we created in the previous section. In the next section, we are going to allow users identify themselves, so that they access various API endpoints.</p>"},{"location":"chapter9/","title":"Authentication using JWTS","text":""},{"location":"chapter9/#introduction","title":"Introduction","text":"<p>Now that we can create user accounts, let's build on that to allow users to log in and maintain a session in our application. While there are many approaches to authentication, we will focus on JWT (JSON Web Token) authentication in this chapter. JWTs are a mechanism for transferring claims (secret data) between parties. The claims in a JWT are encoded as a JSON object, which is used as a payload that can be signed, integrity protected, or encrypted.</p>"},{"location":"chapter9/#basic-structure-of-a-jwt","title":"Basic structure of a JWT","text":"<p>A JWT shall have the following components;</p> <ol> <li>Header : This contains the type of the JWT as well as the signing algorithm being used to create it. It will look like this</li> </ol> <pre><code>{\n  \"alg\": \"HS256\",\n  \"typ\": \"JWT\"\n}\n</code></pre> <ol> <li>Payload: This part contains the claims which are basically the data that we may want to keep about a specific entity. This can also be any additional data that we may want to encode.</li> </ol> <pre><code>{\n  \"sub\": \"1234567890\",\n  \"name\": \"John Doe\",\n  \"iat\": 1516239022\n}\n</code></pre> <ol> <li>Signature: This part explains how the header, the payload were signed using the signing algorithm and the secret.</li> </ol> <pre><code>HMACSHA256(base64UrlEncode(header) + \".\" + base64UrlEncode(payload), secret);\n</code></pre>"},{"location":"chapter9/#how-jwt-authentication-works","title":"How JWT Authentication works","text":"<ol> <li> <p>Client Authentication: The client shall submit a payload with the user's email or password and when they are valid, the server shall genrate a JWT to send it to the client.</p> </li> <li> <p>Token Storage: The client will store the token either in local storage or cookies.</p> </li> <li> <p>Subsequent Requests: The client shall make requests to the server using the token inside the HTTP headers.</p> </li> <li> <p>Token Verification: The server verifies the token's signature and validates its payload to ensure the token has not been tampered with and is still valid.</p> </li> <li> <p>Authorization: If the token is valid, the server processes the request; otherwise, it rejects the request.</p> </li> </ol> <p>JWTs are compact, we can pass them in the request body, headers, and also via URLs. In addition, they are self contained and can contain all information we may wish them to have therefor, reducing on the number of times we query the database. They are secure and can also be used across many domains making them ideal for ditributed systems.</p>"},{"location":"chapter9/#encoding-and-decoding-jwts","title":"Encoding and Decoding JWTs","text":""},{"location":"chapter9/#installing-pyjwt","title":"Installing PyJWT","text":"<p>To implement JWT authentication, we shall make use of PyJWT, a library for encoding and decoding JWTs using Python. Let us begin by installing it with;</p> Installing PyJWT<pre><code>pip install pyjwt[crypto]\n</code></pre> <p>Note how we have included crypto, stading for the cryptography module.</p>"},{"location":"chapter9/#creating-the-necessary-functions","title":"Creating the Necessary functions","text":"<p>Inside our <code>auth</code> directory, we shall create move to the utils file where we create the functions for our password management. Inside <code>utils.py</code>, let us add the following code.</p> src/auth/utils.py<pre><code>from datetime import datetime, timedelta\n\nimport jwt\nfrom passlib.context import CryptContext\nfrom src.config import Config\n\n\n\n... #the password functions\ndef create_access_token(user_data: dict , expiry:timedelta =None, refresh: bool= False) -&gt; str:\n    payload = {\n        'user':user_data,\n        'exp': datetime.now() + (expiry if expiry is not None else timedelta(minutes=60)),\n        'jti': str(uuid.uuid4()),\n        'refresh' : refresh\n    }\n\n\n    token = jwt.encode(\n        payload=payload,\n        key= Config.JWT_SECRET,\n        algorithm=Config.JWT_ALGORITHM\n    )\n\n    return token\n\ndef decode_token(token: str) -&gt; dict:\n    try:\n        token_data = jwt.decode(\n            jwt=token,\n            algorithms=[Config.JWT_ALGORITHM]\n        )\n\n        return token_data\n    except jwt.PyJWTError as jwte:\n        logging.exception(jwte)\n        return None\n\n    except Exception as e:\n        logging.exception(e)\n        return None\n</code></pre> <p>We begin by importing necessary objects such as the <code>Config</code> object as well as PyJWT's <code>CryptContext</code>class. We also import PYJWT to allow us accss the functions necessary to encode and decode JWTs. We the create two functions.</p> <ol> <li>The <code>create_access_token</code> function that shall help us create access or refresh tokens. Access tokens are going to be short lived and for security reasons we shall create long-lived refresh tokens to allow us create new access tokens once they are expired.</li> </ol> Encoding JWTS<pre><code>def create_access_token(user_data: dict , expiry:timedelta =None, refresh: bool= False) -&gt; str:\n    payload = {\n        'user':user_data,\n        'exp': datetime.now() + (expiry if expiry is not None else timedelta(minutes=60)),\n        'jti': str(uuid.uuid4()),\n        'refresh' : refresh\n    }\n\n\n    token = jwt.encode(\n        payload=payload,\n        key= Config.JWT_SECRET,\n        algorithm=Config.JWT_ALGORITHM\n    )\n\n    return token\n</code></pre> <p>The function has parameters, <code>user_data</code>, <code>expiry</code>, and <code>refresh</code>. <code>user_data</code> shall be all the data about the user to whom the token shall be issued. <code>expiry</code> shall be a datetime timedelta object that shall be used to create the expiry date of a token. We also have the <code>refresh</code> boolean that shall be used to mark a token as a refresh token or not.</p> <p>We create a dictionary called <code>payload</code> to hold the neccessary claims that we want to encode the token. This contains the data about the user <code>user_data</code>, the expiry <code>exp</code>, the JWT ID <code>jti</code> and the refresh boolean`.</p> <p>After doing this, our token shall be created by using the <code>encode</code> function from PyJWT. This function uses the payload, the key and the algoritm to encode the token. Note how we get the two from the <code>Config</code> object. To make these be accessed , we need to first update <code>src/config.py</code> to add the following.</p> Update the Config to add JWT secret and algorithm<pre><code>class Settings(BaseSettings):\n    DATABASE_URL : str\n    JWT_SECRET:str\n    JWT_ALGORITHM:str\n\n    model_config = SettingsConfigDict(\n        env_file=\".env\",\n        extra=\"ignore\"\n    )\n</code></pre> <p>We shall need to also modify our <code>.env</code> to have this</p> Adding JWT secret and algorithm to .env<pre><code>DATABASE_URL=postgresql+asyncpg://jod35:nathanoj35@localhost:5432/bookly_db\nJWT_SECRET=e698218fbf1d9d46b06a6c1aa41b3124\nJWT_ALGORITHM=HS256\n</code></pre> <p>Once we have created the token, we shall return it as shown above.</p> <ol> <li>The <code>decode_token</code> is a function to help us decode the tokens and get the claims or data kept within them. It makes use of PyJWT's <code>decode</code> function to get the claims encoded in a token and handle potential exceptions that might occur during the decoding process.</li> </ol> <pre><code>def decode_token(token: str) -&gt; dict:\n    try:\n        token_data = jwt.decode(\n            jwt=token,\n            algorithms=[Config.JWT_ALGORITHM]\n        )\n\n        return token_data\n    except jwt.PyJWTError as jwte:\n        logging.exception(jwte)\n        return None\n\n    except Exception as e:\n        logging.exception(e)\n        return None\n</code></pre> <p>It takes a JWT as a string <code>token</code> and attempts to decode it with a specified algorithm from the configuration <code>Config.JWT_ALGORITHM</code>. If the decoding process is successful, it returns a dictionary containing the decoded <code>token_data</code>. If a <code>jwt.PyJWTError</code> or any other exception occurs during the decoding process, the function logs the exception using the <code>logging.exception</code> method and returns <code>None</code>.</p> <p>This ensures that any errors encountered while decoding the token are captured and logged, helping with debugging and preventing the application from crashing due to unhandled exceptions.</p> <p>Note</p> <p>Using <code>PyJWTError</code> is a very effective way of catching all exceptions that arise from PyJWT since it is the base class from which they are built.</p>"},{"location":"chapter9/#creating-the-login-endpoint","title":"Creating the Login Endpoint","text":"<p>Now that we have an idea of how we shall create and decode tokens, let us build on top of this to create the login endpoint. This is going to follow the following steps;</p> <ol> <li>User Submission: The user submits an email and password.</li> <li>Server Verification: The server verifies if the user exists and their password matches the stored password hash in the database.</li> <li>Token Generation:</li> <li>If the verification is successful, an access token and a refresh token are granted to the user, allowing them to log in.</li> <li>If the verification fails, an exception is raised to indicate that the provided credentials are invalid.</li> </ol> the login endpoint<pre><code># src/auth/routes.py\nfrom fastapi import APIRouter, Depends, status\nfrom .schemas import UserLoginModel\nfrom .service import UserService\nfrom src.db.main import get_session\nfrom sqlmodel.ext.asyncio.session import AsyncSession\nfrom fastapi.exceptions import HTTPException\nfrom .utils import create_access_token, verify_password\nfrom fastapi.responses import JSONResponse\n\nauth_router = APIRouter()\nuser_service = UserService()\n\n\n@auth_router.post(\"/login\")\nasync def login_users(\n    login_data: UserLoginModel, session: AsyncSession = Depends(get_session)\n):\n    email = login_data.email\n    password = login_data.password\n\n    user = await user_service.get_user_by_email(email, session)\n\n    if user is not None:\n        password_valid = verify_password(password, user.password_hash)\n\n        if password_valid:\n            access_token = create_access_token(\n                user_data={\"email\": user.email, \"user_uid\": str(user.uid)}\n            )\n\n            refresh_token = create_access_token(\n                user_data={\"email\": user.email, \"user_uid\": str(user.uid)},\n                refresh=True,\n                expiry=timedelta(days=REFRESH_TOKEN_EXPIRY),\n            )\n\n            return JSONResponse(\n                content={\n                    \"message\": \"Login successful\",\n                    \"access_token\": access_token,\n                    \"refresh_token\": refresh_token,\n                    \"user\": {\"email\": user.email, \"uid\": str(user.uid)},\n                }\n            )\n\n    raise HTTPException(\n        status_code=status.HTTP_403_FORBIDDEN, detail=\"Invalid Email Or Password\"\n    )\n</code></pre> <p>This code defines an endpoint for user login. Using the <code>auth_router</code> object, we define the <code>login</code> path which we shall use for logging in users. The <code>login_users</code> function is handles POST requests to the /login endpoint. This function accepts <code>login_data</code>, which includes the user's email and password, and a <code>session</code> dependency session provided by <code>Depends(get_session)</code>.</p> <p>Within the <code>login_users</code> function, the user's email and password are extracted from <code>login_data</code> which is an object from <code>UserLoginModel</code>.</p> The UserLoginModel<pre><code># inside src/auth/routes.py\nclass UserLoginModel(BaseModel):\n    email: str = Field(max_length=40)\n    password: str  = Field(min_length=6)\n</code></pre> <p>The <code>user_service.get_user_by_email</code> function is then called to retrieve the user from the database using the provided email. If the user is found, the password provided is verified against the stored password hash using the <code>verify_password function</code>. If the password is valid, an <code>access_token</code> and a <code>refresh_token</code> are generated using the <code>create_access_token function</code>. The tokens and user information are returned in a JSON response indicating a successful login. If the user is not found or the password is invalid, an HTTP 403 Forbidden exception is raised, indicating that the email or password is incorrect.</p> <p>Let us test this endpoint in Insomnia. Make a request with correct email and password. </p> <p>Giving invalid credentials results into the following. </p>"},{"location":"chapter9/#http-bearer-authentication","title":"HTTP Bearer Authentication","text":"<p>Now that we can grant access tokens to users, we need to protect our API endpoints such that users require to provide access tokens to access them. This is where HTTP Bearer Authentication comes in. HTTP Bearer Authentication is an HTTP authentication scheme that involves security tokens called Bearer Tokens. This can be understood as \"give accewss to the bearer of the token\". Everytime a client is to make a request to a protected endpoint, they must send a string in form of <code>Bearer &lt;token&gt;</code> in the request's <code>Authorization</code> header.</p> <p>FastAPI comes really packed with many security classes that can allow for the implementation of different forms of Authentication such as Basic Authentication, OAuth2, OpenID Connect and HTTP Bearer. To use HTTPBearer Authentication, we shall make use of FastAPI's <code>HTTPBearer</code> class. THis is its definition. The HTTPBearer class<pre><code>... # the rest of fastapi/security/http.py\nclass HTTPBearer(HTTPBase):\n    def __init__(\n        self,\n        *,\n        bearerFormat: Annotated[Optional[str], Doc(\"Bearer token format.\")] = None,\n        scheme_name: Annotated[\n            Optional[str],\n            Doc(\n                \"\"\"\n                Security scheme name.\n\n                It will be included in the generated OpenAPI (e.g. visible at `/docs`).\n                \"\"\"\n            ),\n        ] = None,\n        description: Annotated[\n            Optional[str],\n            Doc(\n                \"\"\"\n                Security scheme description.\n\n                It will be included in the generated OpenAPI (e.g. visible at `/docs`).\n                \"\"\"\n            ),\n        ] = None,\n        auto_error: Annotated[\n            bool,\n            Doc(\n                \"\"\"\n                By default, if the HTTP Bearer token not provided (in an\n                `Authorization` header), `HTTPBearer` will automatically cancel the\n                request and send the client an error.\n\n                If `auto_error` is set to `False`, when the HTTP Bearer token\n                is not available, instead of erroring out, the dependency result will\n                be `None`.\n\n                This is useful when you want to have optional authentication.\n\n                It is also useful when you want to have authentication that can be\n                provided in one of multiple optional ways (for example, in an HTTP\n                Bearer token or in a cookie).\n                \"\"\"\n            ),\n        ] = True,\n    ):\n        self.model = HTTPBearerModel(bearerFormat=bearerFormat, description=description)\n        self.scheme_name = scheme_name or self.__class__.__name__\n        self.auto_error = auto_error\n\n    async def __call__(\n        self, request: Request\n    ) -&gt; Optional[HTTPAuthorizationCredentials]:\n        authorization = request.headers.get(\"Authorization\")\n        scheme, credentials = get_authorization_scheme_param(authorization)\n        if not (authorization and scheme and credentials):\n            if self.auto_error:\n                raise HTTPException(\n                    status_code=HTTP_403_FORBIDDEN, detail=\"Not authenticated\"\n                )\n            else:\n                return None\n        if scheme.lower() != \"bearer\":\n            if self.auto_error:\n                raise HTTPException(\n                    status_code=HTTP_403_FORBIDDEN,\n                    detail=\"Invalid authentication credentials\",\n                )\n            else:\n                return None\n        return HTTPAuthorizationCredentials(scheme=scheme, credentials=credentials)\n</code></pre></p> <p>The <code>HTTPBearer</code> class extends <code>HTTPBase</code> to provide HTTP Bearer token authentication. This class allows you to create an instance that can be used as a dependency via <code>Depends()</code>. When invoked, the dependency returns an <code>HTTPAuthorizationCredentials</code> object containing the authentication scheme and credentials. In the constructor, optional parameters such as bearerFormat, scheme_name, description, and auto_error are defined, allowing customization of the bearer token format, security scheme name, and description as shown in the generated OpenAPI documentation. The auto_error parameter determines whether an error is automatically raised if the token is not provided or invalid, enabling optional authentication if set to False.</p> <p>The <code>__call__</code> method of the <code>HTTPBearer</code> class processes incoming requests by extracting the <code>Authorization</code> header and validating its content. It parses the header to separate the scheme and credentials, checking if they are present and if the scheme matches \"bearer\". If the token is missing or invalid, and auto_error is True, an HTTP 403 Forbidden exception is raised. If <code>auto_error</code> is False, the method returns None instead of raising an exception, allowing the endpoint to handle the absence of credentials gracefully. This functionality is particularly useful for endpoints that require optional or multiple methods of authentication.</p> <p>Now that we have an understanding of this class, let us extend it to use it to protect  our API endpoints. To begin, we shall create a <code>dependencies.py</code> file inside the auth directory.  dependencies.py<pre><code>from fastapi.security import HTTPBearer\n\n\nclass AccessTokenBearer(HTTPBearer):\n    pass\n</code></pre></p> <p>By doing so, we have created the <code>AccessTokenBearer</code> class we are going to use  to create a dependency that we shall inject inside every path handler function that belongs to any endpoints that need protection. Let us start with the CRUD endpoints we created in the previous chapters.</p> src/books/routes.py<pre><code>from fastapi import APIRouter, status, Depends\nfrom fastapi.exceptions import HTTPException\nfrom src.books.schemas import Book, BookUpdateModel, BookCreateModel\nfrom sqlmodel.ext.asyncio.session import AsyncSession\nfrom src.books.service import BookService\nfrom src.db.main import get_session\nfrom typing import List\nfrom src.auth.dependencies import AccessTokenBearer\n\n\nbook_router = APIRouter()\nbook_service = BookService()\nacccess_token_bearer = AccessTokenBearer()\n\n\n@book_router.get(\"/\", response_model=List[Book])\nasync def get_all_books(\n    session: AsyncSession = Depends(get_session),\n    token_details=Depends(acccess_token_bearer),\n):\n    books = await book_service.get_all_books(session)\n    return books\n\n... #rest of the code\n</code></pre> <p>In the code above, what we have done is to import the <code>AccessTokenBearer</code> class and create an object called <code>access_token_bearer</code> that we provide as a dependency to the path handler via <code>Depends()</code>. By doing that, we have protected an endpoints and made it a requirement for us to access it by using an <code>Authorization</code> Header in the request.</p> <p>Making the request without the header being set results into the following. The user wont access the resources because they are not authenticated. </p> <p>Providing the Authorization headers results into a successful response. </p> <p>While this is enough to add protection to API  endpoints, we may want to customize it by adding our own checks. Let us modify our <code>AccessTokenBearer</code> class to allow for those checks to be made. </p> Modified AccessTokenBearer class<pre><code># inside src/auth/dependendencies.py\nclass AccessTokenBearer(HTTPBearer):\n\n    def __init__(self, auto_error=True):\n        super().__init__(auto_error=auto_error)\n\n    async def __call__(self, request: Request) -&gt; HTTPAuthorizationCredentials | None:\n        creds = await super().__call__(request)\n\n        token = creds.credentials\n\n        if not self.token_valid(token):\n            raise HTTPException(\n                status_code=status.HTTP_403_FORBIDDEN, detail={\n                    \"error\":\"This token is invalid or expired\",\n                    \"resolution\":\"Please get new token\"\n                }\n            )\n\n\n        return token_data\n\n    def token_valid(self, token: str) -&gt; bool:\n\n        token_data = decode_token(token)\n\n        return token_data is not None \n</code></pre> <p>We begin by initializing the class with the <code>__init__</code> method, which accepts an optional <code>auto_error</code> parameter, defaulting to <code>True</code>, and passes this to the parent <code>HTTPBearer</code> class. The core functionality is in the <code>__call__</code> method, which makes instances of the class callable. This asynchronous method takes a <code>Request</code> object, extracts the authorization credentials by calling the <code>__call__</code> method of the parent class, and retrieves the token from these credentials.</p> <p>Once the token is extracted, the <code>token_valid</code> method is invoked to verify the token's validity. This method attempts to decode the token using a <code>decode_token</code> function (that we defined in <code>src/auth/utils.py</code>). If <code>decode_token</code> successfully decodes the token, it returns some <code>token_data</code>; otherwise, it returns <code>None</code>. The <code>token_valid</code> method returns <code>True</code> if <code>token_data</code> is not <code>None</code>, indicating the token is valid, and <code>False</code> otherwise.</p> <p>Back in the <code>__call__</code> method, if the token is found to be invalid, an <code>HTTPException</code> is raised with a status code of <code>403 Forbidden</code>, accompanied by a detailed message indicating that the token is invalid or expired and advising the user to obtain a new token. If the token is valid, the decoded token data is returned. This mechanism ensures that only requests with valid tokens are processed further, enhancing the security of the application by preventing unauthorized access.</p> <p>We have now protected API Enpoints for CRUD on books so that they can only be accessed by providing a JWT in the Authorization header. Our routes for books should look like this. Modified book API endpoints with HTTP Bearer Auth<pre><code>from fastapi import APIRouter, status, Depends\nfrom fastapi.exceptions import HTTPException\nfrom src.books.schemas import Book, BookUpdateModel, BookCreateModel\nfrom sqlmodel.ext.asyncio.session import AsyncSession\nfrom src.books.service import BookService\nfrom src.db.main import get_session\nfrom typing import List\nfrom src.auth.dependencies import AccessTokenBearer\n\n\nbook_router = APIRouter()\nbook_service = BookService()\nacccess_token_bearer = AccessTokenBearer()\n\n\n@book_router.get(\"/\", response_model=List[Book])\nasync def get_all_books(\n    session: AsyncSession = Depends(get_session),\n    token_details=Depends(acccess_token_bearer),\n):\n\n    print(token_details)\n    books = await book_service.get_all_books(session)\n    return books\n\n\n@book_router.post(\n    \"/\",\n    status_code=status.HTTP_201_CREATED,\n    response_model=Book,\n)\nasync def create_a_book(\n    book_data: BookCreateModel,\n    session: AsyncSession = Depends(get_session),\n    token_details=Depends(acccess_token_bearer),\n) -&gt; dict:\n    new_book = await book_service.create_book(book_data, session)\n    return new_book\n\n\n@book_router.get(\"/{book_uid}\", response_model=Book)\nasync def get_book(\n    book_uid: str,\n    session: AsyncSession = Depends(get_session),\n    token_details=Depends(acccess_token_bearer),\n) -&gt; dict:\n    book = await book_service.get_book(book_uid, session)\n\n    if book:\n        return book\n    else:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND, detail=\"Book not found\"\n        )\n\n\n@book_router.patch(\"/{book_uid}\", response_model=Book)\nasync def update_book(\n    book_uid: str,\n    book_update_data: BookUpdateModel,\n    session: AsyncSession = Depends(get_session),\n    token_details=Depends(acccess_token_bearer),\n) -&gt; dict:\n\n    updated_book = await book_service.update_book(book_uid, book_update_data, session)\n\n    if updated_book is None:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND, detail=\"Book not found\"\n        )\n\n    else:\n        return updated_book\n\n\n@book_router.delete(\"/{book_uid}\", status_code=status.HTTP_204_NO_CONTENT)\nasync def delete_book(\n    book_uid: str,\n    session: AsyncSession = Depends(get_session),\n    token_details=Depends(acccess_token_bearer),\n):\n    book_to_delete = await book_service.delete_book(book_uid, session)\n\n    if book_to_delete is None:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND, detail=\"Book not found\"\n        )\n    else:\n\n        return {}\n</code></pre></p>"},{"location":"chapter9/#renew-user-access-with-refresh-tokens","title":"Renew User Access with Refresh Tokens","text":"<p>Now that we have implemented protection for our routes, we need to handle renewing user access by using refresh tokens. Refresh tokens are designed to be long-lived tokens that enable users to obtain new access tokens. Let's implement this functionality. To begin, we are going to refactor our dependencies so that we allow validation even for acess tokens.</p> modified dependencies<pre><code>from fastapi import Request, status\nfrom fastapi.security import HTTPBearer\nfrom fastapi.security.http import HTTPAuthorizationCredentials\nfrom .utils import decode_token\nfrom fastapi.exceptions import HTTPException\n\n\nclass TokenBearer(HTTPBearer):\n\n    def __init__(self, auto_error=True):\n        super().__init__(auto_error=auto_error)\n\n    async def __call__(self, request: Request) -&gt; HTTPAuthorizationCredentials | None:\n        creds = await super().__call__(request)\n\n        token = creds.credentials\n\n        token_data = decode_token(token)\n\n        if not self.token_valid(token):\n            raise HTTPException(\n                status_code=status.HTTP_403_FORBIDDEN, detail={\n                    \"error\":\"This token is invalid or expired\",\n                    \"resolution\":\"Please get new token\"\n                }\n            )\n\n\n        self.verify_token_data(token_data)\n\n        return token_data\n\n    def token_valid(self, token: str) -&gt; bool:\n\n        token_data = decode_token(token)\n\n        return token_data is not None \n\n    def verify_token_data(self, token_data):\n        raise NotImplementedError(\"Please Override this method in child classes\")\n\n\nclass AccessTokenBearer(TokenBearer):\n\n    def verify_token_data(self, token_data: dict) -&gt; None:\n        if token_data and token_data[\"refresh\"]:\n            raise HTTPException(\n                status_code=status.HTTP_403_FORBIDDEN,\n                detail=\"Please provide an access token\",\n            )\n\n\nclass RefreshTokenBearer(TokenBearer):\n    def verify_token_data(self, token_data: dict) -&gt; None:\n        if token_data and not token_data[\"refresh\"]:\n            raise HTTPException(\n                status_code=status.HTTP_403_FORBIDDEN,\n                detail=\"Please provide a refresh token\",\n            )\n</code></pre> <p>This code establishes a system for managing both access and refresh token authentication in a FastAPI application. It begins with the <code>TokenBearer</code> class, which extends the <code>HTTPBearer</code> class. The <code>TokenBearer</code> class overrides the <code>__call__</code> method to extract the token from incoming requests and decode it using the <code>decode_token</code> function. If the token is invalid, indicated by a failed decode, it raises an <code>HTTPException</code> with a <code>403 Forbidden</code> status. Additionally, the <code>verify_token_data</code> method is designed to be overridden by subclasses, enabling specific checks on the token data to ensure the token's purpose aligns with the request's requirements.</p> <p>The system is further refined with two subclasses: <code>AccessTokenBearer</code> and <code>RefreshTokenBearer</code>. The <code>AccessTokenBearer</code> subclass overrides the <code>verify_token_data</code> method to ensure that the provided token is an access token. It does this by checking if the <code>refresh</code> field in the token data is <code>False</code>, raising an exception if it is a refresh token. On the other hand, the <code>RefreshTokenBearer</code> subclass ensures that the token is a refresh token by checking if the <code>refresh</code> field is <code>True</code>, raising an exception if it is not. This dual approach allows the application to handle authentication using both access and refresh tokens effectively, ensuring appropriate validation and error handling for each token type. </p> <p>With that out of the way, we can now creat the endpoint that will be used to generate new access tokens when a user provides a refresh token. Inside <code>src/auth/routes.py</code>, let us add the following code. API path for creating new access tokens with a refresh token<pre><code>@auth_router.get(\"/refresh_token\")\nasync def get_new_access_token(token_details: dict = Depends(RefreshTokenBearer())):\n    expiry_timestamp = token_details[\"exp\"]\n\n    if datetime.fromtimestamp(expiry_timestamp) &gt; datetime.now():\n        new_access_token = create_access_token(user_data=token_details[\"user\"])\n\n        return JSONResponse(content={\"access_token\": new_access_token})\n\n    raise HTTPException(\n        status_code=status.HTTP_400_BAD_REQUEST, detail=\"Invalid Or expired token\"\n    )\n</code></pre></p> <p>This code defines an endpoint for obtaining a new access token using a refresh token in a FastAPI application. The endpoint is created at <code>/refresh_token</code> and is handled by the asynchronous function <code>get_new_access_token</code>. This function utilizes dependency injection with <code>Depends(RefreshTokenBearer())</code> to ensure that the request contains a valid refresh token. The <code>RefreshTokenBearer</code> class checks the token and returns its decoded data as <code>token_details</code>. Inside the function, the expiry timestamp is extracted from the token details, and a check is performed to determine if the refresh token is still valid by comparing the current time with the expiry timestamp. If the token is valid, a new access token is created using the <code>create_access_token</code> function, which takes user data from the refresh token, and a JSON response is returned containing the new access token.</p> <p>If the refresh token is found to be invalid or expired, an <code>HTTPException</code> is raised with a status code of <code>400 Bad Request</code> and an appropriate error message. This endpoint ensures that users can obtain fresh access tokens without needing to re-authenticate, thereby maintaining secure user sessions. By validating the refresh token and generating a new access token only if the refresh token is valid and not expired, the application enhances security and user experience. This mechanism helps streamline the process of renewing user access while preventing unauthorized access with expired or invalid tokens.</p>"},{"location":"chapter9/#revoking-tokens-using-redis","title":"Revoking Tokens Using Redis","text":"<p>Now that we have granted users access using access tokens, we also need a way to invalidate these tokens when users log out. We will implement this using a token blocklist. A token blocklist will store information about revoked JWTs, ensuring that they cannot be used to access protected endpoints. </p> <p>There are many options available, but in our case, we will use Redis for this purpose. Redis will provide us with a key-value store that will be sufficient for implementing this functionality.</p> <p>To use Redis with FastAPI, we are going to use Aioredis which is an asyncio based Python client for Redis. Through it, we shall get access to methods allowing us to interact with Redis using Python. So let us begin by installing it with;</p> Installing aioredis<pre><code>pip install aioredis\n</code></pre> <p>Once Aioredis has been installed, we are going to add this code to a new file called <code>src/db/redis.py</code> Functions to handle token revoking<pre><code># inside src/db/redis.py\n\nimport aioredis\nfrom src.config import Config\n\nJTI_EXPIRY = 3600\n\ntoken_blocklist = aioredis.StrictRedis(\n    host=Config.REDIS_HOST, port=Config.REDIS_PORT, db=0\n)\n\n\nasync def add_jti_to_blocklist(jti: str) -&gt; None:\n    await token_blocklist.set(name=jti, value=\"\", ex=JTI_EXPIRY)\n\n\nasync def token_in_blocklist(jti:str) -&gt; bool:\n   jti =  await token_blocklist.get(jti)\n\n   return jti is not None\n</code></pre></p> <p>This code snippet sets up a token blocklist using Redis. It begins by importing the aioredis library, and configuration settings from the project's config module. A constant JTI_EXPIRY is defined to set the expiration time for blocklist entries to 3600 seconds (1 hour). The Redis client token_blocklist is initialized using aioredis.StrictRedis, connecting to the Redis server with the specified host, port, and database number (db=0).</p> <p>The <code>add_jti_to_blocklist</code> function asynchronously adds a JWT ID (JTI) to the Redis blocklist, setting an expiration time for the entry. The <code>token_in_blocklist</code> function checks if a given JTI is in the blocklist by attempting to retrieve it from Redis; it returns <code>True</code> if the JTI is found and <code>False</code> otherwise. </p> <p>Once we have created these, we need to update our <code>TokenBearer</code> function to accomodate the checks for a token being in the token blocklist. </p> Updated __call__ method<pre><code>from src.db.redis import token_in_blocklist\n\nclass TokenBearer(HTTPBearer):\n\n    def __init__(self, auto_error=True):\n        super().__init__(auto_error=auto_error)\n\n    async def __call__(self, request: Request) -&gt; HTTPAuthorizationCredentials | None:\n        creds = await super().__call__(request)\n\n        token = creds.credentials\n\n        token_data = decode_token(token)\n\n        # add this \n        if await token_in_blocklist(token_data['jti']):\n            raise HTTPException(\n                status_code=status.HTTP_403_FORBIDDEN, detail={\n                    \"error\":\"This token is invalid or has been revoked\",\n                    \"resolution\":\"Please get new token\"\n                }\n            )\n</code></pre> <p>To implement the logout functionality by adding the token to the blocklist, we'll create the logout endpoint. This endpoint will ensure the token is not already in the blocklist before proceeding to block it.</p> <p>the logout endpoint<pre><code>from fastapi import APIRouter, Depends, status\nfrom .schemas import UserCreateModel, UserModel, UserLoginModel\nfrom .service import UserService\nfrom src.db.main import get_session\nfrom sqlmodel.ext.asyncio.session import AsyncSession\nfrom fastapi.exceptions import HTTPException\nfrom .utils import create_access_token, verify_password\nfrom fastapi.responses import JSONResponse\nfrom datetime import timedelta, datetime\nfrom .dependencies import RefreshTokenBearer,AccessTokenBearer\nfrom src.db.redis import add_jti_to_blocklist\n\nauth_router = APIRouter()\nuser_service = UserService()\n\n\n... #the rest of the code in src/auth/routes.py\n\n\n@auth_router.get('/logout')\nasync def revoke_token(token_details:dict=Depends(AccessTokenBearer())):\n\n    jti = token_details['jti']\n\n    await add_jti_to_blocklist(jti)\n\n    return JSONResponse(\n        content={\n            \"message\":\"Logged Out Successfully\"\n        },\n        status_code=status.HTTP_200_OK\n    )\n</code></pre> The logout endpoint will be found on the <code>/logout</code> path. It is secured by the <code>AccessTokenBearer</code> class, which requires a valid access token for access. Upon receiving the token, we retrieve the relevant details <code>token_details</code> from the dependency and extract the token's JTI (JWT ID). We then call the <code>add_jti_to_blocklist</code> function to add this JTI to the blocklist in Redis. After successfully adding the JTI to the blocklist, we return a response indicating the success of the operation.</p> <p>Let us test this out in the client. Let us begin by get a new token pair from the Login endpoint, </p> <p>Using the new access token, let us try to access the endpoint for listing all books. </p> <p>Let us now revoke this token by accessing the token by using the logging endpoint. </p> <p>Notice how this token cannot be used to list all books again. So this shows how revoked access tokens can not be used to access a protected endpoint. </p>"},{"location":"chapter9/#conclusion","title":"Conclusion","text":"<p>At this point, we have covered several key aspects of implementing JWT authentication in a FastAPI application. We started by granting users access using access tokens. We then explored protecting endpoints with HTTP Bearer Authentication, ensuring that users can only access them with valid tokens. Additionally, we implemented a way for users to renew their access tokens using refresh tokens when their current tokens expire. Finally, we demonstrated how to revoke tokens using Redis, preventing them from being used to access protected endpoints.</p>"}]}